<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/3.4.2" created="2013-04-22 06:59" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>长颈鹿~mdk a vimer~fork</title>
	<link>http://10.131.10.73/mdk-vimer</link>
	<description>小站之linuxsir mdk  A Vimer !!!!</description>
	<pubDate>Mon, 22 Apr 2013 06:59:59 +0000</pubDate>
	<language>en-US</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://10.131.10.73/mdk-vimer</wp:base_site_url>
	<wp:base_blog_url>http://10.131.10.73/mdk-vimer</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login>root</wp:author_login><wp:author_email>mengdaikun@gmail.com</wp:author_email><wp:author_display_name><![CDATA[root]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

	<wp:category><wp:term_id>1</wp:term_id><wp:category_nicename>uncategorized</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Uncategorized]]></wp:cat_name></wp:category>
	<wp:term><wp:term_id>5</wp:term_id><wp:term_taxonomy>nav_menu</wp:term_taxonomy><wp:term_slug>mdk</wp:term_slug><wp:term_name><![CDATA[mdk]]></wp:term_name></wp:term>

	<generator>http://wordpress.org/?v=3.4.2</generator>

	<item>
		<title>shell</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=8</link>
		<pubDate>Sun, 18 Nov 2012 05:15:39 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?page_id=8</guid>
		<description></description>
		<content:encoded><![CDATA[shell和批处理是差不多的~awk,sed,grep是利器~vim和emace是神器~~学shell是系统管理员和运维工程师的必备~ <a href="http://acm.cjlu.edu.cn">http://acm.cjlu.edu.cn</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>8</wp:post_id>
		<wp:post_date>2012-11-18 05:15:39</wp:post_date>
		<wp:post_date_gmt>2012-11-18 05:15:39</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>closed</wp:ping_status>
		<wp:post_name>shell</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>python </title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=32</link>
		<pubDate>Sun, 18 Nov 2012 06:14:06 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?page_id=32</guid>
		<description></description>
		<content:encoded><![CDATA[python简单易学~~搞完shell来python轻轻松松~~python与linux&amp;&amp;unix的管理~~python也面向对象编程~threading~socket编程~~python的世界你准备好了吗~~跨平台的额~~还是先占坑有空上经验和代码]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>32</wp:post_id>
		<wp:post_date>2012-11-18 06:14:06</wp:post_date>
		<wp:post_date_gmt>2012-11-18 06:14:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>python</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>unix/linux </title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=34</link>
		<pubDate>Sun, 18 Nov 2012 06:14:20 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?page_id=34</guid>
		<description></description>
		<content:encoded><![CDATA[今天跑上跑下的来往图书馆~~终于借到了《高性能linux服务器构建实战》~~用的天师的卡~~哈哈~~又得到一本神书~华章科技就是牛哈哈~~奋斗吧Acmer!!!!]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>34</wp:post_id>
		<wp:post_date>2012-11-18 06:14:20</wp:post_date>
		<wp:post_date_gmt>2012-11-18 06:14:20</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>linux</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>ACM</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=47</link>
		<pubDate>Wed, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?page_id=47</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>47</wp:post_id>
		<wp:post_date>2012-11-18 06:21:58</wp:post_date>
		<wp:post_date_gmt>0000-00-00 00:00:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name></wp:post_name>
		<wp:status>draft</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>c/c++</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=53</link>
		<pubDate>Thu, 22 Nov 2012 12:51:54 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?page_id=53</guid>
		<description></description>
		<content:encoded><![CDATA[c的世界是完美的~c++有了对象的c,java是c++的程序员写出来的~~c++写个半年一载还是不知所云~发现其什么都能干~~又好像什么都不能干~java学完后就立马能知道它拿来干嘛的~~计算机的底层就剩指针了~指针是把双刃刀~~你做好准备了吗？？kernel指针所向披靡~还是占坑啦]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>53</wp:post_id>
		<wp:post_date>2012-11-22 12:51:54</wp:post_date>
		<wp:post_date_gmt>2012-11-22 12:51:54</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>cc</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>面试与笔试</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=59</link>
		<pubDate>Thu, 22 Nov 2012 12:53:26 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?page_id=59</guid>
		<description></description>
		<content:encoded><![CDATA[经历分享]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>59</wp:post_id>
		<wp:post_date>2012-11-22 12:53:26</wp:post_date>
		<wp:post_date_gmt>2012-11-22 12:53:26</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>linuxkernel</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>ACM</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=61</link>
		<pubDate>Thu, 22 Nov 2012 12:53:41 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?page_id=61</guid>
		<description></description>
		<content:encoded><![CDATA[从大一就开始接触ACM了~接触最早的是ubuntu~算法和数据结构的世界是美好的~~搞了两年多的ACM~感触颇多~首先算法和数据结构是IT人的内功~算法可以活跃人的思维~ACM要靠三个人的彼此合作~做题也好比一个软件工程~要有测试和主力~当主力敲完核心算法后~测试要提供测试数据~~要找出bug的最好了~~先说这么多~~有空再说

跟学弟们说算好好搞ACM算法和数据结构~~但没有一个听进去~搞python的~~玩java 的哎~~有个SB的打酱油的~进来两年啥都没做就学会了追牛~~~擦擦擦]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>61</wp:post_id>
		<wp:post_date>2012-11-22 12:53:41</wp:post_date>
		<wp:post_date_gmt>2012-11-22 12:53:41</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>acm</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>windows</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=63</link>
		<pubDate>Thu, 22 Nov 2012 12:54:27 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?page_id=63</guid>
		<description></description>
		<content:encoded><![CDATA[windows 说啥好呢？╮(╯▽╰)╭~~一个大众化的操作系统~~图形化操作~~任何一个人都可以用的起~windwos做得很棒~coder要耍得起windows~玩得起unix/linux~telnet ip port 跳转则对方的port处于开放状态~netstat -an 查看所有本机连接的port和主机~windwos程序设计~win32 API ~是基础 ~MFC就是封装了API~╮(╯▽╰)╭~批处理确实可以实现很多自动化的东西~]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>63</wp:post_id>
		<wp:post_date>2012-11-22 12:54:27</wp:post_date>
		<wp:post_date_gmt>2012-11-22 12:54:27</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>windows</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://10.131.10.73/mdk-vimer/?p=65</link>
		<pubDate>Thu, 22 Nov 2012 12:54:52 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?p=65</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>65</wp:post_id>
		<wp:post_date>2012-11-22 12:54:52</wp:post_date>
		<wp:post_date_gmt>2012-11-22 12:54:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>65</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>1</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="mdk"><![CDATA[mdk]]></category>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[63]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://10.131.10.73/mdk-vimer/?p=66</link>
		<pubDate>Thu, 22 Nov 2012 12:54:52 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?p=66</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>66</wp:post_id>
		<wp:post_date>2012-11-22 12:54:52</wp:post_date>
		<wp:post_date_gmt>2012-11-22 12:54:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>66</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>2</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="mdk"><![CDATA[mdk]]></category>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[61]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://10.131.10.73/mdk-vimer/?p=67</link>
		<pubDate>Thu, 22 Nov 2012 12:54:52 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?p=67</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>67</wp:post_id>
		<wp:post_date>2012-11-22 12:54:52</wp:post_date>
		<wp:post_date_gmt>2012-11-22 12:54:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>67</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>3</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="mdk"><![CDATA[mdk]]></category>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[59]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://10.131.10.73/mdk-vimer/?p=68</link>
		<pubDate>Thu, 22 Nov 2012 12:54:52 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?p=68</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>68</wp:post_id>
		<wp:post_date>2012-11-22 12:54:52</wp:post_date>
		<wp:post_date_gmt>2012-11-22 12:54:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>68</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>4</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="mdk"><![CDATA[mdk]]></category>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[53]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://10.131.10.73/mdk-vimer/?p=69</link>
		<pubDate>Thu, 22 Nov 2012 12:54:52 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?p=69</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>69</wp:post_id>
		<wp:post_date>2012-11-22 12:54:52</wp:post_date>
		<wp:post_date_gmt>2012-11-22 12:54:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>69</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>5</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="mdk"><![CDATA[mdk]]></category>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[34]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title></title>
		<link>http://10.131.10.73/mdk-vimer/?p=70</link>
		<pubDate>Thu, 22 Nov 2012 12:54:52 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?p=70</guid>
		<description></description>
		<content:encoded><![CDATA[ ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>70</wp:post_id>
		<wp:post_date>2012-11-22 12:54:52</wp:post_date>
		<wp:post_date_gmt>2012-11-22 12:54:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>70</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>6</wp:menu_order>
		<wp:post_type>nav_menu_item</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="nav_menu" nicename="mdk"><![CDATA[mdk]]></category>
		<wp:postmeta>
			<wp:meta_key>_menu_item_type</wp:meta_key>
			<wp:meta_value><![CDATA[post_type]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_menu_item_parent</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object_id</wp:meta_key>
			<wp:meta_value><![CDATA[32]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_object</wp:meta_key>
			<wp:meta_value><![CDATA[page]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_target</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_classes</wp:meta_key>
			<wp:meta_value><![CDATA[a:1:{i:0;s:0:"";}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_xfn</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_menu_item_url</wp:meta_key>
			<wp:meta_value><![CDATA[]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>linux内核</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=72</link>
		<pubDate>Thu, 22 Nov 2012 12:59:01 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?page_id=72</guid>
		<description></description>
		<content:encoded><![CDATA[内核引导-&gt;系统调用-&gt;内存管理-&gt;进程调用与管理-&gt;文件系统-&gt;应用层管理...............]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>72</wp:post_id>
		<wp:post_date>2012-11-22 12:59:01</wp:post_date>
		<wp:post_date_gmt>2012-11-22 12:59:01</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>linux%e5%86%85%e6%a0%b8%e7%ba%a2%e9%bb%91%e6%a0%91</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>20个位运算知道少??(1)</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=104</link>
		<pubDate>Wed, 19 Dec 2012 06:49:00 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=104</guid>
		<description></description>
		<content:encoded><![CDATA[/*
 * =====================================================================================
 *
 *       Filename:  weiyi1.cpp
 *
 *    Description:  位运算
 *
 *        Version:  1.0
 *        Created:  2012/12/19 13:05:23
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  mdk-vim.cpp-c (mdk), <a href="mailto:mengdaikun@gmail.com">mengdaikun@gmail.com</a>
 *        Company:  cjluacm-vim-mdk
 *
 * =====================================================================================
 */
int max1(int a,int b){
  return b &amp; ( (a-b) &gt;&gt; 31) | a &amp; (~(a-b) &gt;&gt; 31);
}
int max2(int x,int y){
  return x ^ ((x^y) &amp; -(x &lt; y));
}
int min1(int a,int b){
  return a &amp; ((a-b) &gt;&gt; 31) | b &amp; (~(a-b) &gt;&gt; 31);
}
int min2(int x,int y){
  return y ^ ((x^y) &amp; -(x &lt; y));
}
bool isSampSign(int x,int y){
  return (x^y) &gt;= 0;
}
int getTwo(int n){
 // 2^n
 return 2 &lt;&lt; (n-1);
}
bool isTwo(int n){
 return n &gt; 0 ? (n&amp;(n-1)) == 0:false;
}
int quyu(int m,int n){
  return m &amp; (n-1);
}
int getAgv1(int n,int m){
 return (n+m) &gt;&gt; 1;
}
int getAgv2(int x,int y){
 return ((x^y) &gt;&gt; 1) + (x&amp;y);
}
int getBit(int n,int m){  //从低位到高位 取n的第m位
 return (n &gt;&gt; (m-1)) &amp; 1;
}
int setBit1(int n,int m){ //从低位到高位 将n的第m位置1
 return n | (1 &lt;&lt; (m-1));
}
int setBit2(int n,int m){ //从低位到高位 将n的第m位置0
 return n &amp; ~(1 &lt;&lt; (m-1));
}
int getnum1(int n){
  //get n+1
  return -~n;
}
int getnum2(int n){
 return ~-n;
}
int getnum3(int n){
 return ~n + 1;
}
int main(int argc,char *argv[])
{
    int num1 = max1(3,5);
    int num2 = max2(3,5);
    int num3 = min1(3,5);
    int num4 = min2(3,5);
    cout&lt;&lt;getnum3(3)&lt;&lt;endl;
    //cout&lt;&lt;getBit2(4,1)&lt;&lt;endl;
    //cout&lt;&lt;getAgv1(3,5)&lt;&lt;" "&lt;&lt;getAgv2(3,5)&lt;&lt;endl;
    //cout&lt;&lt;quyu(2,4)&lt;&lt;" "&lt;&lt;quyu(5,3)&lt;&lt;endl;
    //cout&lt;&lt;isTwo(4)&lt;&lt;" "&lt;&lt;isTwo(5)&lt;&lt;endl;
    //cout&lt;&lt;getTwo(2)&lt;&lt;endl;
    //cout&lt;&lt;isSampSign(-1,2)&lt;&lt;endl;;
    //cout&lt;&lt;isSampSign(3,5)&lt;&lt;endl;
    //cout&lt;&lt;num3&lt;&lt;" "&lt;&lt;num4&lt;&lt;endl;
    //cout&lt;&lt;num1&lt;&lt;" "&lt;&lt;num2&lt;&lt;endl;
    return 0;
}]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>104</wp:post_id>
		<wp:post_date>2012-12-19 06:49:00</wp:post_date>
		<wp:post_date_gmt>2012-12-19 06:49:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>20%e4%b8%aa%e4%bd%8d%e8%bf%90%e7%ae%97%e7%9f%a5%e9%81%93%e5%b0%911</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>53</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>20位运算知道少(2)</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=106</link>
		<pubDate>Wed, 19 Dec 2012 06:51:13 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=106</guid>
		<description></description>
		<content:encoded><![CDATA[ 上午码出来的~~参照网上的
int getMaxInt1(){
  return ( 1 &lt;&lt; 31 ) - 1; //优先级括号不能省略
}
int getMaxInt2(){
  return ~( 1 &lt;&lt; 31 );
}
int getMaxInt3(){
  return ( 1 &lt;&lt; -1 ) - 1;  //gcc 不支持
}
int getMaxInt4(){
  return ( (unsigned int) - 1 ) &gt;&gt; 1;
}
int getMinInt5(){
  return 1 &lt;&lt; 31; //获取int类型的最小值
}
int getMinInt6(){
  return 1 &lt;&lt; -1; //gcc 不支持
}
int getMaxLong(){
  return ((unsigned long) - 1 ) &gt;&gt; 1;
}
int getMinLong(){
  return 1 &lt;&lt; 63;
}
int mulTwo(int n){
   return n &lt;&lt; 1;
}
int divTwo(int n){
  return n &gt;&gt; 1;
}
int mulTwoPower(int n,int m){
 //n*(2^m)
  return n &lt;&lt; m;
}
int divTwoPower(int n,int m){
 //n/(2^m)
  return n &gt;&gt; m;
}
bool isOddNumber(int n){
  return (n &amp; 1) == 1;
}
void swap1(int a,int b){
 a ^= b;
 b ^= a;
 a ^= b;
 cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;
}
void swap2(int *a,int *b){
 (*a) ^= (*b) ^= (*a) ^= (*b);
}
int abs(int n){
  return (n^( n &gt;&gt; 31 )) -( n &gt;&gt; 31 );
}
int main(int argc,char *argv[])
{
   /*
    *位运算的20则
    * */
    int max1 = getMaxInt1();
    int max2 = getMaxInt2();
    int max3 = getMaxInt4();
    int min1 = getMinInt5();
    int min2 = getMinInt6();
    int max4 = getMaxLong();
    int min3 = getMinLong();
    int num1 = mulTwo(2);
    int num2 = divTwo(2);
    int num3 = mulTwoPower(2,1);
    int num4 = divTwoPower(2,1);
    int num5 = isOddNumber(4);
    int num6 = isOddNumber(3);
    int a=3;
    int b=4;
    int a1=3;
    int b1=4;
    a ^= b;
    b ^= a;
    a ^= b;
    //cout&lt;&lt;a&lt;&lt;"  "&lt;&lt;b&lt;&lt;endl;
    //cout&lt;&lt;max1&lt;&lt;" "&lt;&lt;max2&lt;&lt;" "&lt;&lt;max3&lt;&lt;endl;
    //cout&lt;&lt;min1&lt;&lt;" "&lt;&lt;min2&lt;&lt;endl;
    //cout&lt;&lt;max4&lt;&lt;endl;
    //cout&lt;&lt;min3&lt;&lt;endl;
    //cout&lt;&lt;num1&lt;&lt;" "&lt;&lt;num2&lt;&lt;endl;
    //cout&lt;&lt;num3&lt;&lt;" "&lt;&lt;num4&lt;&lt;endl;
    //cout&lt;&lt;num5&lt;&lt;" "&lt;&lt;num6&lt;&lt;endl;
    //swap1(a,b);
    //cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;
    //swap2(&amp;a1,&amp;b1);
    //cout&lt;&lt;a1&lt;&lt;" "&lt;&lt;b1&lt;&lt;endl;
    int abs1 = abs(-5);
    cout&lt;&lt;abs1&lt;&lt;endl;
    return 0;
}]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>106</wp:post_id>
		<wp:post_date>2012-12-19 06:51:13</wp:post_date>
		<wp:post_date_gmt>2012-12-19 06:51:13</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>20%e4%bd%8d%e8%bf%90%e7%ae%97%e7%9f%a5%e9%81%93%e5%b0%912</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>53</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>linux利器之tcpdump</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=115</link>
		<pubDate>Fri, 21 Dec 2012 13:03:59 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=115</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>如下一些实例:</strong>

<strong>tcpdump -i <em>eth0</em></strong><em> </em>

其中，eth0为参数值，表示需要抓包的网口，这是个必需参数哦。

tcpdump支持很多的关键字，下面先看几个例子：

（例1）tcpdump -i <em>eth0</em> host <em>192.168.0.250 -----</em>在网口eth0上抓取主机地址为192.168.0.250的所有数据包。

（例2）tcpdump -i <em>eth0</em> net <em>192.168.0.0/24</em> ------ 在网口eth0上抓取网络地址为192.168.0.0/24的所有数据包

（例3）tcpdump -i <em>eth0</em> port <em>80</em> ------ 在网口eth0上抓取端口为80的所有数据包(注意，这里不区分是源端口还是目的端口)

当然，我们也可以指定源端口或目的端口

（例4）tcpdump -i <em>eth0</em> src port <em>80</em> and dst port<em>6100</em> --- 在网口eth0上抓取源端口为80且目的端口为6100的数据包，这里用到了and逻辑运算符，后面再介绍

（例5）tcpdump -i <em>eth0 icmp</em> --- 在网口eth0上抓取所有icmp协议的数据包

以上几个例子，可以大致体现出tcpdump的基本用法。

&nbsp;

实际上，tcpdump主要包括三种类型的关键字，第一种是关于类型的关键字，主要包括host，net，port，如上面的例（1）（2）（3），第二种

是确定传输方向的关键字，主要包括src，dst，src or dst，src and dst，这些关键字指明了传输的方向，如上面的例（4）。第三种是协议关键字，包括fddi，ip，arp，

rarp，tcp，udp，imcp等，如上面的例（5）。

除了这三种类型的关键字外，还有其他重要的关键字，如：gateway，broadcast，less，greater，还有三种逻辑运算，取非运算是'not'、'!'，与运算符是'and'、'&amp;&amp;'、

或运算符是'or'、'||'，这些关键字可以组合起来构成强大的组合条件来满足我们的需求。

&nbsp;

先看看tcpdump的具体参数及意义：

-i：指定tcpdump监听的网络接口

-s：指定要监听数据包的长度

-c：指定要监听的数据包数量，达到指定数量后自动停止抓包

-w：指定将监听到的数据包写入文件中保存

-A：指定将每个监听到的数据包以ACSII可见字符打印

-n：指定将每个监听到数据包中的域名转换成IP地址后显示

-nn：指定将每个监听到的数据包中的域名转换成IP、端口从应用名称转换成端口号后显示

-e：指定将监听到的数据包链路层的信息打印出来，包括源mac和目的mac，以及网络层的协议

-p：将网卡设置为非混杂模式，不能与host或broadcast一起使用

-r：指定从某个文件中读取数据包

-S：指定打印每个监听到的数据包的TCP绝对序列号而非相对序列号

&nbsp;

&nbsp;

OK，参数介绍先到这里，下面看几个具体例子

&nbsp;

tcpdump -i eth0 -s 1400 -nn host 192.168.0.250 and ! 192.168.0.74 and icmp -e

抓取网口eth0上192.168.0.250与除192.168.0.74外的其他主机之间的icmp报文

&nbsp;

tcpdump -i eth0 -s 1400 -nn tcp and \(host 192.168.0.250 and ! 192.168.0.74\)

抓取网口eth0上192.168.0.250与除192.168.0.74外的所有tcp数据包，这里用到了括号，注意，在tcpdump中使用括号时必须用转义。

tcpdump -i eth0 ether src or dst 00:21:85:6C:D9:A3

抓取网口eth0上源mac地址或目的mac地址为00:21:85:6C:D9:A3的所有数据包，注意，这里的mac地址格式必须以':'分隔。

&nbsp;

=============================================================================================================

下面是参考的一篇文章的原文<a href="http://linux.chinaitlab.com/administer/840012.html">http://linux.chinaitlab.com/administer/840012.html</a>：

&nbsp;

　　TCPDUMP简介

　　在传统的网络分析和<a href="http://softtest.chinaitlab.com/" target="_blank">测试</a>技术中，嗅探器(sniffer)是最常见，也是最重要的技术之一。sniffer工具首先是为网络管理员和网络程序员进行网络分析而设计的。对于网络管理人员来说，使用嗅探器可以随时掌握网络的实际情况，在网络性能急剧下降的时候，可以通过sniffer工具来分析原因，找出造成网络阻塞的来源。对于网络程序员来说,通过sniffer工具来调试程序。

　　用过windows平台上的sniffer工具(例如，netxray和sniffer pro软件)的朋友可能都知道，在共享式的局域网中，采用sniffer工具简直可以对网络中的所有流量一览无余！Sniffer工具实际上就是一个网络上的抓包工具，同时还可以对抓到的包进行分析。由于在共享式的网络中，信息包是会广播到网络中所有主机的网络接口，只不过在没有使用sniffer工具之前，主机的<a href="http://network.chinaitlab.com/" target="_blank">网络设备</a>会判断该信息包是否应该接收，这样它就会抛弃不应该接收的信息包，sniffer工具却使主机的<a href="http://network.chinaitlab.com/" target="_blank">网络设备</a>接收所有到达的信息包，这样就达到了网络监听的效果。

　　Linux作为网络<a href="http://server.chinaitlab.com/" target="_blank">服务器</a>，特别是作为<a href="http://cisco.chinaitlab.com/List_6.html" target="_blank">路由</a>器和网关时，数据的采集和分析是必不可少的。所以，今天我们就来看看Linux中强大的网络数据采集分析工具——TcpDump。

　　用简单的话来定义tcpdump，就是：dump the traffice on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。

　　作为<a href="http://internet.chinaitlab.com/" target="_blank">互联网</a>上经典的的系统管理员必备工具，tcpdump以其强大的功能，灵活的截取策略，成为每个高级的系统管理员分析网络，排查问题等所必备的东东之一。

　　顾名思义，TcpDump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、<a href="http://cisco.chinaitlab.com/List_11.html" target="_blank">协议</a>、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。

　　tcpdump提供了源代码，公开了接口，因此具备很强的可扩展性，对于网络维护和入侵者都是非常有用的工具。tcpdump存在于基本的FreeBSD系统中，由于它需要将网络界面设置为混杂模式，普通用户不能正常执行，但具备root权限的用户可以直接执行它来获取网络上的信息。因此系统中存在网络分析工具主要不是对本机<a href="http://security.chinaitlab.com/" target="_blank">安全</a>的威胁，而是对网络上的其他计算机的<a href="http://security.chinaitlab.com/" target="_blank">安全</a>存在威胁。

　　普通情况下，直接启动tcpdump将监视第一个网络界面上所有流过的数据包。

　　－－－－－－－－－－－－－－－－－－－－－－－

　　bash-2.02# tcpdump

　　tcpdump: listening on eth0

　　11:58:47.873028 202.102.245.40.netbios-ns &gt; 202.102.245.127.netbios-ns: udp 50

　　11:58:47.974331 0:10:7b:8:3a:56 &gt; 1:80:c2:0:0:0 802.1d ui/C len=43

　　0000 0000 0080 0000 1007 cf08 0900 0000

　　0e80 0000 902b 4695 0980 8701 0014 0002

　　000f 0000 902b 4695 0008 00

　　11:58:48.373134 0:0:e8:5b:6d:85 &gt; Broadcast sap e0 ui/C len=97

　　ffff 0060 0004 ffff ffff ffff ffff ffff

　　0452 ffff ffff 0000 e85b 6d85 4008 0002

　　0640 4d41 5354 4552 5f57 4542 0000 0000

　　0000 00

　　^C

　　－－－－－－－－－－－－－－－－－－－－－－－－

　　首先我们注意一下，从上面的输出结果上可以看出来，基本上tcpdump总的的输出格式为：系统时间 来源主机.端口 &gt; 目标主机.端口 数据包参数

　　TcpDump的参数化支持

　　tcpdump支持相当多的不同参数，如使用-i参数指定tcpdump监听的网络界面，这在计算机具有多个网络界面时非常有用，使用-c参数指定要监听的数据包数量，使用-w参数指定将监听到的数据包写入文件中保存，等等。

　　然而更复杂的tcpdump参数是用于过滤目的，这是因为网络中流量很大，如果不加分辨将所有的数据包都截留下来，数据量太大，反而不容易发现需要的数据包。使用这些参数定义的过滤规则可以截留特定的数据包，以缩小目标，才能更好的分析网络中存在的问题。tcpdump使用参数指定要监视数据包的类型、地址、端口等，根据具体的网络问题，充分利用这些过滤规则就能达到迅速定位故障的目的。请使用man tcpdump查看这些过滤规则的具体用法。

　　显然为了安全起见，不用作网络管理用途的计算机上不应该运行这一类的网络分析软件，为了屏蔽它们，可以屏蔽内核中的bpfilter伪设备。一般情况下网络硬件和TCP/IP堆栈不支持接收或发送与本计算机无关的数据包，为了接收这些数据包，就必须使用网卡的混杂模式，并绕过标准的TCP/IP堆栈才行。在FreeBSD下，这就需要内核支持伪设备bpfilter。因此，在内核中取消bpfilter支持，就能屏蔽tcpdump之类的网络分析工具。

　　并且当网卡被设置为混杂模式时，系统会在控制台和日志文件中留下记录，提醒管理员留意这台系统是否被用作攻击同网络的其他计算机的跳板。

　　May 15 16:27:20 host1 /kernel: fxp0: promiscuous mode enabled

　　虽然网络分析工具能将网络中传送的数据记录下来，但是网络中的数据流量相当大，如何对这些数据进行分析、分类统计、发现并报告错误却是更关键的问题。网络中的数据包属于不同的<a href="http://cisco.chinaitlab.com/List_11.html" target="_blank">协议</a>，而不同<a href="http://cisco.chinaitlab.com/List_11.html" target="_blank">协议</a>数据包的格式也不同。因此对捕获的数据进行解码，将包中的信息尽可能的展示出来，对于协议分析工具来讲更为重要。昂贵的商业分析工具的优势就在于它们能支持很多种类的应用层协议，而不仅仅只支持tcp、udp等低层协议。

　　从上面tcpdump的输出可以看出，tcpdump对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带-w参数的tcpdump 截获数据并保存到文件中，然后再使用其他程序进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘。

　　TCP功能

　　数据过滤

　　不带任何参数的TcpDump将搜索系统中所有的网络接口，并显示它截获的所有数据，这些数据对我们不一定全都需要，而且数据太多不利于分析。所以，我们应当先想好需要哪些数据，TcpDump提供以下参数供我们选择数据：

　　-b 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。

　　例如：tcpdump -b arp 将只显示网络中的arp即地址转换协议信息。

　　-i 选择过滤的网络接口，如果是作为路由器至少有两个网络接口，通过这个选项，就可以只过滤指定的接口上通过的数据。例如：

　　tcpdump -i eth0 只显示通过eth0接口上的所有报头。

　　src、dst、port、host、net、ether、gateway这几个选项又分别包含src、dst 、port、host、net、ehost等附加选项。他们用来分辨数据包的来源和去向，src host 192.168.0.1指定源主机IP地址是192.168.0.1，dst net 192.168.0.0/24指定目标是网络192.168.0.0。以此类推，host是与其指定主机相关无论它是源还是目的，net是与其指定网络相关的，ether后面跟的不是IP地址而是物理地址，而gateway则用于网关主机。可能有点复杂，看下面例子就知道了：

　　tcpdump src host 192.168.0.1 and dst net 192.168.0.0/24

　　过滤的是源主机为192.168.0.1与目的网络为192.168.0.0的报头。

　　tcpdump ether src 00:50:04:BA:9B and dst……

&nbsp;

&nbsp;

&nbsp;

　　过滤源主机物理地址为XXX的报头（为什么ether src后面没有host或者net？物理地址当然不可能有网络喽）。

　　Tcpdump src host 192.168.0.1 and dst port not telnet

　　过滤源主机192.168.0.1和目的端口不是telnet的报头。

　　ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型。

　　例如：

　　tcpdump ip src……

　　只过滤数据-链路层上的IP报头。

　　tcpdump udp and src host 192.168.0.1

　　只过滤源主机192.168.0.1的所有udp报头。

　　数据显示/输入输出

　　TcpDump提供了足够的参数来让我们选择如何处理得到的数据，如下所示：

　　-l 可以将数据重定向。

　　如tcpdump -l ＞tcpcap.txt将得到的数据存入tcpcap.txt文件中。

　　-n 不进行IP地址到主机名的转换。

　　如果不使用这一项，当系统中存在某一主机的主机名时，TcpDump会把IP地址转换为主机名显示，就像这样：eth0 ＜ ntc9.1165＞ router.domain.net.telnet，使用-n后变成了：eth0 ＜ 192.168.0.9.1165 ＞ 192.168.0.1.telnet。

　　-nn 不进行端口名称的转换。

　　上面这条信息使用-nn后就变成了：eth0 ＜ ntc9.1165 ＞ router.domain.net.23。

　　-N 不打印出默认的域名。

　　还是这条信息-N 后就是：eth0 ＜ ntc9.1165 ＞ router.telnet。

　　-O 不进行匹配代码的优化。

　　-t 不打印UNIX时间戳，也就是不显示时间。

　　-tt 打印原始的、未格式化过的时间。

　　-v 详细的输出，也就比普通的多了个TTL和服务类型。

　　［expression]的用法：

　　expression是tcpdump最为有用的高级用法，可以利用它来匹配一些特殊的包。下面介绍一下expression的用法，主要是如何写出符合要求最为严格expression。如果tcpdump中没有expression,那么tcpdump会把网卡上的所有数据包输出，否则会将被expression匹配的包输出。

　　expression 由一个或多个[primitives]组成，而[primitives]由一个或多个[qualitifer]加一个id(name)或数字组成，它们的结构如用正则表达式则可表示为：

　　expression = ([qualitifer］+(id|number))+

　　依次看来，expression是一个复杂的条件表达式，其中[qualitifer］+(id|number)就是一个比较基本条件，qualitifer就表达一些的名称（项，变量），id或number则表示一个值（或常量）。

　　qualitifer共有三种，分别是：

　　type 表示id name或number涉及到的类型，这些词有host, nest, port ,portrange等等。

　　例子：

　　host foo 此为一个简单的primitive，host为qualitifer, foo为id name

　　net 128.3 net为qualitifer, 128.3为number

　　port 20

　　等等

　　每个privimtive必须有一个type词，如果表达式中没有，则默认是host.

　　dir 指定数据传输的方向，这些词有src, dst, src or dst, src and dst

　　例子：

　　dst net 128.3 ;此为一个相对复杂的primitive,结构为dir type number,表示目标网络为128.3的条件。

　　src or dst port ftp-data 此为比上一个相对简的结构，src or dst表示源或目标，ftp-data为id，表示ftp协议中数据传输端口，故整体表示源或目标端口ftp-data的数据包即匹配。

　　如果在一个primitive中没有dir词，此默认为src or dst. 如 host foo则表示源或目标主机为foo的数据包都匹配。

　　proto 此种词是用来匹配某种特定协议的，这些词包括：ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet,tcp和udp。其实这些词经常用来匹配某种协议，是使用率最高的一组词了。

　　上面三种qualitifer和id name或number组成一个primitive通常是下面这种方式的：

　　proto dir type id(number) ，即primitive=proto dir type (id | number)

　　如：

　　tcp src port 80

　　ip dst host 192.168.1.1

　　如果出现type的话，一定会出现id或num

　　如果出现dir，那么也会出现type,如果不出现，默认为host

　　而proto可单独出现，如 tcpdump 'tcp'

　　通过上面介绍的三种qualitifer，我们很快就可以写出一个primitive，下面我就只用一个primitive作为expression匹配数据包。

　　(1)匹配ether包

　　匹配特定mac地址的数据包。

　　tcpdump 'ether src 00:19:21:1D:75:E6'

　　匹配源mac为00:19:21:1D:75:E6的数据包其中src可改为dst, src or dst来匹改变条件

&nbsp;

&nbsp;

&nbsp;

　　匹配ether广播包。ether广播包的特征是mac全1.故如下即可匹配：

　　tcpdump 'ether dst ff:ff:ff:ff:ff:ff'

　　<a href="mailto:ylin@ylin:~$">ylin@ylin:~$</a> sudo tcpdump -c 1 'ether dst ff:ff:ff:ff:ff:ff'

　　tcpdump: verbose output suppressed, use -v or -vv for full protocol decode

　　listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes

　　10:47:57.784099 arp who-has 192.168.240.77 tell 192.168.240.189

　　在此，只匹配1个包就退出了。第一个是arp请求包，arp请求包的是采用广播的方式发送的，被匹配那是当之无愧的。

　　匹配ether组播包，ether的组播包的特征是mac的最高位为1，其它位用来表示组播组编号，如果你想匹配其的多播组，知道它的组MAC地址即可。如

　　tcpdump 'ether dst &lt;Mac_Adrress&gt;' Mac_Address表示地址，填上适当的即可。如果想匹配所有的ether多播数据包，那么暂时请放下，下面会继续为你讲解更高级的应用。

　　(2)匹配arp包

　　arp包用于IP到Mac址转换的一种协议，包括arp请求和arp答应两种报文，arp请求报文是ether广播方式发送出去的，也即 arp请求报文的mac地址是全1，因此用ether dst FF;FF;FF;FF;FF;FF可以匹配arp请求报文，但不能匹配答应报文。因此要匹配arp的通信过程，则只有使用arp来指定协议。

　　tcpdump 'arp' 即可匹配网络上arp报文。

　　<a href="mailto:ylin@ylin:~$">ylin@ylin:~$</a> arping -c 4 192.168.240.1&gt;/dev/null&amp; sudo tcpdump -p 'arp'

　　[1] 9293

　　WARNING: interface is ignored: Operation not permitted

　　tcpdump: verbose output suppressed, use -v or -vv for full protocol decode

　　listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes

　　11:09:25.042479 arp who-has 192.168.240.1 (00:03:d2:20:04:28 (oui Unknown)) tell ylin.local

　　11:09:25.042702 arp reply 192.168.240.1 is-at 00:03:d2:20:04:28 (oui Unknown)

　　11:09:26.050452 arp who-has 192.168.240.1 (00:03:d2:20:04:28 (oui Unknown)) tell ylin.local

　　11:09:26.050765 arp reply 192.168.240.1 is-at 00:03:d2:20:04:28 (oui Unknown)

　　11:09:27.058459 arp who-has 192.168.240.1 (00:03:d2:20:04:28 (oui Unknown)) tell ylin.local

　　11:09:27.058701 arp reply 192.168.240.1 is-at 00:03:d2:20:04:28 (oui Unknown)

　　11:09:33.646514 arp who-has ylin.local tell 192.168.240.1

　　11:09:33.646532 arp reply ylin.local is-at 00:19:21:1d:75:e6 (oui Unknown)

　　本例中使用arping -c 4 192.168.240.1产生arp请求和接收答应报文，而tcpdump -p 'arp'匹配出来了。此处-p选项是使网络工作于正常模式（非混杂模式），这样是方便查看匹配结果。

　　(3)匹配IP包

　　众所周知，IP协议是TCP/IP协议中最重要的协议之一，正是因为它才能把Internet互联起来，它可谓功不可没，下面分析匹配IP包的表达式。

　　对IP进行匹配

　　tcpdump 'ip src 192.168.240.69'

　　<a href="mailto:ylin@ylin:~$">ylin@ylin:~$</a> sudo tcpdump -c 3 'ip src 192.168.240.69'

　　tcpdump: verbose output suppressed, use -v or -vv for full protocol decode

　　listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes

　　11:20:00.973605 IP ylin.local.51486 &gt; walnut.crossbeamsys.com.ssh: S 2706301341:2706301341(0) win 5840 &lt;mss 1460,sackOK,timestamp 1687608 0,nop,wscale 5&gt;

　　11:20:00.974328 IP ylin.local.32849 &gt; 192.168.200.150.domain: 5858+ PTR? 20.200.168.192.in-addr.arpa. (45)

　　11:20:01.243490 IP ylin.local.51486 &gt; walnut.crossbeamsys.com.ssh: . ack 2762262674 win 183 &lt;nop,nop,timestamp 1687676 4155416897&gt;

　　IP广播组播数据包匹配：只需指明广播或组播地址即可

　　tcpdump 'ip dst 240.168.240.255'

　　<a href="mailto:ylin@ylin:~$">ylin@ylin:~$</a> sudo tcpdump 'ip dst 192.168.240.255'

　　tcpdump: verbose output suppressed, use -v or -vv for full protocol decode

　　listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes

　　11:25:29.690658 IP dd.local &gt; 192.168.240.255: ICMP echo request, id 10022, seq 1, length 64

　　11:25:30.694989 IP dd.local &gt; 192.168.240.255: ICMP echo request, id 10022, seq 2, length 64

　　11:25:31.697954 IP dd.local &gt; 192.168.240.255: ICMP echo request, id 10022, seq 3, length 64

　　11:25:32.697970 IP dd.local &gt; 192.168.240.255: ICMP echo request, id 10022, seq 4, length 64

　　11:25:33.697970 IP dd.local &gt; 192.168.240.255: ICMP echo request, id 10022, seq 5, length 64

　　11:25:34.697982 IP dd.local &gt; 192.168.240.255: ICMP echo request, id 10022, seq 6, length 64

　　此处匹配的是ICMP的广播包，要产生此包，只需要同一个局域网的另一台主机运行ping -b 192.168.240.255即可，当然还可产生组播包，由于没有适合的软件进行模拟产生，在此不举例子。

　　(4)匹配TCP数据包

　　TCP同样是TCP/IP协议栈里面最为重要的协议之一，它提供了端到端的可靠数据流，同时很多应用层协议都是把TCP作为底层的通信协议，因为TCP的匹配是非常重要的。

　　如果想匹配HTTP的通信数据，那只需指定匹配端口为80的条件即可

　　tcpdump 'tcp dst port 80'

　　<a href="mailto:ylin@ylin:~$">ylin@ylin:~$</a> wget <a href="http://www.baidu.com/">http://www.baidu.com</a> 2&gt;1 1 &gt;/dev/null &amp; sudo tcpdump -c 5 'tcp port 80'

　　[1] 10762

　　tcpdump: verbose output suppressed, use -v or -vv for full protocol decode

　　listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes

　　12:02:47.549056 IP xd-22-43-a8.bta.net.cn.www &gt; ylin.local.47945: S 1202130469:1202130469(0) ack 1132882351 win 2896 &lt;mss 1460,sackOK,timestamp 3497190920 2329221,nop,wscale 2&gt;

　　12:02:47.549085 IP ylin.local.47945 &gt; xd-22-43-a8.bta.net.cn.www: . ack 1 win 183 &lt;nop,nop,timestamp 2329258 3497190920&gt;

　　12:02:47.549226 IP ylin.local.47945 &gt; xd-22-43-a8.bta.net.cn.www: P 1:102(101) ack 1 win 183 &lt;nop,nop,timestamp 2329258 3497190920&gt;

　　12:02:47.688978 IP xd-22-43-a8.bta.net.cn.www &gt; ylin.local.47945: . ack 102 win 698 &lt;nop,nop,timestamp 3497190956 2329258&gt;

　　12:02:47.693897 IP xd-22-43-a8.bta.net.cn.www &gt; ylin.local.47945: . 1:1409(1408) ack 102 win 724 &lt;nop,nop,timestamp 3497190957 2329258&gt;

&nbsp;

&nbsp;

&nbsp;

　　(5)匹配udp数据包

　　udp是一种无连接的非可靠的用户数据报，因此udp的主要特征同样是端口，用如下方法可以匹配某一端口

　　tcpdump 'upd port 53' 查看DNS的数据包

　　<a href="mailto:ylin@ylin:~$">ylin@ylin:~$</a> ping -c 1 <a href="http://www.baidu.com/">www.baidu.com</a> &gt; /dev/null&amp; sudo tcpdump -p udp port 53

　　[1] 11424

　　tcpdump: verbose output suppressed, use -v or -vv for full protocol decode

　　listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes

　　12:28:09.221950 IP ylin.local.32853 &gt; 192.168.200.150.domain: 63228+ PTR? 43.22.108.202.in-addr.arpa. (44)

　　12:28:09.222607 IP ylin.local.32854 &gt; 192.168.200.150.domain: 5114+ PTR? 150.200.168.192.in-addr.arpa. (46)

　　12:28:09.487017 IP 192.168.200.150.domain &gt; ylin.local.32853: 63228 1/0/0 (80)

　　12:28:09.487232 IP 192.168.200.150.domain &gt; ylin.local.32854: 5114 NXDomain* 0/1/0 (140)

　　12:28:14.488054 IP ylin.local.32854 &gt; 192.168.200.150.domain: 60693+ PTR? 69.240.168.192.in-addr.arpa. (45)

　　12:28:14.755072 IP 192.168.200.150.domain &gt; ylin.local.32854: 60693 NXDomain 0/1/0 (122)

　　使用ping <a href="http://www.baidu.com/">www.baidu.com</a>目标是产生DNS请求和答应，53是DNS的端口号。

　　此外还有很多qualitifer是还没有提及的，下面是其它合法的primitive,在tcpdump中是可以直接使用的。

　　gateway host

　　匹配使用host作为网关的数据包，即数据报中mac地址（源或目的）为host，但IP报的源和目的地址不是host的数据包。

　　dst net net

　　src net net

　　net net

　　net net mask netmask

　　net net/len

　　匹配IPv4/v6地址为net网络的数据报。

　　其中net可以为192.168.0.0或192.168这两种形式。如net 192.168 或net 192.168.0.0

　　net net mask netmask仅对IPv4数据包有效，如net 192.168.0.0 mask 255.255.0.0

　　net net/len同样只对IPv4数据包有效，如net 192.168.0.0/16

　　dst portrange port1-port2

　　src portrange port1-port2

　　portrange port1-port2

　　匹配端口在port1-port2范围内的ip/tcp，ip/upd，ip6/tcp和ip6/udp数据包。dst, src分别指明源或目的。没有则表示src or dst

　　less length 匹配长度少于等于length的报文。

　　greater length 匹配长度大于等于length的报文。

　　ip protochain protocol 匹配ip报文中protocol字段值为protocol的报文

　　ip6 protochain protocol 匹配ipv6报文中protocol字段值为protocol的报文

　　如tcpdump 'ip protochain 6 匹配ipv4网络中的TCP报文，与tcpdump 'ip &amp;&amp; tcp'用法一样，这里的&amp;&amp;连接两个primitive。6是TCP协议在IP报文中的编号。

　　ether broadcast

　　匹配以太网广播报文

　　ether multicast

　　匹配以太网多播报文

　　ip broadcast

　　匹配IPv4的广播报文。也即IP地址中主机号为全0或全1的IPv4报文。

　　ip multicast

　　匹配IPv4多播报文，也就是IP地址为多播地址的报文。

　　ip6 multicast

　　匹配IPv6多播报文，即IP地址为多播地址的报文。

　　vlan vlan_id

　　匹配为vlan报文 ，且vlan号为vlan_id的报文

　　到些为此，我们一直在介绍primitive是如何使用的，也即expression只有一个primitive。通过学会写好每个primtive，我们就很容易把多个primitive组成一个expression，方法很简单，通过逻辑运算符连接起来就可以了，逻辑运算符有以下三个：

　　“&amp;&amp;” 或”and”

　　“||” 或“or”

　　“!” 或“not”

　　并且可通过()进行复杂的连接运算。

　　如tcpdump ‘ip &amp;&amp; tcp’

　　tcpdump ‘ host 192.168.240.3 &amp;&amp;( tcp port 80 || tcp port 443)’

　　通过上面的各种primitive，我们可以写出很丰富的条件，如ip, tcp, udp,vlan等等。如IP，可以按址址进行匹，tcp/udp可以按端口匹配。但是，如果我想匹配更细的条件呢？如tcp中只含syn标志，fin标志的报文呢？上面的primitive恐怕无能为力了。不用怕，tcpdump为你提供最后一个功能最强大的primitive，记住是primitive，而不是expression。你可以用多个这个的primitive组成更复杂的 expression.

&nbsp;

&nbsp;

&nbsp;

　　最后一个primitive形式为 expr relop expr

　　若把这个形式记为A，那么你可这样写tcpdump 'A1 &amp;&amp; A2 &amp;&amp; ip src 192.168.200.1'，等等。

　　下面我们就来分析A这个形式，看看这是如何强大，如果你觉得很乱的话，建议你先用用上面的知识来实际操作几次，要不然就会很乱的，因为expression太复杂了。

　　形式：expr relop expr

　　relop表示关系操作符，可以为&gt;, &lt; ,&gt;=,&lt;=, =, !=之一，

　　expr是一个算术表达式，由整数组成和二元运算符（＋，－，＊，/，＆，|, &lt;&lt;, &gt;&gt;)，长度操作，报文数据访问子。同时所有的整数都是无符号的，即0x80000000 和 0xffffffff &gt; 0。为了访问报文中的数据，可使用如下方式：

　　proto [ expr : size ]

　　proto表示该问的报文，expr的结果表示该报文的偏移，size为可选的，表示从expr偏移量起的szie个字节，整个表达式为proto报文 中,expr起的szie字节的内容（无符号整数）

　　下面是expr relop expr这种形式primitive的例子：

　　'ether[0] &amp; 1 !=0' ether报文中第0个bit为1，即以太网广播或组播的primtive。

　　通过这种方式，我们可以对报文的任何一个字节进行匹配了，因此它的功能是十分强大的。

　　‘ip[0] = 4’ ip报文中的第一个字节为version，即匹配IPv4的报文，

　　如果我们想匹配一个syn报文，可以使用：'tcp[13] = 2'，因为tcp的标志位为TCP报文的第13个字节，而syn在这个字节的低1位，故匹配只有syn标志的报文,上述条件是可满要求的，并且比较严格。

　　如果想匹配ping命令的请求报文，可以使用'icmp[0]=8'，因为icmp报文的第0字符表示类型，当类型值为8时表示为回显示请求。

　　对于TCP和ICMP中常用的字节，如TCP中的标志位，ICMP中的类型，这个些偏移量有时会忘记。不过tcpdump为你提供更方便的用法，你不用记位这些数字，用字符就可以代替了.

　　对于ICMP报文，类型字节可以icmptype来表示它的偏称量，上面的primitive可改为'icmp[icmptype] =8'，如果8也记不住怎么办？tcpdump还为该字节的值也提供了字符表示，如'icmp[icmptype] = icmp-echo'。

　　下面是tcpdump提供的字符偏移量：

　　icmptype：表示icmp报文中类弄字节的偏移量

　　icmpcode:表示icmp报文中编码字节的偏移量

　　tcpflags:表示TCP报文中标志位字节的偏移量

　　此外，还提供了很多值来对应上面的偏移字节：

　　ICMP中类型字节的值可以是：

　　icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redi‐rect, icmp-echo, icmp-routeradvert, icmp-routersolicit,

　　icmp-timxceed, icmp-paramprob, icmp-tstamp, icmp-tstam‐preply, icmp-ireq, icmp-ireqreply, icmp-maskreq, icmp-maskreply.

　　TCP中标志位字节的值可以是：

　　tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg.

　　通过上面的字符表示，我们可以写出下面的primitive

　　'tcp[tcpflags] = tcp-syn' 匹配只有syn标志设置为1的 tcp报文

　　'tcp[tcpflags] &amp; (tcp-syn |tcp-ack |tcp-fin) !=0' 匹配含有syn，或ack或fin标志位的TCP报文

　　对于IP报文，没有提供字符支持，如果想匹配更细的条件，直接使用数字指字偏移量就可以了，不过要对IP报文有更深入的了解才可以。

　　学会写primitive后，expression就是小菜一碟了，由一个或多个primitive组成，并且逻辑连接符组成即可：

　　tcpdump ‘host 192.168.240.91 &amp;&amp; icmp[icmptype] = icmp-echo’

　　tcpdump ‘host 192.168.1.100 &amp;&amp; vrrp’

　　tcpdump 'ether src 00:00:00:00:00:02 &amp;&amp; ether[0] &amp; 1 !=0'

　　让你随心所欲地使用tcpdump，将不用再从复杂的输出中去挑报文了！

　　如此，我们可以写出更复杂的表达式来匹配报文，如IP或TCP中的报文id，IP是中的分段标志，ICMP中类型和代码等。

转载自<a href="http://blog.csdn.net/zjl_1026_2001/article/details/7303118">http://blog.csdn.net/zjl_1026_2001/article/details/7303118</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>115</wp:post_id>
		<wp:post_date>2012-12-21 13:03:59</wp:post_date>
		<wp:post_date_gmt>2012-12-21 13:03:59</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>linux%e5%88%a9%e5%99%a8%e4%b9%8btcpdump</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>34</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>e</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=159</link>
		<pubDate>Wed, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=159</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>159</wp:post_id>
		<wp:post_date>2012-12-25 09:00:47</wp:post_date>
		<wp:post_date_gmt>0000-00-00 00:00:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name></wp:post_name>
		<wp:status>draft</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>main 函数详解</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=210</link>
		<pubDate>Wed, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=210</guid>
		<description></description>
		<content:encoded><![CDATA[<div id="cnblogs_post_body">
<div>

[声明]本文转自李建忠老师的帖子，但是没有找到原文出处，现提供转贴地址：<a href="http://www.cnblogs.com/catbim/archive/2006/04/12/373478.html">这里</a>

“Hello World!”程序是程序员一直以来的一个浪漫约定，也是一个伟大的梦想--总有一天，出自人类之手的计算机会面对这个美丽的世界说一声“Hello World!”。它是学习一门新语言的一个很好的起点，我们就从这里开始，看下面例子：

1 //HelloWorld.cs by Cornfield,2001
2 //csc HelloWorld.cs
3 using System;
4 class HelloWorld
5 {
6 public static void Main()
7 {
8 Console.WriteLine("Hello World !");
9 }
10 }
11
12

我们可以打开Windows自带的简易的"记事本"程序来编写这段代码--笔者推荐刚开始采用这个极其简单却能把程序代码暴露的相当清晰的编辑工具。我们将它的文件名保存为HelloWorld.cs，其中".cs"是C#源代码文件的扩展名。然后在配置好C#编译器的命令行环境里键入"csc HelloWorld.cs"编译文件。可以看到编译输出文件HelloWorld.exe。我们键入HelloWorld执行这个文件可得到下面的输出：

Hello World !

下面我们来仔细分析上面的代码和整个程序的编译输出及执行过程。先看文件开始的两行代码，这是C#语言的单行注释语句。和C++语言类似，C#支持两种注释方法：以"//"开始的单行注释和以"/*"，"*/"配对使用的多行注释。注释之间不能嵌套。

再来看下面的"using System;"语句，这是C#语言的using命名空间指示符，这里的"System"是Microsoft.NET系统提供的类库。C#语言没有自己的语言类库，它直接获取Microsoft.NET系统类库。Microsoft.NET类库为我们的编程提供了非常强大的通用功能。该语句使得我们可以用简短的别名"Console"来代替类型"System.Console"。当然using指示符并不是必须的，我们可以用类型的全局名字来获取类型。实际上，using语句采用与否根本不会对C#编译输出的程序有任何影响，它仅仅是简化了较长的命名空间的类型引用方式。

接着我们声明并实现了一个含有静态Main()函数的HelloWorld类。C#所有的声明和实现都要放在同一个文件里，不像C++那样可以将两者分离。Main()函数在C#里非常特殊，它是编译器规定的所有可执行程序的入口点。由于其特殊性，对Main()函数我们有以下几条准则：
<table>
<tbody>
<tr>
<td valign="middle" width="25">1.</td>
<td valign="middle" width="550">Main()函数必须封装在类或结构里来提供可执行程序的入口点。C#采用了完全的面向对象的编程方式，C#中不可以有像C++那样的全局函数。</td>
</tr>
<tr>
<td valign="middle" width="25">2.</td>
<td valign="middle" width="550">Main()函数必须为静态函数(static)。这允许C#不必创建实例对象即可运行程序。</td>
</tr>
<tr>
<td valign="middle" width="25">3.</td>
<td valign="middle" width="550">Main()函数保护级别没有特殊要求， public,protected,private等都可，但一般我们都指定其为public。</td>
</tr>
<tr>
<td valign="middle" width="25">4.</td>
<td valign="middle" width="550">Main()函数名的第一个字母要大写，否则将不具有入口点的语义。C#是大小写敏感的语言。</td>
</tr>
<tr>
<td valign="middle" width="25">5.</td>
<td valign="middle" width="550">Main()函数的参数只有两种参数形式：无参数和string 数组表示的命令行参数，即static void Main()或static void Main(string[]args) ，后者接受命令行参数。一个C#程序中只能有一个Main()函数入口点。其他形式的参数不具有入口点语义，C#不推荐通过其他参数形式重载Main()函数，这会引起编译警告。</td>
</tr>
<tr>
<td valign="middle" width="25">6.</td>
<td valign="middle" width="550">Main()函数返回值只能为void(无类型)或int(整数类型)。其他形式的返回值不具有入口点语义。</td>
</tr>
</tbody>
</table>
我们再来看"HelloWorld.cs"程序中Main()函数的内部实现。前面提过，Console是在命名空间System下的一个类，它表示我们通常打交道的控制台。而我们这里是调用其静态方法WriteLine()。如同C++一样，静态方法允许我们直接作用于类而非实例对象。WriteLine()函数接受字符串类型的参数"Hello World !"，并把它送入控制台显示。如前所述，C#没有自己的语言类库，它直接获取Microsoft.NET系统类库。我们这里正是通过获取Microsoft.NET系统类库中的System.Console.WriteLine()来完成我们想要的控制台输出操作。这样我们便完成了"Hello World!"程序。

但事情远没那么简单！在我们编译输出执行程序的同时，Microsoft.NET底层的诸多机制却在暗地里涌动，要想体验C#的锐利，我们没有理由忽视其背靠的Microsoft.NET平台。实际上如果没有Microsoft.NET平台，我们很难再说C#有何锐利之处。我们先来看我们对"HelloWorld.cs"文件用csc.exe命令编译后发生了什么。是的，我们得到了HelloWorld.exe文件。但那仅仅是事情的表象，实际上那个HelloWorld.exe根本不是一个可执行文件！那它是什么？又为什么能够执行？
好的，下面正是回答这些问题的地方。首先，编译输出的HelloWorld.exe是一个由中间语言（IL），元数据(Metadata)和一个额外的被编译器添加的目标平台的标准可执行文件头（比如Win32平台就是加了一个标准Win32可执行文件头）组成的PE（portable executable，可移植执行体）文件，而不是传统的二进制可执行文件--虽然他们有着相同的扩展名。中间语言是一组独立于CPU的指令集，它可以被即时编译器Jitter翻译成目标平台的本地代码。中间语言代码使得所有Microsoft.NET平台的高级语言C#,VB.NET，VC.NET等得以平台独立，以及语言之间实现互操作。元数据是一个内嵌于PE文件的表的集合。元数据描述了代码中的数据类型等一些通用语言运行时(Common Language Runtime)需要在代码执行时知道的信息。元数据使得.NET应用程序代码具备自描述特性，提供了类型安全保障，这在以前需要额外的类型库或接口定义语言（Interface Definition Language,简称IDL）。
这样的解释可能还是有点让人困惑，那么我们来实际的解剖一下这个PE文件。我们采用的工具是.NET SDK Beta2自带的ildasm.exe，它可以帮助我们提取PE文件中的有关数据。我们键入命令"ildasm /output:HelloWorld.il HelloWorld.exe"，一般可以得到两个输出文件：helloworld.il和helloworld.res。其中后者是提取的资源文件，我们暂且不管，我们来看helloworld.il文件。我们用"记事本"程序打开可以看到元数据和中间语言（IL）代码，由于篇幅关系，我们只将其中的中间语言代码提取出来列于下面，有关元数据的表项我们暂且不谈：

1 class private auto ansi beforefieldinit HelloWorld
2        extends [mscorlib]System.Object
3 {
4   .method public hidebysig static void  Main() cil managed
5   {
6     .entrypoint
7     // Code size       11 (0xb)
8     .maxstack  8
9     IL_0000:  ldstr      "Hello World !"
10     IL_0005:  call       void [mscorlib]System.Console::WriteLine(string)
11     IL_000a:  ret
12   } // end of method HelloWorld::Main
13   .method public hidebysig specialname rtspecialname
14           instance void  .ctor() cil managed
15   {
16     // Code size       7 (0x7)
17     .maxstack  8
18     IL_0000:  ldarg.0
19     IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
20     IL_0006:  ret
21   } // end of method HelloWorld::.ctor
22 } // end of class HelloWorld

我们粗略的感受是它很类似于早先的汇编语言，但它具有了对象定义和操作的功能。我们可以看到它定义并实现了一个继承自System.Object 的HelloWorld类及两个函数：Main()和.ctor()。其中.ctor()是HelloWorld类的构造函数，可在"HelloWorld.cs"源代码中我们并没有定义构造函数呀--是的，我们没有定义构造函数，但C#的编译器为我们添加了它。你还可以看到C#编译器也强制HelloWorld类继承System.Object类，虽然这个我们也没有指定。关于这些高级话题我们将在以后的讲座中予以剖析。

那么PE文件是怎么执行的呢？下面是一个典型的C#/.NET应用程序的执行过程：
<table>
<tbody>
<tr>
<td valign="middle" width="13">1.</td>
<td valign="middle" width="562">用户执行编译器输出的应用程序(PE文件)，操作系统载入PE文件，以及其他的DLL(.NET动态连接库)。</td>
</tr>
<tr>
<td valign="middle" width="13">2.</td>
<td valign="middle" width="562">操作系统装载器根据前面PE文件中的可执行文件头跳转到程序的入口点。显然，操作系统并不能执行中间语言，该入口点也被设计为跳转到mscoree.dll（.NET平台的核心支持DLL）的_ CorExeMain()函数入口。</td>
</tr>
<tr>
<td valign="middle" width="13">3.</td>
<td valign="middle" width="562">CorExeMain()函数开始执行PE文件中的中间语言代码。这里的执行的意思是通用语言运行时按照调用的对象方法为单位，用即时编译器将中间语言编译成本地机二进制代码，执行并根据需要存于机器缓存。</td>
</tr>
<tr>
<td valign="middle" width="13">4.</td>
<td valign="middle" width="562">程序的执行过程中，垃圾收集器负责内存的分配，释放等管理功能。</td>
</tr>
<tr>
<td valign="middle" width="13">5.</td>
<td valign="middle" width="562">程序执行完毕，操作系统卸载应用程序。</td>
</tr>
</tbody>
</table>
清楚的知晓编译输出的PE文件的执行过程是深度掌握C#语言编程的关键，这种过程的本身就诠释着C#语言的高级内核机制以及其背后Microsoft.NET平台种种诡秘的性质。一个"Hello World !"程序的概括力已经足够，在我们对C#语言有了一个很好的起点之后，下面的专题会和大家一起领略C#基础语言，窥探Microsoft.NET平台构造，步步体验C#锐利编程的极乐世界，Let's go!

&nbsp;

</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>210</wp:post_id>
		<wp:post_date>2013-02-24 04:45:25</wp:post_date>
		<wp:post_date_gmt>0000-00-00 00:00:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name></wp:post_name>
		<wp:status>draft</wp:status>
		<wp:post_parent>53</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>生活与人生</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=117</link>
		<pubDate>Sat, 22 Dec 2012 04:16:31 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=117</guid>
		<description></description>
		<content:encoded><![CDATA[计量~10年9月我一个人从来宾坐着k538长途奔波了一天一夜以后~单枪匹马来到杭州~~这个我即将奋斗四年的城市~~]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>117</wp:post_id>
		<wp:post_date>2012-12-22 04:16:31</wp:post_date>
		<wp:post_date_gmt>2012-12-22 04:16:31</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%b8%aa%e4%ba%ba%e7%94%9f%e6%b4%bb</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>大学四年规划</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=122</link>
		<pubDate>Sat, 22 Dec 2012 04:24:13 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=122</guid>
		<description></description>
		<content:encoded><![CDATA[       当我写这一篇文章时，我已经是中国计量大学的一名学生了，现在，我站在大学的开头，展望一下大学四年的学习和生活，希望我的大学能够如预期一般充实而有意义。 
大一：打牢地基。观念上将“要我学”变为“我要学”，脚踏实地学好基础课程，特别是英语和计算机。在大规划下要做小计划，坚持每天记英语单词、练习口语，并从大一开始就坚定不移地学下去。根据自己的实际情况考虑是否修读双学位或辅修第二专业，并尽早做好资料准备。大一的学习任务相对轻松，可适当参加社团活动，担当一定的职务，提高自己的组织能力和交流技巧，为毕业<a href="http://www.16175.com/Article/3533.html" target="_blank">求职</a>面试练好兵。 
　　大二：承前启后。在这一年里，既要稳抓基础，又要做好由基础课向专业课过渡的准备，并要把一些重要的高年级课程逐一浏览，以便向大三平稳过渡。这一年，手中应握有一两张有分量的英语和计算机认证书了，并适当选读其它专业的课程，使自己知识多元化。可参加有益的社会实践，如下乡、义工活动，也可尝试到与自己专业相关的单位兼职，多体验不同层次的生活，培养自己的吃苦精神和社会责任感。 
　　大三：奋起直追。主动加深专业课程的学习，并把大四的课程尽量挤入大三这一学期，以便大四有相对宽松的时间<a href="http://www.16175.com/Article/3533.html" target="_blank">求职</a>或考研。对于大多数同学来说，大三是到了快要把自己抛向社会的时候，因而要多向大四的师兄师姐打听<a href="http://www.16175.com/Article/3533.html" target="_blank">求职</a>信息、面试技巧和职场需求情况，请教写求职信、<a href="http://www.16175.com/Article/2961.html" target="_blank">个人简历</a>的经验，并在假期开始为自己心目中的职业进行实践。准备考研或出国留学的同学，则要关注考试资讯，尽可能多渠道地搜罗各种资料。 
　　大四：扬帆千里。目标既已锁定，该出手时就出手了。求职的，编写好个人求职材料，进军招聘活动，多到求职网站和论坛转一转，你自然会享受到勤劳的果实。考研和出国的，现在就是冲刺期，落足功夫，争取把目标拿下。在同学们为自己的前途忙得晕头转向的时候，毕业论文这一关可马虎不得，这是对你大学四年学习的一个检验，要对自己负责，别“剪刀加浆糊”就糊弄过去，想想被评上优秀论文是一件多么荣耀的事情啊。只要在大学前三年都能认真践行自己计划的同学，相信大四就是你收获的季节了。

       生活上，在大学四年间应当养成良好的生活习惯，良好的生活习惯有利于我们的学习和生活，能使我们的学习起到事半功倍的作用。要养成良好的生活习惯就要做到以下几个方面的内容。我要合理地安排作息时间，形成良好的作息制度；还要进行适当的体育锻炼和文娱活动；要保证合理的营养供应，养成良好的饮食习惯；不能养成沉溺于电脑网络游戏等不良的习惯；并且在课堂上要认真详细的记笔记。

       在大学本科期间，我们并不指望能学到什么高深的专业知识，而是应该把重心放在学习能力的培养上。一个人贵在知道自己应该去干什么，"明其志，方能知所赴！"学校提供的平台是许多专家的共同认可的，适合大部分同学的需要，然我们自己应该更清楚自己的实际需要，在学的课程上有所侧重，有所安排，另外选学一些对自己有价值、有益处的课程……这将更具个性化更能挖掘你的潜力。

        大学同样是一个施展表现你的才华的大舞台。好好利用它，也是一个任务。怎么说呢？有人说："社会经验道义后社会上去培养也来得及，现在读好书不就行了么？"我认为这是各误区能力的培养其实不是一朝一夕的。就比如语言能力，我们从小就开始训练，对么？但你可以说——我现在的语言功底、交际能力非常出色了么？很少有！即使我们平时一直在培养的东西尚且如此，更何况工作能力呢？它常需要一定条件，一定时间空间的。许多大一没有从事任何社会工作的同学，往往到了大二、大三就很难加入学生会、团委，等等，为什么呢？就是这个道理，我们应该把握大学里这个机会充分锻炼自己的工作能力。

         大学课余生活丰富多彩，思源湖畔、光彪楼里，时时飘来美妙的音乐。
各类大小社团所推出的活动络绎不绝，只要你在校园逛逛，回寝室时便会发现手里捧着一大堆海报、传单。这儿一个报告，那儿一个音乐沙龙，东边一场篮球赛，西边一处美食节。其中你择其一二参加可以帮助你缓解学习的压力，舒缓自己情绪，又可以广交朋友，走进大学的社团身份，对将来人生多元化有百利。

      我上高中时的理想大学生活跟我现在的差距的确是很大，但那时只是天真的认为大学是很美好的。现在明白了，也认清了，并开始适应了。我想大学终究是一个学习的地方。所以学习还是第一位，这四年中一定要把学习抓好，尤其是对自己感兴趣的学科，要好好学好，兴趣决定动力，我就是对很多事都提不起兴趣，才会缺少很多的动力。总之大学生涯不一定要门门都是优秀，只要有拿得出手的就可以。毕竟各科都精通实在难做到。我也没必要订些不切实际的目标。

        曾经读到了这样一句话“青春的含义就在于不管我们选择了什么、成功与否，都不后悔。我希望通过4年的大学生活，深切地体会到青春和成长所带来的喜悦和甘甜。不仅要努力学习专业知识，同时还应该培养自己的竞争意识，创新意识和团队合作意识。在经历4年的历练之后，我希望自己能够更加勇敢、坚强，并且积极向上。”我觉得，这正是我对大学生活的期望。

在拟好了规划后，还需要提醒自己，在行动中具体实施目标时也会碰到困难。如很难预料的或难以控制的事情发生，像社会经济衰退、生病、环境突然发生变化等，在这种情况下，我们需要等待，或者寻求其他方法，或改变自己的设想来适应社会需求。

希望我的大学能够是我梦想的跳板，助我的梦想奋力起航。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>122</wp:post_id>
		<wp:post_date>2012-12-22 04:24:13</wp:post_date>
		<wp:post_date_gmt>2012-12-22 04:24:13</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%a4%a7%e5%ad%a6%e5%9b%9b%e5%b9%b4%e8%a7%84%e5%88%92</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>117</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>空白 </title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=124</link>
		<pubDate>Sat, 22 Dec 2012 04:25:19 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=124</guid>
		<description></description>
		<content:encoded><![CDATA[<div>
<div id="veryContent">
<table id="blogContentTable" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<div id="blogContainer">
<div id="blogDetailDiv">在空白的屏幕上打出一连串的字符，我以为我做得到，但我始终不敢按回车，好奇又害怕答案，当删去时内心又觉得空虚…恨自己…怪自己…唉…望着屏幕～好空白…</div>
</div></td>
</tr>
</tbody>
</table>
<div id="paperBottom"> </div>
</div>
</div>
<div>
<div>

&nbsp;

&nbsp;

</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>124</wp:post_id>
		<wp:post_date>2012-12-22 04:25:19</wp:post_date>
		<wp:post_date_gmt>2012-12-22 04:25:19</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%a9%ba%e7%99%bd</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>117</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>无聊人～琐碎～</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=127</link>
		<pubDate>Sat, 22 Dec 2012 04:26:39 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=127</guid>
		<description></description>
		<content:encoded><![CDATA[流星,因为短暂而美丽,划过黑寂的夜空,释放出那一闪而逝的光芒,虽然微弱,却没有人能无视它的存在.人生如同流星，充满了精彩与传奇，如同一支美丽的传说，究竟是否会象流星那样短暂，别人决定不了上天也决定不了，只有自己来掌握。如果愿意，流星也可永恒]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>127</wp:post_id>
		<wp:post_date>2012-12-22 04:26:39</wp:post_date>
		<wp:post_date_gmt>2012-12-22 04:26:39</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%97%a0%e8%81%8a%e4%ba%ba%ef%bd%9e%e7%90%90%e7%a2%8e%ef%bd%9e</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>117</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>琐碎思</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=129</link>
		<pubDate>Sat, 22 Dec 2012 04:28:17 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=129</guid>
		<description></description>
		<content:encoded><![CDATA[梦回310...记得晚睡熄灯后分东西部飙歌…一起被老罗拉到阳台上政治课…一起在球场挥汗打球…一块热衷于投三分…无兄弟不篮球~记得快高考时，男阿姨来我们宿舍告我们要本份点了…留下那句“国大不是问题…”经典…夜深人静…只想道声:兄弟可好…]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>129</wp:post_id>
		<wp:post_date>2012-12-22 04:28:17</wp:post_date>
		<wp:post_date_gmt>2012-12-22 04:28:17</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%90%90%e7%a2%8e%e6%80%9d</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>117</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>对不起</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=131</link>
		<pubDate>Sat, 22 Dec 2012 04:29:34 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=131</guid>
		<description></description>
		<content:encoded><![CDATA[。。有时候没办法陪著你，你总是对我说没关系，放不下我对你的任性，对不起不该让你伤心，有时候，你会让让我，尽管我大男人发作，有时候，你会装作不懂，默默地，留一些空间给我，这些事情，其实，我一直都藏在心里，请你原谅我不懂逗你开心，请你原谅我不懂听你的心，回想这过去，我学著让你更安心，别赌气别任性别放弃，说声对不起，请你相信我，我会更加珍惜你，请你相信我我会呵护著你，小小的爱情，却是我最大的幸运，疼爱的，想念的都是你，请你相信，一个这样的我，请原谅，对不起~对不起]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>131</wp:post_id>
		<wp:post_date>2012-12-22 04:29:34</wp:post_date>
		<wp:post_date_gmt>2012-12-22 04:29:34</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%af%b9%e4%b8%8d%e8%b5%b7</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>117</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>~~有的时候~~ </title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=133</link>
		<pubDate>Sat, 22 Dec 2012 04:31:05 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=133</guid>
		<description></description>
		<content:encoded><![CDATA[有的时候喜欢不吃不喝，一个人走过饭堂门口，感觉不饿，想想，再绕回来；
   有的时候喜欢让自己很忙，累到心里都感觉到疲惫了，蒙起头就睡，不让自己伤神再想起别的事来；
   有的时候醒来会想起某些人，曾经还以为，少了谁都不会怎样，生活还不是一样要过。－－其实不是这样，想念有的时候会让人痛彻心扉；
    有的时候话特别多，喜欢喊着讲，不一定是高兴才这样，也不全是难过非要发泄，可能只是单纯的想而已；
    有的时候喜欢某一首歌，单曲循环，反复听着，像是听着自己的心声那样，比如“十年”：十年之前你不认识我，我也不认识你…十年之后我们是朋友，还可以问候…一路走来，再走下去，遇人无数，谁会是谁的过客，谁又会是谁的知己；
    有的时候很沉默，喜欢一句话都不说，一个人走到某个角落，渐渐的，把某些事想开来，刹那间，让自己找到奋斗下去的勇气；
    有的时候喜欢逛逛朋友的空间，不怎么留痕迹，感觉你们快乐就好；
   有的时候会和别人说，其实我很内向，只是喜欢在你们面前“聒噪”而已，经常某些人会瞪着眼睛反回来，“少来了你，就你这样还内向呢…”有点不知所措，笑笑，无所谓吧，我们一起快乐就好；
   有的时候想着去联系某个人，拿起电话的时候才知道，其实不懂要说什么，总是会突然怀念一些朋友，在心里的问候，也许你们不懂；
   有的时候很多人在一起，感觉很开心，只是自己不怎么喜欢讲话，喜欢听别人讲那些自己经历过或不曾经历过的事，经常在心里感慨：哇，人家见识好广，懂得很多；
    有的时候渴望和我们家族的人在一起，不做什么，一起聊聊天，听听他们唱歌，也会觉得很温馨，偶尔有的时候玩真心话大冒险，会把小丑弄得很委屈，呵呵…其实我也挨她整得很无语过；
    有的时候会很想去某个地方，比如说南宁，不为什么，只是有好多同学在那，会很想他们，我的青春，他们加入过，曾经我们一起努力过，奋斗过。或者走在街上，还会遇到某张熟悉的面孔，打招呼的时候也许会这样说：真巧，你也在这；
    有的时候感觉心里有些不好过，因为大大小小的考试太多，有些顾不上朋友，他们会以为我变了，冷落了他们，其实不是这样，可是很多时候不懂怎么说，害怕他们这样回我，人家读大学都很多课余时间，难道就只有你忙吗；
    
    有的时候会很想家，想家里人的时候很温馨，也很有动力，常常有这样的感觉，我可以努力去做很多事，只要他们健康、快乐就好；
    有的时候还会为久违的问候而感动，人家说，我不想知道你的主角是谁，我只是想看看你的文字而已…傻啊，你怎么不说你是想看看我的心情，想知道我过得好不好呢；
   有的时候…有的时候也想问某个人，如果你也听说，我把自己的生活过成这样，会不会你也开始有那么一点心疼我？
    有的时候，每个人都有很多个“有的时候”吧，只是不同的时候不同的心情，不同的感慨而已。我不知道你在想什么，不知道你在做什么，也许吃饭，也许～～]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>133</wp:post_id>
		<wp:post_date>2012-12-22 04:31:05</wp:post_date>
		<wp:post_date_gmt>2012-12-22 04:31:05</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%9c%89%e7%9a%84%e6%97%b6%e5%80%99</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>117</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>…看你这闹的~</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=136</link>
		<pubDate>Sat, 22 Dec 2012 04:33:10 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=136</guid>
		<description></description>
		<content:encoded><![CDATA[记得六月初的一个傍晚，那会刚考完经济学，我就跑去城站接你，到了才知道我弄错了，原来你在滨江，那会下着大雨，我又得直奔滨江。记得接你回到学校已经八点了。都两个月来了，暑假我们相依为伴。其间你只闹过一回。但今天你闹得最凶。我承认下午的军训我逃了。反正去了也打酱油…但我也有事啊！下午出门了，本想去看受伤的双手，终究没去。只是买了点生活用品。晚上冒着被批的风险去见你，你倒好死活不坑声，还好平哥调解好，让你开了口。我这九天过得那叫苦啊！我也想晚上过去的，挤不出时间啊！接下来的时间应该比较好了！我会每天过去的~看你这闹的…好像内存条跟你有仇似的…bois乱了，你只让我玩ubuntu…好啦！珍爱生命…远离MFC…嗯~晚安~]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>136</wp:post_id>
		<wp:post_date>2012-12-22 04:33:10</wp:post_date>
		<wp:post_date_gmt>2012-12-22 04:33:10</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%9c%8b%e4%bd%a0%e8%bf%99%e9%97%b9%e7%9a%84</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>117</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>今天</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=139</link>
		<pubDate>Sat, 22 Dec 2012 04:34:36 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=139</guid>
		<description></description>
		<content:encoded><![CDATA[<table id="blogContentTable" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">
<div id="blogContainer">
<div id="paperTitleArea" align="center"> </div>
<div id="blogDetailDiv">今天~冷~冻~冰。高一同班的一女生今告诉我《盗墓笔记8》出了，曾经坐在她后面看这小说，想不到她居然也看了而且很迷恋。。移动硬盘两天了还没到，可恶的申通！！晚上打电话回家了。。怀念老妈做的菜，更喜欢吃自个做的菜。。青菜啊。。就这样了</div>
</div></td>
</tr>
</tbody>
</table>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>139</wp:post_id>
		<wp:post_date>2012-12-22 04:34:36</wp:post_date>
		<wp:post_date_gmt>2012-12-22 04:34:36</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%bb%8a%e5%a4%a9</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>117</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>2012之开篇猥琐解题</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=141</link>
		<pubDate>Sat, 22 Dec 2012 04:36:26 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=141</guid>
		<description></description>
		<content:encoded><![CDATA[2012真的是世界末日吗？？答案是不知道。。管它呢~反正咱有火车票。本篇报告本不想在这发表的，无奈。。=下回再在CSDN发表吧~本篇报告谢绝大牛踢场。。欢迎大牛前来指导和交流。。推箱子是一个很经典的游戏.这道题主要就是搜索算法。。而且是双重的bfs，推箱子这个游戏做起来应该不难。。相比俄罗斯方块还是简单的。。界面做出来主要还是看算法。。废话少说。。
<div>   1. 因为是双bfs  所以用四维数组判重</div>
<div>   2.先对箱子bfs，再根据箱子的位置对人进行bfs</div>
<div> <a href="http://http//acm.hdu.edu.cn/showproblem.php?pid=1254" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1254</a></div>
<div>  总算对bfs又加深了印象和理解。。泪奔。。看源码吧。。</div>
<div>    /* </div>
<div> 该题与迷宫题有一定的相似性，只不过多出了人，故还需对人进行bfs</div>
<div> 该题为双bfs</div>
<div>*/</div>
<div>#include&lt;iostream&gt;</div>
<div>#include&lt;cstdio&gt;</div>
<div>#include&lt;queue&gt;</div>
<div>#include&lt;string&gt;</div>
<div>#include&lt;algorithm&gt;</div>
<div>using namespace std;</div>
<div>int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};   //上下左右四个方向</div>
<div>int map[8][8];</div>
<div>bool hash[8][8][8][8];  //四维数组表示人和箱子的位置</div>
<div>bool vis[8][8][8][8];</div>
<div>int dx,dy,n,m,flag;</div>
<div>struct point </div>
<div>{</div>
<div>  int px;</div>
<div>  int py;</div>
<div>  int xx;</div>
<div>  int xy;</div>
<div>  int step; //走过的步数</div>
<div>};</div>
<div>queue&lt;point&gt; q;</div>
<div>queue&lt;point&gt; p;</div>
<div>point temp;</div>
<div>point input()</div>
<div>{</div>
<div>   int i,j;</div>
<div>   point temp;</div>
<div>   dx=9,dy=9;  //初始化目的地</div>
<div>   temp.step =0;</div>
<div>   scanf("%d %d",&amp;n,&amp;m);</div>
<div>    for(i=0;i&lt;n;i++)</div>
<div>   {</div>
<div>        for(j=0;j&lt;m;j++)</div>
<div>{</div>
<div>   scanf("%d",&amp;map[i][j]);</div>
<div>   if(map[i][j]==4)  //人的开始的位置</div>
<div>   {</div>
<div>     map[i][j]=0;</div>
<div> temp.px =i;</div>
<div> temp.py =j;</div>
<div>   }</div>
<div>   if(map[i][j]==2)  //箱子的位置</div>
<div>   {</div>
<div>      map[i][j]=0;</div>
<div>  temp.xx =i;</div>
<div>  temp.xy =j;</div>
<div>   }</div>
<div>   if(map[i][j]==3)  //目的地</div>
<div>   {</div>
<div>     map[i][j]=0;</div>
<div> dx=i;</div>
<div> dy=j;</div>
<div>   }</div>
<div>}</div>
<div>   }</div>
<div>return temp;</div>
<div>}</div>
<div>int people_out(point temp)   //判断是否越界或行得通</div>
<div>{</div>
<div>if(temp.px &lt;0 || temp.py &lt;0 || temp.px &gt;=n || temp.py &gt;=m)  //越界</div>
<div>return 0;</div>
<div>if(temp.px == temp.xx &amp;&amp; temp.py ==temp.xy )  //人和箱子相重</div>
<div>return 0;</div>
<div>if(map[temp.px ][temp.py ]==1)  //有墙行不通</div>
<div>return 0;</div>
<div>return 1;</div>
<div>}</div>
<div> int people_bfs(point temp ,point tar)   //对推箱者bfs</div>
<div>{</div>
<div>    int i;</div>
<div>point tt;</div>
<div>memset(hash,false,sizeof(hash));  //初始化</div>
<div>while(!q.empty ())</div>
<div>q.pop ();</div>
<div>q.push (temp);</div>
<div>while(!q.empty ())</div>
<div>{</div>
<div>   temp=q.front ();</div>
<div>   q.pop ();</div>
<div>   tt=temp;</div>
<div>   if(tt.px ==tar.px &amp;&amp; tt.py == tar.py )//人也能到达</div>
<div>   {</div>
<div>     flag=1;</div>
<div> return flag;</div>
<div>   }</div>
<div>   for(i=0;i&lt;4;i++)</div>
<div>   {</div>
<div>      tt.px =temp.px +dir[i][0];</div>
<div>  tt.py =temp.py +dir[i][1];</div>
<div>  if(!people_out(tt))  continue;</div>
<div>  if(!hash[temp.xx ][temp.xy ][tt.px ][tt.py ])   //标记人走过的位置</div>
<div>  {</div>
<div>   q.push (tt);</div>
<div>   hash[temp.xx ][temp.xy ][tt.px ][tt.py ]=true;</div>
<div>  }</div>
<div>   }</div>
<div>}</div>
<div>}</div>
<div>int box_out(point temp)  //判断箱子是否行得通</div>
<div>{</div>
<div>  if(temp.xx &lt;0 || temp.xy &lt;0 || temp.xx &gt;=n || temp.xy &gt;=m)   //越界</div>
<div>  return  0;</div>
<div>  if(map[temp.xx ][temp.xy ]==1)</div>
<div>  return 0;</div>
<div>  return 1;</div>
<div>}</div>
<div> int box_bfs(point temp)  //对箱子的bfs</div>
<div>{ </div>
<div>int i;</div>
<div>    point tt;</div>
<div>    while(!p.empty())</div>
<div>        p.pop();</div>
<div>    p.push(temp);</div>
<div>    while(!p.empty())</div>
<div>    {</div>
<div>        temp = p.front();</div>
<div>        p.pop();</div>
<div>        if(temp.xx == dx &amp;&amp; temp.xy == dy)  //能到达目的地</div>
<div>        {</div>
<div>            return temp.step;</div>
<div>        }</div>
<div>        tt.step = temp.step + 1;</div>
<div>        for(i = 0; i &lt; 4; i++)</div>
<div>        {</div>
<div>            tt.xx = temp.xx + dir[i][0];</div>
<div>            tt.xy = temp.xy + dir[i][1];</div>
<div>            if( !box_out(tt) ) continue;</div>
<div>/*==人的位置==*/</div>
<div>            tt.px = temp.xx - dir[i][0];  </div>
<div>            tt.py = temp.xy - dir[i][1];</div>
<div>            if(tt.px &lt; 0 || tt.py &lt; 0 || tt.px &gt;= n || tt.py &gt;= m)</div>
<div>                continue;</div>
<div>            if(map[tt.px][tt.py] == 1)</div>
<div>                continue;</div>
<div>            flag = 0;</div>
<div>            people_bfs(temp, tt);  //对人搜索</div>
<div>            if(flag)</div>
<div>            {</div>
<div>                tt.px = temp.xx;</div>
<div>                tt.py = temp.xy;</div>
<div>                if(!vis[tt.px][tt.py][tt.xx][tt.xy])  //该位置未走过</div>
<div>                {</div>
<div>                    vis[tt.px][tt.py][tt.xx][tt.xy] = true;</div>
<div>                    p.push(tt);</div>
<div>                }</div>
<div>            }</div>
<div>        }</div>
<div>    }</div>
<div>    return -1;   //行不通返回-1</div>
<div>}</div>
<div>int main()</div>
<div>{</div>
<div>   int t;</div>
<div>   scanf("%d",&amp;t);</div>
<div>   while(t--)</div>
<div>   {</div>
<div>      printf("%d\n",box_bfs(input()));</div>
<div>  memset(vis,false,sizeof(vis));</div>
<div>   }</div>
<div>   return 0;</div>
<div>}</div>
<div>     /* 2012。。依旧泪奔。。依旧AC。。。*/</div>
<div>
<table width="100%" border="0" cellspacing="2" align="center">
<tbody>
<tr align="center">
<td>2012-01-01 18:32:21</td>
<td><span style="color: #ff0000;">Accepted</span></td>
<td><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1254" target="_blank">1254</a></td>
<td>0MS</td>
<td>212K</td>
<td><a href="http://acm.hdu.edu.cn/viewcode.php?rid=5223875" target="_blank">3626 B</a></td>
<td>C++</td>
</tr>
</tbody>
</table>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>141</wp:post_id>
		<wp:post_date>2012-12-22 04:36:26</wp:post_date>
		<wp:post_date_gmt>2012-12-22 04:36:26</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>2012%e4%b9%8b%e5%bc%80%e7%af%87%e7%8c%a5%e7%90%90%e8%a7%a3%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>61</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>ACM程序设计竞赛与数学建模竞赛的对比</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=143</link>
		<pubDate>Sat, 22 Dec 2012 04:38:06 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=143</guid>
		<description></description>
		<content:encoded><![CDATA[利用半小时的时间~~为4.14日感叹一下~这里利用某大牛的部分篇幅。
<div> </div>
<div>      学校总喜欢拿数学建模和ACM程序设计竞赛进行对比，的确，这两个比赛都是</div>
三个人一个队伍，应该说都考察了参赛选手全面的素质。然而毕竟区别还是很大的，
数学建模竞赛是教育部倡导的几项大学传统赛事之一，相信会有很多大学会像我们学
校一样看重这一点-----官方认证
<div>     在说数学建模竞赛本身是一个很好的竞赛形式，的确能提高数学素养，在科学研究数</div>
学建模发挥的作用是越来越明显，实验室产生的大量数据绝对是需要数学处理才能产
生真正的科学结果，完全凭直觉的时代早已经过去了。教育部倡导这项竞赛的确是用
心良苦，真正用心参加过数学建模竞赛的人肯定能得到科学研究的锻炼。然而似乎在
中国这样国情下，各个学校名利心太强了，使得数学建模竞赛这一个如此好的竞赛形
式带来了如此多的不公正，无论从竞赛过程还是评奖过程，指导老师参与的都过多
了，以至有人发出感叹“数学建模究竟是学生参加，还是导师参加呢？”。再就是评
奖的过程的确是人为因素大了点，受大干扰也大了些。


     现在的数学建模竞赛好多都是成了伪造数据竞赛，从赛区的初评来看是产生这种情况
的温床。赛区的初评都是看结果的，结果的好坏直接影响着一篇论文的质量，只要结
果不理想的将很可能是直接刷掉，于是出现了好多数据伪造，只要模型的结果不理
想，在时间不允许的前提下只能这样，要不然尽管在问题的解决中有创新，但是人家
根本就看不到了。这样的事实看多了，可以说麻木了。看着那么多伪造数据的论文拿
国家大奖我只能说数学建模已经在慢慢的贬值，给人一种上当受骗的感觉。数学建模
就是鼓励造假，越假越好，越假越能拿大奖。看到了拿全国大奖的同学，问他们结果
<div>怎么那么好，一句话伤透了心“我们的数据都是伪造的”。伤心之余，被获奖的网友们称</div>
<div>我们队“经验不足，人太老实”进行总结。教训是惨重的，对心灵的打击是不能磨灭的。


    从此对数学建模的印象就不如之前的那么虔诚，感觉都是假的，尽管不想造假，但是
造假获奖得到的是学校的奖励与鼓励，得到的是各种荣誉。从这个方面至少反映了现
在的大学造假之风已经比较严重了。

    相反ACM程序设计竞赛给人的是一种积极向上，公平，公正，机器评判有效的避免了人
为误差，对与不对自有数据进行测试。而且ACM程序设计竞赛还给人一种永远要继续学
习的动力，考察的的各个方面，数学，编程能力，相关学科背景，身体素质，心理素
质，团队合作。。。。。。热爱这个活动的人相信大部分都是一种兴趣，一种发自内
心的热爱，一种追求梦想，一种永远上进的精神。ACM需要长期的积累，没有随便就成
功的，从这个意义上说，ACM也是一种奥林匹克，需要长期的锻炼，加上现场的良好发
挥才能取得好成绩。一个考试成绩很牛的学生可以对经典的最短路
算法，最小生成树算法讲得头头是道，然而就是不能写程序，不能实现自己的想法，
甚至很多人对于经典算法是为了考试而死记硬背下来的。科学技术领域日新月异，计
算机算法领域也是如此，大学本科的教育教材方面已经是难跟上发展，ACM程序设计则
提供了这样一个引领前进的平台，很多教科书上没有的算法与思考方法都可以在赛题
上找到答案，而且通过题目的训练不仅能锻炼编程能力，至少对算法也是应该理解。
所谓“与时俱进”在这里也得到了最大的体现。
<div>                                                             ~~仅以此篇祭拜我一年多来的青春</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>143</wp:post_id>
		<wp:post_date>2012-12-22 04:38:06</wp:post_date>
		<wp:post_date_gmt>2012-12-22 04:38:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>acm%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e7%ab%9e%e8%b5%9b%e4%b8%8e%e6%95%b0%e5%ad%a6%e5%bb%ba%e6%a8%a1%e7%ab%9e%e8%b5%9b%e7%9a%84%e5%af%b9%e6%af%94</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>61</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>~想说的那些话~</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=146</link>
		<pubDate>Sat, 22 Dec 2012 06:00:56 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=146</guid>
		<description></description>
		<content:encoded><![CDATA[     许久未曾写下些什么<span style="font-family: Times New Roman;">,</span>每次抬起手放在键盘上就有种卡住的感觉<span style="font-family: Times New Roman;">,</span>如鲠在喉<span style="font-family: Times New Roman;">.10年9月自己单枪匹马的坐着k538经过一天一夜的奔波来到杭州，进入了计量~</span>时间过的太快了<span style="font-family: Times New Roman;">,</span>禁不起片刻的伫足<span style="font-family: Times New Roman;">.</span>转眼四年已快过四分之三了

     伴随着成长<span style="font-family: Times New Roman;">,</span>随之而来的便是压力<span style="font-family: Times New Roman;">.</span>回忆起小时候信誓旦旦的说想快点长大<span style="font-family: Times New Roman;">,</span>是多么的天真<span style="font-family: Times New Roman;">.</span>殊不知长大的结局就是各种莫名其妙的压力开始死皮赖脸的往你肩上垒<span style="font-family: Times New Roman;">.</span>我并不是反感压力<span style="font-family: Times New Roman;">,</span>反而我倒是挺嗜迷这种压力的感觉<span style="font-family: Times New Roman;">.</span>说来也奇怪<span style="font-family: Times New Roman;">,</span>人总是对自己的真实存在充满怀疑<span style="font-family: Times New Roman;">,</span>而这些代表着责任的压力恰恰填补了存在感缺失的空隙<span style="font-family: Times New Roman;">.</span>

<span style="font-family: Times New Roman;">     思前想后<span style="font-family: Times New Roman;">,</span>总是被一个问题困扰<span style="font-family: Times New Roman;">.</span>人为什么而活<span style="font-family: Times New Roman;">.</span>记得之前不少在室友面前感叹人生,还因而被他们当做笑柄.我们活着的意义是什么呢<span style="font-family: Times New Roman;">?</span>即便那样不着调的理由也算意义的话<span style="font-family: Times New Roman;">,</span>那么人活着连这种可怜的意义都没有<span style="font-family: Times New Roman;">.</span>长辈们说为了下一代<span style="font-family: Times New Roman;">,</span>父母为了儿女<span style="font-family: Times New Roman;">,</span>儿女又为了未来的下一代<span style="font-family: Times New Roman;">.</span>这便是如今普遍支撑起人们意志的理由<span style="font-family: Times New Roman;">.</span>然而这是意义么<span style="font-family: Times New Roman;">?</span>也许问题本身就存在毛病<span style="font-family: Times New Roman;">,</span>很多事情并不是为了有意义而存在的<span style="font-family: Times New Roman;">.</span>这世间万物的存在<span style="font-family: Times New Roman;">,</span>它们又何时想过意义<span style="font-family: Times New Roman;">.</span>所以太追求意义只是可笑的作茧自缚<span style="font-family: Times New Roman;">.</span></span>

<span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;">   之前想过~十多年的寒窗<span style="font-family: Times New Roman;">”</span>苦<span style="font-family: Times New Roman;">”</span>读<span style="font-family: Times New Roman;">,</span>总想给自己放个长长的假<span style="font-family: Times New Roman;">.</span>去各处游历也好<span style="font-family: Times New Roman;">.就像南宁帮的小宝哥一样现在到处旅游~</span>总之是想过一种没有任何压力的生活<span style="font-family: Times New Roman;">.</span>但是现实是禁不起这么久的清闲的<span style="font-family: Times New Roman;">.</span>正如我刚才说的<span style="font-family: Times New Roman;">,</span>时间禁不起半点伫足</span></span>

<span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;">    前几天跟老同学调侃~~大家都问毕业后会回省内发展吗？我说不回的~原因很简单：专业不对口~我也想为家乡的发展作贡献的~毕竟很多人都说<span style="font-family: Times New Roman;">,</span>像我这样还会那么一丁半点技术的水货<span style="font-family: Times New Roman;">,</span>应该去杭州上海深圳那样的大城市去发展<span style="font-family: Times New Roman;">,待遇很更好~自己身边的大牛们也都奔向这些城市~待遇都5k左右或者更多的~或许吧~但这样随之就有很多问题随之而来~</span></span></span>

<span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;">     原来在人人上面看过几篇帖子<span style="font-family: Times New Roman;">,</span>有说父母慢慢变老的细节的<span style="font-family: Times New Roman;">,</span>也有正儿八经计算我们一生还能见父母多少次的<span style="font-family: Times New Roman;">.</span>不管形式如何<span style="font-family: Times New Roman;">,</span>主题都是一样<span style="font-family: Times New Roman;">.</span>人在长大<span style="font-family: Times New Roman;">,</span>父母在变老<span style="font-family: Times New Roman;">.</span>我们在一起的年华并不如我们想象的那么多了<span style="font-family: Times New Roman;">.</span>看完之后感触颇深<span style="font-family: Times New Roman;">,”</span>父母在<span style="font-family: Times New Roman;">,</span>不远游<span style="font-family: Times New Roman;">”</span>也成了我经常念及的话<span style="font-family: Times New Roman;">.</span>虽说<span style="font-family: Times New Roman;">”</span>好男儿志在四方<span style="font-family: Times New Roman;">”</span>苦守一地只会沦为窝囊的代名词<span style="font-family: Times New Roman;">.</span>但我总觉得<span style="font-family: Times New Roman;">,</span>人活着总要去在意一点情感吧<span style="font-family: Times New Roman;">,</span>这样也不妄自诩情感生物<span style="font-family: Times New Roman;">.</span>时常能见着父母<span style="font-family: Times New Roman;">,</span>能隔三岔五的嘘个寒问个暖什么的才是我想要的<span style="font-family: Times New Roman;">.所以现在的我远在它乡~一周至少会打两次长途回家跟老爸老妈唠叨上一段时间~算是对自己的罪过的一种弥补吧~至少这样我打完电话的心情总是明朗~就像之前我打回去告诉放假回家的具体日期后~~现在我每次打回去他们都会问票买的怎么样了~</span></span></span></span>

<span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;">    之前打电话回家老爸老妈总会问生活费还够用吗？我总说够用的~其实确是够用了~虽说每个家庭<span style="font-family: Times New Roman;">,</span>每位父母都不会计较儿女用自己再多的钱<span style="font-family: Times New Roman;">.</span>但是潜移默化的从家长的口中会流露出<span style="font-family: Times New Roman;">,</span>诸如<span style="font-family: Times New Roman;">”</span>这么大还用家里的钱<span style="font-family: Times New Roman;">”</span>或者<span style="font-family: Times New Roman;">”</span>养你那么多年<span style="font-family: Times New Roman;">,</span>看看你用我了多少钱<span style="font-family: Times New Roman;">”</span>此类的<span style="font-family: Times New Roman;">,</span>看似平常<span style="font-family: Times New Roman;">,</span>却略带点责备的语句<span style="font-family: Times New Roman;">.</span>请原谅我的狭隘<span style="font-family: Times New Roman;">,</span>我总感觉这些话是莫大的讽刺<span style="font-family: Times New Roman;">.</span>它仿佛一个驮在你背上<span style="font-family: Times New Roman;">,</span>你甩也甩不掉的怪物<span style="font-family: Times New Roman;">.</span>还时刻的提醒你<span style="font-family: Times New Roman;">,</span>告诫你<span style="font-family: Times New Roman;">,</span>你这个浪费钱的家伙<span style="font-family: Times New Roman;">,</span>你的存在根本就是一个错误<span style="font-family: Times New Roman;">,</span>一个天天吃了睡<span style="font-family: Times New Roman;">,</span>睡了吃的东西居然浪费这么多金钱<span style="font-family: Times New Roman;">,</span>可耻<span style="font-family: Times New Roman;">,</span>可恨<span style="font-family: Times New Roman;">!</span>每每想到此处<span style="font-family: Times New Roman;">,</span>我心中便充满了负罪感<span style="font-family: Times New Roman;">,</span>恨不得马上去死掉<span style="font-family: Times New Roman;">.我有平板，尼康卡片机,移动硬盘各种高端电子设备~其实是我在上海的老哥给我买的~总之我不想成为家人的负担了~</span></span></span></span></span>

<span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;">       总之<span style="font-family: Times New Roman;">,</span>再多的原因都是我在自说自话<span style="font-family: Times New Roman;">.路</span>是错是对反正已经走到了这一步<span style="font-family: Times New Roman;">,</span>定要认认真真<span style="font-family: Times New Roman;">,</span>踏踏实实的走下去<span style="font-family: Times New Roman;">.</span>说起<span style="font-family: Times New Roman;">”</span>踏踏实实<span style="font-family: Times New Roman;">”,</span>这也是我这些年来感悟最多的一个词<span style="font-family: Times New Roman;">.不管友情<span style="font-family: Times New Roman;">,</span>亲情<span style="font-family: Times New Roman;">,</span>爱情都不是该用语言来诠释的东西<span style="font-family: Times New Roman;">.</span>用心去做<span style="font-family: Times New Roman;">,心中自泯~</span>冷暖自知的便好<span style="font-family: Times New Roman;">.</span></span></span></span></span></span></span>

<span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;">         写了好多也说了好多~这些年来经历也算不少了~今天看了自己大一写的那些计划~发现自己写的那些东西居然跟自己如今的行径大体相同~不论如何~世界末日已过~~新纪元开始了~~这也算是给自己新纪元的新的风向标吧~想说的太多了~~以后再说吧~~</span></span></span></span></span></span></span>

<span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;"><span style="font-family: Times New Roman;">                                                                                                              --by 2012-12-22 mdk-vimer</span></span></span></span></span></span></span>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>146</wp:post_id>
		<wp:post_date>2012-12-22 06:00:56</wp:post_date>
		<wp:post_date_gmt>2012-12-22 06:00:56</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%83%b3%e8%af%b4%e7%9a%84%e9%82%a3%e4%ba%9b%e8%af%9d</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>117</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>TCP协议疑难杂症全景解析</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=154</link>
		<pubDate>Mon, 24 Dec 2012 07:38:57 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=154</guid>
		<description></description>
		<content:encoded><![CDATA[<span style="color: #333333;"> 转自<a href="http://blog.csdn.net/dog250/article/details/6612496#comments">http://blog.csdn.net/dog250/article/details/6612496#comments</a></span>

&nbsp;
<h1><a name="t0"></a>说明：</h1>
<span style="color: #333333;">1).本文以TCP的发展历程解析容易引起混淆，误会的方方面面
2).本文不会贴大量的源码，大多数是以文字形式描述，我相信文字看起来是要比代码更轻松的
3).针对对象：对TCP已经有了全面了解的人。因为本文不会解析TCP头里面的每一个字段或者3次握手的细节，也不会解释慢启动和快速重传的定义
4).除了《TCP/IP详解》(卷一，卷二)以及《Unix网络编程》以及Linux源代码之外，学习网络更好的资源是RFC
</span>

5).本文给出一个提纲，如果想了解细节，请直接查阅RFC

&nbsp;

6).翻来覆去，终于找到了这篇备忘，本文基于这篇备忘文档修改。

&nbsp;
<h1><a name="t1"></a>1.网络协议设计</h1>
<span style="color: #333333;">ISO提出了OSI分层网络模型，这种分层模型是理论上的，TCP/IP最终实现了一个分层的协议模型，每一个层次对应一组网络协议完成一组特定的功能，该组网络协议被其下的层次复用和解复用。这就是分层模型的本质，最终所有的逻辑被编码到线缆或者电磁波。
分层模型是很好理解的，然而对于每一层的协议设计却不是那么容易。TCP/IP的漂亮之处在于：协议越往上层越复杂。我们把网络定义为互相连接在一起的设备，网络的本质作用还是“端到端”的通信，然而希望互相通信的设备并不一定要“直接”连接在一起，因此必然需要一些中间的设备负责转发数据，因此就把连接这些中间设备的线缆上跑的协议定义为链路层协议，实际上所谓链路其实就是始发与一个设备，通过一根线，终止于另一个设备。我们把一条链路称为“一跳”。因此一个端到端的网络包含了“很多跳”。
</span>
<h1><a name="t2"></a>2.TCP和IP协议</h1>
<span style="color: #333333;">终止于IP协议，我们已经可以完成一个端到端的通信，为何还需要TCP协议？这是一个问题，理解了这个问题，我们就能理解TCP协议为何成了现在这个样子，为何如此“复杂”，为何又如此简单。
正如其名字所展示的那样，TCP的作用是传输控制，也就是控制端到端的传输，那为何这种控制不在IP协议中实现的。答案很简单，那就是这会增加IP协议的复杂性，而IP协议需要的就是简单。这是什么原因造成的呢？
首先我们认识一下为何IP协议是沙漏的细腰部分。它的下层是繁多的链路层协议，这些链路提供了相互截然不同且相差很远的语义，为了互联这些异构的网络，我们需要一个网络层协议起码要提供一些适配的功能，另外它必然不能提供太多的“保证性服务”，因为上层的保证性依赖下层的约束性更强的保证性，你永远无法在一个100M吞吐量的链路之上实现的IP协议保证1000M的吞吐量...
IP协议设计为分组转发协议，每一跳都要经过一个中间节点<span style="text-decoration: underline;">，路由的设计是TCP/IP网络的另一大创举</span>，这样，IP协议就无需方向性，路由信息和协议本身不再强关联，它们仅仅通过IP地址来关联，因此，IP协议更加简单。路由器作为中间节点也不能太复杂，这涉及到成本问题，因此路由器只负责选路以及转发数据包。
因此传输控制协议必然需要在端点实现。在我们详谈TCP协议之前，首先要看一下它不能做什么，由于IP协议不提供保证，TCP也不能提供依赖于IP下层链路的这种保证，比如带宽，比如时延，这些都是链路层决定的，既然IP协议无法修补，TCP也不能，然而它却能修正始于IP层的一些“不可保证性质”，这些性质包括IP层的不可靠，IP层的不按顺序，IP层的无方向/无连接。
将该小节总结一下，TCP/IP模型从下往上，功能增加，需要实现的设备减少，然而设备的复杂性却在增加，这样保证了成本的最小化，至于性能或者因素，靠软件来调节吧，TCP协议就是这样的软件，实际上最开始的时候，TCP并不考虑性能，效率，公平性，正是考虑了这些，TCP协议才复杂了起来。
</span>
<h1><a name="t3"></a>3.TCP协议</h1>
<span style="color: #333333;">这是一个纯软件协议，为何将其设计上两个端点，参见上一小节，本节详述TCP协议，中间也穿插一些简短的论述。
</span>
<h2><a name="t4"></a>3.1.TCP协议</h2>
<span style="color: #333333;"><span style="text-decoration: underline;"><strong>确切的说，TCP协议有两重身份，作为网络协议，它弥补了IP协议尽力而为服务的不足，实现了有连接，可靠传输，报文按序到达。作为一个主机软件，它和UDP以及左右的传输层协议隔离了主机服务和网络，它们可以被看做是一个多路复用/解复用器，将诸多的主机进程数据复用/解复用到IP层。</strong></span>可以看出，不管从哪个角度，TCP都作为一个接口存在，作为网络协议，它和对端的TCP接口，实现TCP的控制逻辑，作为多路复用/解复用器，它和下层IP协议接口，实现协议栈的功能，而这正是分层网络协议模型的基本定义(两类接口，一类和下层接口，另一类和对等层接口)。
我们习惯于将TCP作为协议栈的最顶端，而不把应用层协议当成协议栈的一部分，这部分是因为应用层被TCP/UDP解复用了之后，呈现出了一种太复杂的局面，应用层协议用一种不同截然不同的方式被解释，应用层协议习惯于用类似ASN.1标准来封装，这正体现了TCP协议作为多路复用/解复用器的重要性，由于直接和应用接口，它可以很容易直接被应用控制，实现不同的传输控制策略，这也是TCP被设计到离应用不太远的地方的原因之一。
总之，<span style="text-decoration: underline;"><strong>TCP要点有四，一曰有连接，二曰可靠传输，三曰数据按照到达，四曰端到端流量控制。</strong></span>注意，TCP被设计时只保证这四点，此时它虽然也有些问题，然而很简单，然而更大的问题很快呈现出来，使之不得不考虑和IP网络相关的东西，比如公平性，效率，因此增加了拥塞控制，这样TCP就成了现在这个样子。
</span>
<h2><a name="t5"></a>3.2.有连接，可靠传输，数据按序到达的TCP</h2>
<span style="color: #333333;">IP协议是没有方向的，数据报传输能到达对端全靠路由，因此它是一跳一跳地到达对端的，只要有一跳没有到达对端的路由，那么数据传输将失败，其实路由也是互联网的核心之一，实际上IP层提供的核心基本功能有两点，第一点是地址管理，第二点就是路由选路。TCP利用了IP路由这个简单的功能，因此TCP不必考虑选路，这又一个它被设计成端到端协议的原因。
既然IP已经能尽力让单独的数据报到达对端，那么TCP就可以在这种尽力而为的网络上实现其它的更加严格的控制功能。TCP给无连接的IP网络通信增加了连接性，确认了已经发送出去的数据的状态，并且保证了数据的顺序。
</span>
<h3><a name="t6"></a>3.2.1.有连接</h3>
<span style="color: #333333;">这是TCP的基本，因为后续的传输的可靠性以及数据顺序性都依赖于一条连接，这是最简单的实现方式，因此TCP被设计成一种基于流的协议，既然TCP需要事先建立连接，之后传输多少数据就无所谓了，只要是同一连接的数据能识别出来即可。
疑难杂症1：3次握手和4次挥手
TCP使用3次握手建立一条连接，该握手初始化了传输可靠性以及数据顺序性必要的信息，这些信息包括两个方向的初始序列号，确认号由初始序列号生成，使用3次握手是因为3次握手已经准备好了传输可靠性以及数据顺序性所必要的信息，该握手的第3次实际上并不是需要单独传输的，完全可以和数据一起传输。
TCP使用4次挥手拆除一条连接，为何需要4次呢？因为TCP是一个全双工协议，必须单独拆除每一条信道。注意，4次挥手和3次握手的意义是不同的，很多人都会问为何建立连接是3次握手，而拆除连接是4次挥手。<strong>3次握手的目的很简单，就是分配资源，初始化序列号，这时还不涉及数据传输，3次就足够做到这个了，而4次挥手的目的是终止数据传输，并回收资源，此时两个端点两个方向的序列号已经没有了任何关系，必须等待两方向都没有数据传输时才能拆除虚链路，不像初始化时那么简单，发现SYN标志就初始化一个序列号并确认SYN的序列号。因此必须单独分别在一个方向上终止该方向的数据传输。</strong>
疑难杂症2：TIME_WAIT状态
为何要有这个状态，<span style="text-decoration: underline;"><strong>原因很简单，那就是每次建立连接的时候序列号都是随机产生的，并且这个序列号是32位的，会回绕。</strong></span>现在我来解释这和TIME_WAIT有什么关系。
任何的TCP分段都要在尽力而为的IP网络上传输，中间的路由器可能会随意的缓存任何的IP数据报，它并不管这个IP数据报上被承载的是什么数据，然而根据经验和互联网的大小，一个IP数据报最多存活MSL(这是根据地球表面积，电磁波在各种介质中的传输速率以及IP协议的TTL等综合推算出来的，如果在火星上，这个MSL会大得多...)。
现在我们考虑终止连接时的被动方发送了一个FIN，然后主动方回复了一个ACK，然而这个ACK可能会丢失，这会造成被动方重发FIN，这个FIN可能会在互联网上存活MSL。
如果没有TIME_WAIT的话，假设连接1已经断开，然而其被动方最后重发的那个FIN(或者FIN之前发送的任何TCP分段)还在网络上，然而连接2重用了连接1的所有的5元素(源IP，目的IP，TCP，源端口，目的端口)，刚刚将建立好连接，连接1迟到的FIN到达了，这个FIN将以比较低但是确实可能的概率终止掉连接2.
为何说是概率比较低呢？这涉及到一个匹配问题，迟到的FIN分段的序列号必须落在连接2的一方的期望序列号范围之内。虽然这种巧合很少发生，但确实会发生，毕竟初始序列号是随机产生了。因此终止连接的主动方必须在接受了被动方且回复了ACK之后等待2*MSL时间才能进入CLOSE状态，之所以乘以2是因为这是保守的算法，最坏情况下，针对被动方的ACK在以最长路线(经历一个MSL)经过互联网马上到达被动方时丢失。
为了应对这个问题，RFC793对初始序列号的生成有个建议，那就是设定一个基准，在这个基准之上搞随机，这个基准就是时间，我们知道时间是单调递增的。然而这仍然有问题，那就是回绕问题，如果发生回绕，那么新的序列号将会落到一个很低的值。<strong>因此最好的办法就是避开“重叠”，其含义就是基准之上的随机要设定一个范围。</strong>
要知道，很多人很不喜欢看到服务器上出现大量的TIME_WAIT状态的连接，因此他们将TIME_WAIT的值设置的很低，这虽然在大多数情况下可行，然而确实也是一种冒险行为。最好的方式就是，不要重用一个连接。
疑难杂症3：重用一个连接和重用一个套接字
这是根本不同的，单独重用一个套接字一般不会有任何问题，因为TCP是基于连接的。比如在服务器端出现了一个TIME_WAIT连接，那么该连接标识了一个五元素，只要客户端不使用相同的源端口，连接服务器是没有问题的，因为迟到的FIN永远不会到达这个连接。记住，一个五元素标识了一个连接，而不是一个套接字(当然，对于BSD套接字而言，服务端的accept套接字确实标识了一个连接)。
</span>
<h3><a name="t7"></a>3.2.2.传输可靠性</h3>
<span style="color: #333333;">基本上传输可靠性是靠确认号实现的，也就是说，每发送一个分段，接下来接收端必然要发送一个确认，发送端收到确认后才可以发送下一个字节。这个原则最简单不过了，教科书上的“停止-等待”协议就是这个原则的字节版本，只是TCP使用了滑动窗口机制使得每次不一定发送一个字节，但是这是后话，本节仅仅谈一下确认的超时机制。
怎么知道数据到达对端呢？那就是对端发送一个确认，但是如果一直收不到对端的确认，发送端等多久呢？如果一直等下去，那么将无法发现数据的丢失，协议将不可用，如果等待时间过短，可能确认还在路上，因此等待时间是个问题，另外如何去管理这个超时时间也是一个问题。
疑难杂症4：超时时间的计算
绝对不能随意去揣测超时的时间，而应该给出一个精确的算法去计算。毫无疑问，一个TCP分段的回复到达的时间就是一个数据报往返的时间，因此标准定义了一个新的名词RTT，代表一个TCP分段的往返时间。然而我们知道，IP网络是尽力而为的，并且路由是动态的，且路由器会毫无先兆的缓存或者丢弃任何的数据报，因此这个RTT是需要动态测量的，也就是说起码每隔一段时间就要测量一次，如果每次都一样，万事大吉，然而世界并非如你所愿，因此我们需要找到的恰恰的一个“平均值”，而不是一个准确值。
这个平均值如果仅仅直接通过计算多次测量值取算术平均，那是不恰当的，因为对于数据传输延时，我们必须考虑的路径延迟的瞬间抖动，否则如果两次测量值分别为2和98，那么超时值将是50，这个值对于2而言，太大了，结果造成了数据的延迟过大(本该重传的等待了好久才重传)，然而对于98而言，太小了，结果造成了过度重传(路途遥远，本该很慢，结果大量重传已经正确确认但是迟到的TCP分段)。
因此，<strong>除了考虑每两次测量值的偏差之外，其变化率也应该考虑在内，如果变化率过大，则通过以变化率为自变量的函数为主计算RTT(如果陡然增大，则取值为比较大的正数，如果陡然减小，则取值为比较小的负数，然后和平均值加权求和)，反之如果变化率很小，则取测量平均值。</strong>这是不言而喻的，这个算法至今仍然工作的很好。
疑难杂症5：超时计时器的管理-每连接单一计时器
很显然，对每一个TCP分段都生成一个计时器是最直接的方式，每个计时器在RTT时间后到期，如果没有收到确认，则重传。然而这只是理论上的合理，对于大多数操作系统而言，这将带来巨大的内存开销和调度开销，因此采取每一个TCP连接单一计时器的设计则成了一个默认的选择。可是单一的计时器怎么管理如此多的发出去的TCP分段呢？又该如何来设计单一的计时器呢。
设计单一计时器有两个原则：1.每一个报文在长期收不到确认都必须可以超时；2.这个长期收不到中长期不能和测量的RTT相隔太远。因此RFC2988定义一套很简单的原则：
<span style="text-decoration: underline;"><strong>a.发送TCP分段时，如果还没有重传定时器开启，那么开启它。
b.发送TCP分段时，如果已经有重传定时器开启，不再开启它。
c.收到一个非冗余ACK时，如果有数据在传输中，重新开启重传定时器。
d.收到一个非冗余ACK时，如果没有数据在传输中，则关闭重传定时器。</strong></span>
我们看看这4条规则是如何做到以上两点的，根据a和c(在c中，注意到ACK是非冗余的)，任何TCP分段只要不被确认，超时定时器总会超时的。然而为何需要c呢？只有规则a存在的话，也可以做到原则1。实际上确实是这样的，但是为了不会出现过早重传，才添加了规则c，如果没有规则c，那么万一在重传定时器到期前，发送了一些数据，这样在定时器到期后，除了很早发送的数据能收到ACK外，其它稍晚些发送的数据的ACK都将不会到来，因此这些数据都将被重传。有了规则c之后，只要有分段ACK到来，则重置重传定时器，这很合理，因此大多数正常情况下，从数据的发出到ACK的到来这段时间以及计算得到的RTT以及重传定时器超时的时间这三者相差并不大，一个ACK到来后重置定时器可以保护后发的数据不被过早重传。
这里面还有一些细节需要说明。一个ACK到来了，说明后续的ACK很可能会依次到来，也就是说丢失的可能性并不大，另外，即使真的有后发的TCP分段丢失现象发生，也会在最多2倍定时器超时时间的范围内被重传(假设该报文是第一个报文发出启动定时器之后马上发出的，丢失了，第一个报文的ACK到来后又重启了定时器，又经过了一个超时时间才会被重传)。虽然这里还没有涉及拥塞控制，但是可见网络拥塞会引起丢包，丢包会引起重传，过度重传反过来加重网络拥塞，设置规则c的结果可以缓解过多的重传，毕竟将启动定时器之后发送的数据的重传超时时间拉长了最多一倍左右。最多一倍左右的超时偏差做到了原则2，即“这个长期收不到中长期不能和测量的RTT相隔太远”。
还有一点，如果是一个发送序列的最后一个分段丢失了，后面就不会收到冗余ACK，这样就只能等到超时了，并且超时时间几乎是肯定会比定时器超时时间更长。如果这个分段是在发送序列的靠后的时间发送的且和前面的发送时间相隔时间较远，则其超时时间不会很大，反之就会比较大。
疑难杂症6：何时测量RTT
目前很多TCP实现了时间戳，这样就方便多了，发送端再也不需要保存发送分段的时间了，只需要将其放入协议头的时间戳字段，然后接收端将其回显在ACK即可，然后发送端收到ACK后，取出时间戳，和当前时间做算术差，即可完成一次RTT的测量。
</span>
<h3><a name="t8"></a>3.2.3.数据顺序性</h3>
<span style="color: #333333;">基本上传输可靠性是靠序列号实现的。
疑难杂症7：确认号和超时重传
确认号是一个很诡异的东西，因为TCP的发送端对于发送出去的一个数据序列，它只要收到一个确认号就认为确认号前面的数据都被收到了，即使前面的某个确认号丢失了，也就是说，发送端只认最后一个确认号。这是合理的，因为确认号是接收端发出的，接收端只确认按序到达的最后一个TCP分段。
另外，发送端重发了一个TCP报文并且接收到该TCP分段的确认号，并不能说明这个重发的报文被接收了，也可能是数据早就被接收了，只是由于其ACK丢失或者其ACK延迟到达导致了超时。值得说明的是，接收端会丢弃任何重复的数据，即使丢弃了重复的数据，其ACK还是会照发不误的。
标准的早期TCP实现为，只要一个TCP分段丢失，即使后面的TCP分段都被完整收到，发送端还是会重传从丢失分段开始的所有报文，这就会导致一个问题，那就是重传风暴，一个分段丢失，引起大量的重传。这种风暴实则不必要的，因为大多数的TCP实现中，接收端已经缓存了乱序的分段，这些被重传的丢失分段之后的分段到达接收端之后，很大的可能性是被丢弃。关于这一点在拥塞控制被引入之后还会提及(问题先述为快：本来报文丢失导致超时就说明网络很可能已然拥塞，重传风暴只能加重其拥塞程度)。
疑难杂症8：乱序数据缓存以及选择确认
TCP是保证数据顺序的，但是并不意味着它总是会丢弃乱序的TCP分段，具体会不会丢弃是和具体实现相关的，RFC建议如果内存允许，还是要缓存这些乱序到来的分段，然后实现一种机制等到可以拼接成一个按序序列的时候将缓存的分段拼接，这就类似于IP协议中的分片一样，但是由于IP数据报是不确认的，因此IP协议的实现必须缓存收到的任何分片而不能将其丢弃，因为丢弃了一个IP分片，它就再也不会到来了。
现在，TCP实现了一种称为<strong>选择确认</strong>的方式，接收端会显式告诉发送端需要重传哪些分段而不需要重传哪些分段。这无疑避免了重传风暴。
疑难杂症9：TCP序列号的回绕的问题
TCP的序列号回绕会引起很多的问题，比如序列号为s的分段发出之后，m秒后，序列号比s小的序列号为j的分段发出，只不过此时的j比上一个s多了一圈，这就是回绕问题，那么如果这后一个分段到达接收端，这就会引发彻底乱序-本来j该在s后面，结果反而到达前面了，这种乱序是TCP协议检查不出来的。我们仔细想一下，这种情况确实会发生，数据分段并不是一个字节一个字节发送出去的，如果存在一个速率为1Gbps的网络，TCP发送端1秒会发送125MB的数据，32位的序列号空间能传输2的32次方个字节，也就是说32秒左右就会发生回绕，我们知道这个值远小于MSL值，因此会发生的。
有个细节可能会引起误会，那就是TCP的窗口大小空间是序列号空间的一半，这样恰好在满载情况下，数据能填满发送窗口和接收窗口，序列号空间正好够用。然而事实上，TCP的初始序列号并不是从0开始的，而是随机产生的(当然要辅助一些更精妙的算法)，因此如果初始序列号比较接近2的32次方，那么很快就会回绕。
当然，如今可以用时间戳选项来辅助作为序列号的一个识别的部分，接收端遇到回绕的情况，需要比较时间戳，我们知道，时间戳是单调递增的，虽然也会回绕，然而回绕时间却要长很多。这只是一种策略，在此不详谈。还有一个很现实的问题，理论上序列号会回绕，但是实际上，有多少TCP的端点主机直接架设在1G的网络线缆两端并且接收方和发送方的窗口还能恰好被同时填满。另外，就算发生了回绕，也不是一件特别的事情，回绕在计算机里面太常见了，只需要能识别出来即可解决，对于TCP的序列号而言，在高速网络(点对点网络或者以太网)的两端，数据发生乱序的可能性很小，因此当收到一个序列号突然变为0或者终止序列号小于起始序列号的情况后，很容易辨别出来，只需要和前一个确认的分段比较即可，如果在一个经过路由器的网络两端，会引发IP数据报的顺序重排，对于TCP而言，虽然还会发生回绕，也会慢得多，且考虑到拥塞窗口(目前还没有引入)一般不会太大，窗口也很难被填满到65536。
</span>
<h3><a name="t9"></a>3.2.4.端到端的流量控制</h3>
<span style="color: #333333;">端到端的流量控制使用滑动窗口来实现。滑动窗口的原理非常简单，基本就是一个生产者/消费者模型
疑难杂症10：流量控制的真实意义
很多人以为流量控制会很有效的协调两端的流量匹配，确实是这样，但是如果你考虑到网络的利用率问题，TCP的流量控制机制就不那么完美了，造成这种局面的原因在于，滑动窗口只是限制了最大发送的数据，却没有限制最小发送的数据，结果导致一些很小的数据被封装成TCP分段，报文协议头所占的比例过于大，造成网络利用率下降，这就引出了接下来的内容，那就是端到端意义的TCP协议效率。
<em><strong>~~~~~~~~~~~~~~~~~~~~
承上启下
终于到了阐述问题的时候了，以上的TCP协议实现的非常简单，这也是TCP的标准实现，然而很快我们就会发现各种各样的问题。这些问题导致了标准化协会对TCP协议进行了大量的修补，这些修补杂糅在一起让人们有些云里雾里，不知所措。本文档就旨在分离这些杂乱的情况，实际上，根据RFC，这些杂乱的情况都是可以找到其单独的发展轨迹的。
~~~~~~~~~~~~~~~~~~~~</strong></em>

</span>
<h1><a name="t10"></a>4.端到端意义上的TCP协议效率</h1>
&nbsp;
<h2><a name="t11"></a>4.1.三个问题以及解决</h2>
<span style="color: #333333;"><span style="text-decoration: underline;"><strong>问题1描述：接收端处理慢，导致接收窗口被填满</strong></span>
这明显是速率不匹配引发的问题，然而即使速率不匹配，只要滑动窗口能协调好它们的速率就好，要快都快，要慢都慢，事实上滑动窗口在这一点上做的很好。但是如果我们不得不从效率上来考虑问题的话，事实就不那么乐观了。考虑此时接收窗口已然被填满，慢速的应用程序慢腾腾的读取了一个字节，空出一个位置，然后通告给TCP的发送端，发送端得知空出一个位置，马上发出一个字节，又将接收端填满，然后接收应用程序又一次慢腾腾...这就是糊涂窗口综合症，一个大多数人都很熟悉的词。这个问题极大的浪费了网络带宽，降低了网络利用率。好比从大同拉100吨煤到北京需要一辆车，拉1Kg煤到北京也需要一辆车(超级夸张的一个例子，请不要相信)，但是一辆车开到北京的开销是一定的...
<span style="text-decoration: underline;"><strong>问题1解决：窗口通告</strong></span>
对于问题1，很显然问题出在接收端，我们没有办法限制发送端不发送小分段，但是却可以限制接收端通告小窗口，这是合理的，这并不影响应用程序，此时经典的延迟/吞吐量反比律将不再适用，因为接收窗口是满的，其空出一半空间表示还有一半空间有数据没有被应用读取，和其空出一个字节的空间的效果是一样的，因此可以限制接收端当窗口为0时，直接通告给发送端以阻止其继续发送数据，只有当其接收窗口再次达到MSS的一半大小的时候才通告一个不为0的窗口，此前对于所有的发送端的窗口probe分段(用于探测接收端窗口大小的probe分段，由TCP标准规定)，全部通告窗口为0，这样发送端在收到窗口不为0的通告，那么肯定是一个比较大的窗口，因此发送端可以一次性发出一个很大的TCP分段，包含大量数据，也即拉了好几十吨的煤到北京，而不是只拉了几公斤。
即，限制窗口通告时机，解决糊涂窗口综合症
<span style="text-decoration: underline;"><strong>问题2描述：发送端持续发送小包，导致窗口闲置</strong></span>
这明显是发送端引起的问题，此时接收端的窗口开得很大，然而发送端却不积累数据，还是一味的发送小块数据分段。只要发送了任和的分段，接收端都要无条件接收并且确认，这完全符合TCP规范，因此必然要限制发送端不发送这样的小分段。
<span style="text-decoration: underline;"><strong>问题2解决：Nagle算法</strong></span>
Nagel算法很简单，标准的Nagle算法为：
<span style="text-decoration: underline;"><em><strong>IF 数据的大小和窗口的大小都超过了MSS
Then 发送数据分段
ELSE
IF 还有发出的TCP分段的确认没有到来
Then 积累数据到发送队列的末尾的TCP分段
ELSE
发送数据分段
EndIF
EndIF</strong></em></span>
可是后来，这个算法变了，变得更加灵活了，其中的：
<span style="text-decoration: underline;"><em><strong>IF 还有发出的TCP分段的确认没有到来</strong></em></span>
变成了
<span style="text-decoration: underline;"><em><strong>IF 还有发出的不足MSS大小的TCP分段的确认没有到来</strong></em></span>
这样如果发出了一个MSS大小的分段还没有被确认，后面也是可以随时发送一个小分段的，这个改进降低了算法对延迟时间的影响。这个算法体现了一种自适应的策略，越是确认的快，越是发送的快，虽然Nagle算法看起来在积累数据增加吞吐量的同时也加大的时延，可事实上，如果对于类似交互式的应用，时延并不会增加，因为这类应用回复数据也是很快的，比如Telnet之类的服务必然需要回显字符，因此能和对端进行自适应协调。
注意，Nagle算法是默认开启的，但是却可以关闭。如果在开启的情况下，那么它就严格按照上述的算法来执行。
<span style="text-decoration: underline;"><strong>问题3.确认号(ACK)本身就是不含数据的分段，因此大量的确认号消耗了大量的带宽</strong></span>
这是TCP为了确保可靠性传输的规范，然而大多数情况下，ACK还是可以和数据一起捎带传输的。如果没有捎带传输，那么就只能单独回来一个ACK，如果这样的分段太多，网络的利用率就会下降。从大同用火车拉到北京100吨煤，为了确认煤已收到，北京需要派一辆同样的火车空载开到大同去复命，因为没有别的交通工具，只有火车。如果这位复命者刚开着一列火车走，又从大同来了一车煤，这拉煤的哥们儿又要开一列空车去复命了。
<span style="text-decoration: underline;"><strong>问题3的解决：</strong></span>
RFC建议了一种延迟的ACK，也就是说，ACK在收到数据后并不马上回复，而是延迟一段可以接受的时间，延迟一段时间的目的是看能不能和接收方要发给发送方的数据一起回去，因为TCP协议头中总是包含确认号的，如果能的话，就将ACK一起捎带回去，这样网络利用率就提高了。往大同复命的确认者不必开一辆空载火车回大同了，此时北京正好有一批货物要送往大同，这位复命者搭着这批货的火车返回大同。
如果等了一段可以接受的时间，还是没有数据要发往发送端，此时就需要单独发送一个ACK了，然而即使如此，这个延迟的ACK虽然没有等到可以被捎带的数据分段，也可能等到了后续到来的TCP分段，这样它们就可以取最大者一起返回了，要知道，TCP的确认号是收到的按序报文的最后一个字节的后一个字节。最后，RFC建议，延迟的ACK最多等待两个分段的积累确认。
</span>
<h2><a name="t12"></a>4.2.分析三个问题之间的关联</h2>
<span style="color: #333333;">三个问题导致的结果是相同的，但是要知道它们的原因本质上是不同的，问题1几乎总是出现在接收端窗口满的情况下，而问题2几乎总是发生在窗口闲置的情况下，问题3看起来是最无聊的，然而由于TCP的要求，必须要有确认号，而且一个确认号就需要一个TCP分段，这个分段不含数据，无疑是很小的。
三个问题都导致了网络利用率的降低。虽然两个问题导致了同样的结果，但是必须认识到它们是不同的问题，很自然的将这些问题的解决方案汇总在一起，形成一个全局的解决方案，这就是如今的操作系统中的解决方案。
</span>
<h2><a name="t13"></a>4.3.问题的杂糅情况</h2>
<span style="color: #333333;">疑难杂症11：糊涂窗口解决方案和Nagle算法
糊涂窗口综合症患者希望发送端积累TCP分段，而Nagle算法确实保证了一定的TCP分段在发送端的积累，另外在延迟ACK的延迟的那一会时间，发送端会利用这段时间积累数据。然而这却是三个不同的问题。Nagle算法可以缓解糊涂窗口综合症，却不是治本的良药。
疑难杂症12：Nagle算法和延迟ACK
延迟ACK会延长ACK到达发送端的时间，由于标准Nagle算法只允许一个未被确认的TCP分段，那无疑在接收端，这个延迟的ACK是毫无希望等待后续数据到来最终进行积累确认的，如果没有数据可以捎带这个ACK，那么这个ACK只有在延迟确认定时器超时的时候才会发出，这样在等待这个ACK的过程中，发送端又积累了一些数据，因此延迟ACK实际上是在增加延迟的代价下加强了Nagle算法。在延迟ACK加Nagle算法的情况下，接收端只有不断有数据要发回，才能同时既保证了发送端的分段积累，又保证了延迟不增加，同时还没有或者很少有空载的ACK。
要知道，延迟ACK和Nagle是两个问题的解决方案。
疑难杂症13：到底何时可以发送数据
到底何时才能发送数据呢？如果单从Nagle算法上看，很简单，然而事实证明，情况还要更复杂些。如果发送端已经排列了3个TCP分段，分段1，分段2，分段3依次被排入，三个分段都是小分段(不符合Nagle算法中立即发送的标准)，此时已经有一个分段被发出了，且其确认还没有到来，请问此时能发送分段1和2吗？如果按照Nagle算法，是不能发送的，但实际上它们是可以发送的，因为这两个分段已经没有任何机会再积累新的数据了，新的数据肯定都积累在分段3上了。问题在于，分段还没有积累到一定大小时，怎么还可以产生新的分段？这是可能的，但这是另一个问题，在此不谈。
Linux的TCP实现在这个问题上表现的更加灵活，它是这么判断能否发送的(在开启了Nagle的情况下)：
<span style="text-decoration: underline;"><em><strong>IF (没有超过拥塞窗口大小的数据分段未确认 || 数据分段中包含FIN ) &amp;&amp;
数据分段没有超越窗口边界
Then
IF 分段在中间(上述例子中的分段1和2) ||
分段是紧急模式 ||
通过上述的Nagle算法(改进后的Nagle算法)
Then 发送分段
EndIF
EndIF</strong></em></span>
曾经我也改过Nagle算法，确切的说不是修改Nagle算法，而是修改了“到底何时能发送数据”的策略，以往都是发送端判断能否发送数据的，可是如果此时有延迟ACK在等待被捎带，而待发送的数据又由于积累不够或者其它原因不能发送，因此两边都在等，这其实在某些情况下不是很好。我所做的改进中对待何时能发送数据又增加了一种情况，这就是“ACK拉”的情况，一旦有延迟ACK等待发送，判断一下有没有数据也在等待发送，如果有的话，看看数据是否大到了一定程度，在此，我选择的是MSS的一半：
<span style="text-decoration: underline;"><em><strong>IF (没有超过拥塞窗口大小的数据分段未确认 || 数据分段中包含FIN ) &amp;&amp;
数据分段没有超越窗口边界
Then
IF 分段在中间(上述例子中的分段1和2) ||
分段是紧急模式 ||
通过上述的Nagle算法(改进后的Nagle算法)
Then 发送分段
EndIF
ELSE IF 有延迟ACK等待传输 &amp;&amp;
发送队列中有待发送的TCP分段 &amp;&amp;
发送队列的头分段大小大于MSS的一半
Then 发送队列头分段且捎带延迟ACK
EndIF</strong></em></span>
另外，发送队列头分段的大小是可以在统计意义上动态计算的，也不一定非要是MSS大小的一半。我们发现，这种算法对于交互式网路应用是自适应的，你打字越快，特定时间内积累的分段就越长，对端回复的越快(可以捎带ACK)，本端发送的也就越快(以Echo举例会更好理解)。
疑难杂症14：《TCP/IP详解(卷一)》中Nagle算法的例子解读
这个问题在网上搜了很多的答案，有的说RFC的建议，有的说别的。可是实际上这就是一个典型的“竞态问题”：
首先服务器发了两个分段：
数据段12：ack 14
数据段13：ack 14，54:56
然后客户端发了两个分段：
数据段14：ack 54，14:17
数据段15：ack 56，17:18
可以看到数据段14本来应该确认56的，但是确认的却是54。也就是说，数据段已经移出队列将要发送但还未发送的时候，数据段13才到来，软中断处理程序抢占了数据段14的发送进程，要知道此时只是把数据段14移出了队列，还没有更新任何的状态信息，比如“发出但未被确认的分段数量”，此时软中断处理程序顺利接收了分段13，然后更新窗口信息，并且检查看有没有数据要发送，由于分段14已经移出队列，下一个接受发送检查的就是分段15了，由于状态信息还没有更新，因此分段15顺利通过发送检测，发送完成。
可以看Linux的源代码了解相关信息，tcp_write_xmit这个函数在两个地方会被调用，一个是TCP的发送进程中，另一个就是软中断的接收处理中，两者在调用中的竞态就会引起《详解》中的那种情况。注意，这种不加锁的发送方式是合理的，也是最高效的，因此TCP的处理语义会做出判断，丢弃一切不该接收或者重复接收的分段的。
<em><strong>~~~~~~~~~~~~~~~~~~~~
承上启下
又到了该承上启下，到此为止，我们叙述的TCP还都是简单的TCP，就算是简单的TCP，也存在上述的诸多问题，就更别提继续增加TCP的复杂性了。到此为止，我们的TCP都是端到端意义上的，然而实际上TCP要跑在IP网络之上的，而IP网络的问题是很多的，是一个很拥堵网络。不幸的是，TCP的有些关于确认和可靠性的机制还会加重IP网络的拥堵。
~~~~~~~~~~~~~~~~~~~~</strong></em>

</span>
<h1><a name="t14"></a>5.IP网络之上的TCP</h1>
&nbsp;
<h2><a name="t15"></a>5.1.端到端的TCP协议和IP协议之间的矛盾</h2>
<span style="color: #333333;"><strong>端到端的TCP只能看到两个节点，那就是自己和对方，它们是看不到任何中间的路径的。</strong>可是IP网络却是一跳一跳的，它们的矛盾之处在于TCP的端到端流量控制必然会导致网络拥堵。因为每条TCP连接的一端只知道它对端还有多少空间用于接收数据，它们并不管到达对端的路径上是否还有这么大的容量，事实上所有连接的这些空间加在一起将瞬间超过IP网络的容量，因此TCP也不可能按照滑动窗口流量控制机制很理想的运行。
势必需要一种拥塞控制机制，反应路径的拥塞情况。
疑难杂症15：拥塞控制的本质
由于TCP是端到端协议，因此两端之间的控制范畴属于流量控制，IP网络的拥塞会导致TCP分段的丢失，由于TCP看不到中间的路由器，因此这种丢失只会发生中间路由器，当然两个端点的网卡或者IP层丢掉数据分段也是TCP看不到的。因此拥塞控制必然作用于IP链路。事实上我们可以得知，只有在以下情况下拥塞控制才会起作用：
<span style="text-decoration: underline;"><strong>a.两个或两个以上的连接(其中一个一定要是TCP，另一个可以是任意连接)经过同一个路由器或者同一个链路时；
b.只有一个TCP连接，然而它经过了一个路由器时。</strong></span>
其它情况下是不会拥塞的。因为一个TCP总是希望独享整条网络通路，而这对于多个连接而言是不可能的，必须保证TCP的公平性，这样这种拥塞控制机制才合理。本质上，拥塞的原因就是大家都想独享全部带宽资源，结果导致拥塞，这也是合理的，毕竟TCP看不到网络的状态，同时这也决定了TCP的拥塞控制必须采用试探性的方式，最终到达一个足以引起其“反应”的“刺激点”。
拥塞控制需要完成以下两个任务：1.公平性；2.拥塞之后退出拥塞状态。
疑难杂症16：影响拥塞的因素
我们必须认识到拥塞控制是一个整体的机制，它不偏向于任何TCP连接，因此这个机制内在的就包含了公平性。那么影响拥塞的因素都有什么呢？具有讽刺意味的是，起初TCP并没有拥塞控制机制，正是TCP的超时重传风暴(一个分段丢失造成后续的已经发送的分段均被重传，而这些重传大多数是不必要的)加重了网络的拥塞。因此重传必然不能过频，必须把重传定时器的超时时间设置的稍微长一些，而这一点在单一重传定时器的设计中得到了加强。除此TCP自身的因素之外，其它所有的拥塞都可以靠拥塞控制机制来自动完成。
另外，不要把路由器想成一种线速转发设备，再好的路由器只要接入网络，总是会拉低网络的总带宽，因此即使只有一个TCP连接，由于TCP的发送方总是以发送链路的带宽发送分段，这些分段在经过路由器的时候排队和处理总是会有时延，因此最终肯定会丢包的。
最后，丢包的延后性也会加重拥塞。假设一个TCP连接经过了N个路由器，前N-1个路由器都能顺利转发TCP分段，但是最后一个路由器丢失了一个分段，这就导致了这些丢失的分段浪费了前面路由器的大量带宽。
</span>
<h2><a name="t16"></a>5.2.拥塞控制的策略</h2>
<span style="color: #333333;">在介绍拥塞控制之前，首先介绍一下拥塞窗口，它实际上表示的也是“可以发送多少数据”，然而这个和接收端通告的接收窗口意义是不一样的，后者是流量控制用的窗口，而前者是拥塞控制用的窗口，体现了网络拥塞程度。
拥塞控制整体上分为两类，一类是试探性的拥塞探测，另一类则是拥塞避免(注意，不是常规意义上的拥塞避免)。
</span>
<h3><a name="t17"></a>5.2.1.试探性的拥塞探测分为两类，之一是慢启动，之二是拥塞窗口加性扩大(也就是熟知的拥塞避免，然而这种方式是避免不了拥塞的)。</h3>
&nbsp;
<h3><a name="t18"></a>5.2.2.拥塞避免方式拥塞控制旨在还没有发生拥塞的时候就先提醒发送端，网络拥塞了，这样发送端就要么可以进入快速重传/快速恢复或者显式的减小拥塞窗口，这样就避免网络拥塞的一沓糊涂之后出现超时，从而进入慢启动阶段。</h3>
&nbsp;
<h3><a name="t19"></a>5.2.3.快速重传和快速恢复。所谓快速重传/快速恢复是针对慢启动的，我们知道慢启动要从1个MSS开始增加拥塞窗口，而快速重传/快速恢复则是一旦收到3个冗余ACK，不必进入慢启动，而是将拥塞窗口缩小为当前阀值的一半加上3，然后如果继续收到冗余ACK，则将拥塞窗口加1个MSS，直到收到一个新的数据ACK，将窗口设置成正常的阀值，开始加性增加的阶段。</h3>
<span style="color: #333333;">当进入快速重传时，为何要将拥塞窗口缩小为当前阀值的一半加上3呢？加上3是基于数据包守恒来说的，既然已经收到了3个冗余ACK，说明有三个数据分段已经到达了接收端，既然三个分段已经离开了网络，那么就是说可以在发送3个分段了，只要再收到一个冗余ACK，这也说明1个分段已经离开了网络，因此就将拥塞窗口加1个MSS。直到收到新的ACK，说明直到收到第三个冗余ACK时期发送的TCP分段都已经到达对端了，此时进入正常阶段开始加性增加拥塞窗口。
疑难杂症17：超时重传和收到3个冗余ACK后重传
这两种重传的意义是不同的，超时重传一般是因为网络出现了严重拥塞(没有一个分段到达，如果有的话，肯定会有ACK的，若是正常ACK，则重置重传定时器，若是冗余ACK，则可能是个别报文丢失或者被重排序，若连续3个冗余ACK，则很有可能是个别分段丢失)，此时需要更加严厉的缩小拥塞窗口，因此此时进入慢启动阶段。而收到3个冗余ACK后说明确实有中间的分段丢失，然而后面的分段确实到达了接收端，这因为这样才会发送冗余ACK，这一般是路由器故障或者轻度拥塞或者其它不太严重的原因引起的，因此此时拥塞窗口缩小的幅度就不能太大，此时进入快速重传/快速恢复阶段。
疑难杂症18：为何收到3个冗余ACK后才重传
这是一种权衡的结构，收到两个或者一个冗余ACK也可以重传，但是这样的话可能或造成不必要的重传，因为两个数据分段发生乱序的可能性不大，超过三个分段发生乱序的可能性才大，换句话说，如果仅仅收到一个乱序的分段，那很可能被中间路由器重排了，那么另一个分段很可能马上就到，然而如果连续收到了3个分段都没能弥补那个缺漏，那很可能是它丢失了，需要重传。<span style="text-decoration: underline;"><strong>因此3个冗余ACK是一种权衡，在减少不必要重传和确实能检测出单个分段丢失之间所作的权衡。</strong></span>
注意，冗余ACK是不能捎带的。
疑难杂症19：乘性减和加性增的深层含义
为什么是乘性减而加性增呢？拥塞窗口的增加受惠的只是自己，而拥塞窗口减少受益的大家，可是自己却受到了伤害。哪一点更重要呢？我们知道TCP的拥塞控制中内置了公平性，恰恰就是这种乘性减实现了公平性。拥塞窗口的1个MSS的改变影响一个TCP发送者，为了使得自己拥塞窗口的减少影响更多的TCP发送者-让更多的发送者受益，那么采取了乘性减的策略。
当然，BIC算法提高了加性增的效率，不再一个一个MSS的加，而是一次加比较多的MSS，采取二分查找的方式逐步找到不丢包的点，然后加性增。
疑难杂症20：TCP连接的传输稳定状态是什么
首先，先说一下发送端的发送窗口怎么确定，它取的是拥塞窗口和接收端通告窗口的最小值。然后，我们提出三种发送窗口的稳定状态：
<strong>a.IP互联网络上接收端拥有大窗口的经典锯齿状
b.IP互联网络上接收端拥有小窗口的直线状态
c.直连网络端点间的满载状态下的直线状态</strong>
其中a是大多数的状态，因为一般而言，TCP连接都是建立在互联网上的，而且是大量的，比如Web浏览，电子邮件，网络游戏，Ftp下载等等。TCP发送端用慢启动或者拥塞避免方式不断增加其拥塞窗口，直到丢包的发生，然后进入慢启动或者拥塞避免阶段(要看是由于超时丢包还是由于冗余ACK丢包)，此时发送窗口将下降到1或者下降一半，这种情况下，一般接收端的接收窗口是比较大的，毕竟IP网络并不是什么很快速的网络，一般的机器处理速度都很快。
但是如果接收端特别破，处理速度很慢，就会导致其通告一个很小的窗口，这样的话，即使拥塞窗口再大，发送端也还是以通告的接收窗口为发送窗口，这样就不会发生拥塞。最后，如果唯一的TCP连接运行在一个直连的两台主机上，那么它将独享网络带宽，这样该TCP的数据流在最好的情况下将填满网络管道(我们把网络管道定义为带宽和延时的乘积)，其实在这种情况下是不存在拥塞的，就像你一个人独自徘徊在飘雨黄昏的街头一样...
</span>
<h3><a name="t20"></a>5.2.4.主动的拥塞避免</h3>
<span style="color: #333333;">前面我们描述的拥塞控制方式都是试探性的检测，然后拥塞窗口被动的进行乘性减，这样在接收端窗口很大的情况下(一般都是这样，网络拥堵，分段就不会轻易到达接收端，导致接收端的窗口大量空置)就可能出现锯齿形状的“时间-窗口”图，类似在一个拥堵的北京X环上开车，发送机发动，车开动，停止，等待，发动机发动，车开动...听声音也能听出来。
虽然TCP看不到下面的IP网络，然而它还是可以通过检测RTT的变化以及拥塞窗口的变化推算出IP网络的拥堵情况的。就比方说北京东四环一家快递公司要持续送快递到西四环，当发件人发现货到时间越来越慢的时候，他会意识到“下班高峰期快到了”...
可以通过持续观测RTT的方式来主动调整拥塞窗口的大小而不是一味的加性增。然而还有更猛的算法，那就是计算两个差值的乘积：
(当前拥塞窗口-上一次拥塞窗口)x(当前的RTT-上一次的RTT)
如果结果是正数，则拥塞窗口减少1/8，若结果是负数或者0，则窗口增加一个MSS。注意，这回不再是乘性减了，可以看出，减的幅度比乘性减幅度小，这是因为这种拥塞控制是主动的，而不是之前的那种被动的试探方式。在试探方式中，乘性减以一种惩罚的方式实现了公平性，而在这里的主动方式中，当意识到要拥塞的时候，TCP发送者主动的减少了拥塞窗口，为了对这种自首行为进行鼓励，采用了小幅减少拥塞窗口的方式。需要注意的是，在拥塞窗口减小的过程中，乘积的前一个差值是负数，如果后一个差值也是负数，那么结果就是继续缩减窗口，直到拥塞缓解或者窗口减少到了一定程度，使得后一个差值成了正数或者0，这种情况下，其实后一个差值只能变为0。
疑难杂症21：路由器和TCP的互动
虽然有了5.2.4节介绍的主动的拥塞检测，那么路由器能不能做点什么帮助检测拥塞呢？这种对路由器的扩展是必要的，要知道，每天有无数的TCP要通过路由器，虽然路由器不管TCP协议的任何事(当然排除连接跟踪之类的，这里所说的是标准的IP路由器)，但是它却能以一种很简单的方式告诉TCP的两端IP网络发生了拥堵，<span style="text-decoration: underline;"><strong>这种方式就是当路由器检测到自己发生轻微拥堵的时候随机的丢包，随机丢包而不是连续丢包对于TCP而言是有重大意义的，随机丢包会使TCP发现丢弃了个别的分段而后续的分段仍然会到达接收端，这样TCP发送端就会接收到3个冗余ACK，然后进入快速重传/快速恢复而不是慢启动。</strong></span>
这就是路由器能帮TCP做的事。
</span>
<h1><a name="t21"></a>6.其它</h1>
<span style="color: #333333;">疑难杂症22：如何学习TCP
很多人发帖问TCP相关的内容，接下来稀里哗啦的就是让看《TCP/IP详解》和《Unix网络编程》里面的特定章节，我觉得这种回答很不负责任。因为我并不认为这两本书有多大的帮助，写得确实很不错，然而可以看出Richard Stevens是一个实用主义者，他喜欢用实例来解释一切，《详解》通篇都是用tcpdump的输出来讲述的，这种方式只是适合于已经对TCP很理解的人，然而大多数的人是看不明白的。
如果想从设计的角度来说，这两本书都很烂。我觉得应该先看点入门的，比如Wiki之类的，然后看RFC文档,793，896，1122等)，这样你就明白TCP为何这么设计了，而这些你永远都不能在Richard Stevens的书中得到。最后，如果你想，那么就看一点Richard Stevens的书，最重要的还是写点代码或者敲点命令，然后抓包自己去分析。
疑难杂症23：Linux，Windows和网络编程
我觉得在Linux上写点TCP的代码是很不错的，如果有BSD那就更好了。不推荐用Winsock学习TCP。虽然微软声称自己的API都是为了让事情更简单，但实际上事情却更复杂了，如果你用Winsock学习，你就要花大量的时候去掌握一些和网络编程无关但是windows平台上却少不了的东西
</span>
<h2><a name="t22"></a>6.1.总结</h2>
<span style="color: #333333;">TCP协议是一个端到端的协议，虽然话说它是一个带流量控制，拥塞控制的协议，然而正是因为这些所谓的控制才导致了TCP变得复杂。同时这些特性是互相杂糅的，流量控制带来了很多问题，解决这些问题的方案最终又带来了新的问题，这些问题在解决的时候都只考虑了端到端的意义，但实际上TCP需要尽力而为的IP提供的网络，因此拥塞成了最终的结症，拥塞控制算法的改进也成了一个单独的领域。
在学习TCP的过程中，切忌一锅粥一盘棋的方式，一定要分清楚每一个算法到底是解决什么问题的，每一个问题和其他问题到底有什么关联，这些问题的解决方案之间有什么关联，另外TCP的发展历史也最好了解一下，这些都搞明白了，TCP协议就彻底被你掌控了。接下来你就可以学习Socket API了，然后高效的TCP程序出自你手！</span>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>154</wp:post_id>
		<wp:post_date>2012-12-24 07:38:57</wp:post_date>
		<wp:post_date_gmt>2012-12-24 07:38:57</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>tcp%e5%8d%8f%e8%ae%ae%e7%96%91%e9%9a%be%e6%9d%82%e7%97%87%e5%85%a8%e6%99%af%e8%a7%a3%e6%9e%90</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>34</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>系统调用之exit(0)&amp;_exit(0)</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=160</link>
		<pubDate>Tue, 25 Dec 2012 10:08:11 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=160</guid>
		<description></description>
		<content:encoded><![CDATA[进程就好比人一样有其生命，我们通过fork()函数来创建一个进程，那么我们又是如何来中止进程呢。

1.在Linux中任何让一个进程退出

进程退出表示进程即将结束。在Linux中进程退出分为了正常退出和异常退出两种。

1&gt;正常退出

a. 在main()函数中执行return 。

b.调用exit()函数

c.调用_exit()函数

2&gt;异常退出

a.调用abort函数

b.进程收到某个信号，而该信号使程序终止。

exit()函数的作用是：直接使用进程停止运行，清除其使用的内存空间，并清除其在内核中的各种数据结构；_exit()函数则在这一基础上做了一些包装。在执行退出之前加了若干道工序。exit()函数与_exit()函数最大区别就在于exit()函数在调用exit系统之前要检查文件的打开情况，把文件缓冲区的内容写回文件。

由于Linux的标准函数库中，有一种被称作“缓冲I/O”的 操作，其特征就是对应每一个打开的文件，在内存中都有一片缓冲区。每次读文件时，会连续的读出若干条记录，这样在下次读文件时就可以直接从内存的缓冲区读 取；同样，每次写文件的时候也仅仅是写入内存的缓冲区，等满足了一定的条件（如达到了一定数量或遇到特定字符等），再将缓冲区中的内容一次性写入文件。

printf函数就是使用缓冲I/O的方式，该函数在遇到“/n”换行符时自动的从缓冲区中将记录读出

1&gt;exit和_exit函数都是用来终止进程的。

当程序执行到exit或_exit时，系统无条件的停止剩下所有操作，清除包括PCB在内的各种数据结构，并终止本进程的运行。

2&gt;exit在头文件stdlib.h中声明，而_exit()声明在头文件unistd.h中声明。 exit中的参数exit_code为０代表进程正常终止，若为其他值表示程序执行过程中有错误发生。

3&gt;exit()和_exit()的区别：

a._exit()执行后立即返回给内核，而exit()要先执行一些清除操作，然后将控制权交给内核。

b. 调用_exit函数时，其会关闭进程所有的文件描述符，清理内存以及其他一些内核清理函数，但不会刷新流(stdin, stdout, stderr ...). exit函数是在_exit函数之上的一个封装，其会调用_exit，并在调用之前先刷新流。

如下两个简单的例子:

#include&lt;stdlib.h&gt;

#include&lt;stdio.h&gt;

int main()

{

printf("using exit----\n");

printf("this is the content in buffer\n");

exit(0);

}

输出为:using exit-----

this is the content in buffer

#include&lt;unistd.h&gt;

#include&lt;stdio.h&gt;

int main(void)

{

printf("using _exit()----\n");

printf("This is the content in buffer");

_exit(0);

}

输出:using _exit()-----

如果后一个加\n则结果一样]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>160</wp:post_id>
		<wp:post_date>2012-12-25 10:08:11</wp:post_date>
		<wp:post_date_gmt>2012-12-25 10:08:11</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e4%b9%8bexit0_exit0</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>72</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>vim</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=163</link>
		<pubDate>Tue, 25 Dec 2012 10:33:42 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=163</guid>
		<description></description>
		<content:encoded><![CDATA[I am a vimer ~~~unix/linux~~c/c++~~]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>163</wp:post_id>
		<wp:post_date>2012-12-25 10:33:42</wp:post_date>
		<wp:post_date_gmt>2012-12-25 10:33:42</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>vim</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>vimrc</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=165</link>
		<pubDate>Tue, 25 Dec 2012 10:36:16 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=165</guid>
		<description></description>
		<content:encoded><![CDATA[#个人比较喜欢常用的vimrc

set syntax=on
" 去掉输入错误的提示声音
set noeb

" 在处理未保存或只读文件的时候，弹出确认
set confirm

" 自动缩进
set autoindent
set cindent

" Tab键的宽度
set tabstop=4

" 统一缩进为4
set softtabstop=4
set shiftwidth=4

" 不要用空格代替制表符
set noexpandtab

" 在行和段开始处使用制表符
set smarttab

" 显示行号
set number

" 历史记录数
set history=1000

"禁止生成临时文件
set nobackup
set noswapfile

"搜索忽略大小写
set ignorecase

"搜索逐字符高亮
set hlsearch
set incsearch

"行内替换
set gdefault

"编码设置
set enc=utf-8
set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936

"语言设置
set langmenu=zh_CN.UTF-8
set helplang=cn

" 我的状态行显示的内容（包括文件类型和解码）
set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\"%d/%m/%y\ -\ %H:%M\")}
"set statusline=[%F]%y%r%m%*%=[Line:%l/%L,Column:%c][%p%%]

" 总是显示状态行
set laststatus=2

" 在编辑过程中，在右下角显示光标位置的状态行
set ruler          

" 命令行（在状态行下）的高度，默认为1，这里是2
set cmdheight=2

" 侦测文件类型
filetype on

" 载入文件类型插件
filetype plugin on

" 为特定文件类型载入相关缩进文件
filetype indent on

" 保存全局变量
set viminfo+=!

" 带有如下符号的单词不要被换行分割
set iskeyword+=_,$,@,%,#,-

" 字符间插入的像素行数目
set linespace=0

" 增强模式中的命令行自动完成操作
set wildmenu

" 使回格键（backspace）正常处理indent, eol, start等
set backspace=2

" 允许backspace和光标键跨越行边界
set whichwrap+=&lt;,&gt;,h,l

" 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）
set mouse=a
set selection=exclusive
set selectmode=mouse,key

" 通过使用: commands命令，告诉我们文件的哪一行被改变过
set report=0

" 启动的时候不显示那个援助索马里儿童的提示
set shortmess=atI

" 在被分割的窗口间显示空白，便于阅读
set fillchars=vert:\ ,stl:\ ,stlnc:\

" 高亮显示匹配的括号
set showmatch

" 匹配括号高亮的时间（单位是十分之一秒）
set matchtime=5

" 光标移动到buffer的顶部和底部时保持3行距离
set scrolloff=3

" 为C程序提供自动缩进
set smartindent

" 只在下列文件类型被侦测到的时候显示行号，普通文本文件不显示
if has("autocmd")
   autocmd FileType xml,html,c,cs,java,perl,shell,bash,cpp,python,vim,php,ruby set number
   autocmd FileType xml,html vmap &lt;C-o&gt; &lt;ESC&gt;'&lt;i&lt;!--&lt;ESC&gt;o&lt;ESC&gt;'&gt;o--&gt;
   autocmd FileType java,c,cpp,cs vmap &lt;C-o&gt; &lt;ESC&gt;'&lt;o/*&lt;ESC&gt;'&gt;o*/
   autocmd FileType html,text,php,vim,c,java,xml,bash,shell,perl,python setlocal textwidth=100
   autocmd Filetype html,xml,xsl source $VIMRUNTIME/plugin/closetag.vim
   autocmd BufReadPost *
      \ if line("'\"") &gt; 0 &amp;&amp; line("'\"") &lt;= line("$") |
      \   exe "normal g`\"" |
      \ endif
endif " has("autocmd")

" F5编译和运行C程序，F6编译和运行C++程序
" 请注意，下述代码在windows下使用会报错
" 需要去掉./这两个字符

" C的编译和运行
map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;
func! CompileRunGcc()
exec "w"
exec "!gcc % -o %&lt;"
exec "! ./%&lt;"
endfunc

" C++的编译和运行
map &lt;F6&gt; :call CompileRunGpp()&lt;CR&gt;
func! CompileRunGpp()
exec "w"
exec "!g++ % -o %&lt;"
exec "! ./%&lt;"
endfunc

" &lt;F7&gt; 运行python程序 
map &lt;F7&gt; :w&lt;cr&gt;:!python %&lt;cr&gt; 
 
 
" &lt;F8&gt; 运行shell程序 
map &lt;F8&gt; :call CompileRunSH()&lt;CR&gt; 
func! CompileRunSH() 
exec "w" 
exec "!chmod u+x %" 
exec "!./%" 
endfunc 
 
 
"&lt;F9&gt;  gdb调试 
map &lt;F9&gt; :call Debug()&lt;CR&gt; 
func!  Debug() 
exec "w" 
exec "!gcc % -o %&lt; -gstabs+" 
exec "!gdb %&lt;"
endfunc
 
" 能够漂亮地显示.NFO文件
set encoding=utf-8
function! SetFileEncodings(encodings)
    let b:myfileencodingsbak=&amp;fileencodings
    let &amp;fileencodings=a:encodings
endfunction
function! RestoreFileEncodings()
    let &amp;fileencodings=b:myfileencodingsbak
    unlet b:myfileencodingsbak
endfunction

au BufReadPre *.nfo call SetFileEncodings('cp437')|set ambiwidth=single
au BufReadPost *.nfo call RestoreFileEncodings()

" 高亮显示普通txt文件（需要txt.vim脚本）
au BufRead,BufNewFile *  setfiletype txt

" 用空格键来开关折叠
set foldenable
set foldmethod=manual
nnoremap &lt;space&gt; @=((foldclosed(line('.')) &lt; 0) ? 'zc' : 'zo')&lt;CR&gt;

" minibufexpl插件的一般设置
let g:miniBufExplMapWindowNavVim = 1
let g:miniBufExplMapWindowNavArrows = 1
let g:miniBufExplMapCTabSwitchBufs = 1
let g:miniBufExplModSelTarget = 1
:colorscheme evening
filetype plugin indent on
set guifont=Courier\ 12
set nocompatible
let $VIMFILES=$HOME.'/.vim'

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>165</wp:post_id>
		<wp:post_date>2012-12-25 10:36:16</wp:post_date>
		<wp:post_date_gmt>2012-12-25 10:36:16</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>vimrc</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>163</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>freebsd &amp;&amp; gentoo</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=167</link>
		<pubDate>Tue, 25 Dec 2012 11:48:11 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=167</guid>
		<description></description>
		<content:encoded><![CDATA[linux-&gt;unix-&gt;kernel--&gt;hahahaha]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>167</wp:post_id>
		<wp:post_date>2012-12-25 11:48:11</wp:post_date>
		<wp:post_date_gmt>2012-12-25 11:48:11</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>freebsd</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>二分应用</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=169</link>
		<pubDate>Thu, 27 Dec 2012 12:15:56 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=169</guid>
		<description></description>
		<content:encoded><![CDATA[//从排好序的数组中找出k出现的字数

#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;string&gt;
using namespace std;
int GetFistK(int* data,int length,int k,int start,int end)
{
  if(start &gt; end)
   return -1;
  int middleIndex = (start + end) / 2;
  int middleData = data[middleIndex];
  if(middleData == k)
  {
   if((middleIndex &gt; 0 &amp;&amp; data[middleIndex-1]!=k)||middleIndex ==0)
    return middleIndex;
   else
    end = middleIndex - 1;
  }
  else if(middleData &gt; k)
   end = middleIndex - 1;
  else
   start = middleIndex + 1;
  return GetFistK(data,length,k,start,end);
}
int GetLastK(int* data,int length,int k,int start,int end)
{
 if(start &gt; end)
  return -1;
 int middleIndex = (start + end) / 2;
 int middleData = data[middleIndex];
 if(middleData == k)
 {
  if((middleIndex &lt; length - 1 &amp;&amp; data[middleIndex + 1] != k)||middleIndex == length -1 )
   return middleIndex;
  else
   start = middleIndex + 1;
 }
 else if(middleData &lt; k)
  start = middleIndex + 1;
 else
  end = middleIndex - 1;
 return GetLastK(data,length,k,start,end);
}
int GetNumberK(int* data,int length,int k)
{
   int number = 0;
   if(data != NULL &amp;&amp; length &gt; 0)
   {
    int first = GetFistK(data,length,k,0,length - 1);
 int last = GetLastK(data,length,k,0,length - 1);

 if(first &gt; -1 &amp;&amp; last &gt; -1)
  number = last - first + 1;
   }
   return number;
}
int main()
{ 
    int data[8] = {3,3,3,3,3,3,4,5};
 int k = 4;
 int total=GetNumberK(data,8,k);
 cout&lt;&lt;total&lt;&lt;endl;
 return 0;
}]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>169</wp:post_id>
		<wp:post_date>2012-12-27 12:15:56</wp:post_date>
		<wp:post_date_gmt>2012-12-27 12:15:56</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%ba%8c%e5%88%86%e5%ba%94%e7%94%a8</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>61</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>多线程之生产者与消费者问题</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=172</link>
		<pubDate>Sun, 30 Dec 2012 06:37:37 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=172</guid>
		<description></description>
		<content:encoded><![CDATA[生产者线程向一缓冲区中写入数据~消费者线程从缓冲区中读取数据，由于生产者线程和消费者线程共享同一缓冲区，为了正确的读写数据，在使用缓冲队列时必须保持互至。生产者线程和消费者线程必须满足：生产者写入的缓冲区的数目不能超过缓冲区的容量，消费者线程读取的数目不能超过生产者写入的数目。初始化读写指针为0，如果读指针等于写指针。则缓冲区是空的~如果（写指针+1） % N 等于读指针，则缓冲区是满的

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;sys/wait.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;unistd.h&gt;
#include&lt;pthread.h&gt;
#include&lt;time.h&gt;
#include&lt;math.h&gt;
#define BUFFER_SIZE 8

struct prodcons {
int buffer[BUFFER_SIZE];
pthread_mutex_t lock;
int readpos,writepos;
pthread_cond_t notempty;
pthread_cond_t notfull;
};

void init(struct prodcons *b)
{
pthread_mutex_init(&amp;b-&gt;lock,NULL);
pthread_cond_init(&amp;b-&gt;notempty,NULL);
pthread_cond_init(&amp;b-&gt;notfull,NULL);
b-&gt;readpos = 0 ;
b-&gt;writepos = 0 ;
}

void put(struct prodcons *b,int data)
{
pthread_mutex_lock(&amp;b-&gt;lock);
if((b-&gt;writepos + 1)%BUFFER_SIZE == b-&gt;readpos)
{
pthread_cond_wait(&amp;b-&gt;notfull,&amp;b-&gt;lock);
}
b-&gt;buffer[b-&gt;writepos] = data;
b-&gt;writepos++;
if(b-&gt;writepos &gt;= BUFFER_SIZE)
b-&gt;writepos = 0;
pthread_cond_signal(&amp;b-&gt;notempty);
pthread_mutex_unlock(&amp;b-&gt;lock);
}

int get(struct prodcons *b)
{
int data;
pthread_mutex_lock(&amp;b-&gt;lock);
if(b-&gt;writepos == b-&gt;readpos)
{
pthread_cond_wait(&amp;b-&gt;notempty,&amp;b-&gt;lock);
}
data = b-&gt;buffer[b-&gt;readpos];
b-&gt;readpos++;

if(b-&gt;readpos &gt;= BUFFER_SIZE)
b-&gt;readpos = 0;

pthread_cond_signal(&amp;b-&gt;notfull);
pthread_mutex_unlock(&amp;b-&gt;lock);
return data;
}
#define OVER (-1)
struct prodcons buffer;
void *producer(void *data)
{
int n;
for(n = 0 ; n &lt; 50 ; n++)
{
printf("%d\t",n);
put(&amp;buffer,n);
}
put(&amp;buffer,OVER);
return NULL;
}
void *consumer(void *data)
{
int d;
while(1)
{
d = get(&amp;buffer);
if(d == OVER)
break;
printf("%d\t",d);
}
return NULL;
}
int main(void)
{
pthread_t th_a,th_b;
void *retval;
init(&amp;buffer);
pthread_create(&amp;th_a,NULL,producer,0);
pthread_create(&amp;th_b,NULL,consumer,0);
pthread_join(th_a,&amp;retval);
pthread_join(th_b,&amp;retval);
printf("\n");
return 0;
}]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>172</wp:post_id>
		<wp:post_date>2012-12-30 06:37:37</wp:post_date>
		<wp:post_date_gmt>2012-12-30 06:37:37</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%a4%9a%e7%ba%bf%e7%a8%8b%e4%b9%8b%e7%94%9f%e4%ba%a7%e8%80%85%e4%b8%8e%e6%b6%88%e8%b4%b9%e8%80%85%e9%97%ae%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>72</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>unix socket server &amp; client</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=174</link>
		<pubDate>Sun, 30 Dec 2012 12:11:38 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=174</guid>
		<description></description>
		<content:encoded><![CDATA[socket()函数创建一个socket,然后调用bind()函数将其与本机的地址以及一个本地端口绑定~然后利用listen()在相应的socket上监听，当accept()接收到一个连接的服务请求时，服务器将显示客户机的ip地址,并通过新的socket向客户端发送字符串"Hello,you are connected!"最后关闭socket

myserver.c:

/*
 *socket server
 * */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;errno.h&gt;
#include&lt;unistd.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;sys/wait.h&gt;
#define SERVERPORT 3333
#define BACKLOG 10
int main()
{
    int sockfd,clientfd;
    struct sockaddr_in my_addr;
    struct sockaddr_in remote_addr;
    if((sockfd = socket(AF_INET , SOCK_STREAM ,0))== -1){
    perror("socket create error !!!");
    exit(1);
    }
    my_addr.sin_family = AF_INET;
    my_addr.sin_port = htons(SERVERPORT);
    my_addr.sin_addr.s_addr = INADDR_ANY;
    bzero(&amp;(my_addr.sin_zero),8);
    if(bind(sockfd,(struct sockaddr *)&amp;my_addr,sizeof(struct sockaddr)) == -1){
     perror("bind error....");
     exit(1);
    }
    if(listen(sockfd,BACKLOG) == -1)
    {
     perror("listen error ..");
     exit(1);
    }
    while(1){
     int sin_size = sizeof(struct sockaddr_in);
     if((clientfd = accept(sockfd,(struct sockaddr *)&amp;remote_addr,&amp;sin_size))==-1){
     perror("accept error...");
     continue;
     }
     printf("Receied a connection from %s\n",inet_ntoa(remote_addr.sin_addr));
     if(!fork()){
      if(send(clientfd,"Hello,you are connected!\n",26,0) == -1)
      perror("send error...");
      close(clientfd);
      exit(0);
     }
     close(clientfd);
    }
}

客户端通过服务器域名获得服务器的ip,然后新建一个socket调用connect与服务器连接，连接成功后接收从服务器发送过来的数据，最后关闭socket

gethostbyname()是完成域名转换的 struct hostent *gethostbyname(const char *name)

myclient.c:

/*
 *socket client
 * */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;unistd.h&gt;
#include&lt;errno.h&gt;
#include&lt;netdb.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/wait.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;
#define SERVERPORT 3333
#define MAXDATASIZE 100
int main(int argc,char *argv[])
{
  int sockfd,recvbytes;
  char buf[MAXDATASIZE];
  struct hostent *host;
  struct sockaddr_in serv_addr;
  if(argc &lt; 2)
  {
   fprintf(stderr,"Please enter the server'hostname!\n");
   exit(1);
  }
  if((host= gethostbyname(argv[1])) == NULL){
   perror("gethostbyname error...");
   exit(1);
  }
  if((sockfd=socket(AF_INET,SOCK_STREAM ,0)) == -1)
  {
   perror("socket error...");
   exit(1);
  }
  serv_addr.sin_family = AF_INET ;
  serv_addr.sin_port = htons(SERVERPORT);
  serv_addr.sin_addr = *((struct in_addr *)host-&gt;h_addr);
  bzero(&amp;(serv_addr.sin_zero),8);
  if(connect(sockfd,(struct sockaddr *)&amp;serv_addr,sizeof(struct sockaddr)) == -1)
  {
  perror("connext error...");
  exit(1);
  }
  if((recvbytes=recv(sockfd,buf,MAXDATASIZE,0)) == -1)
  {
   perror("recv error ....");
   exit(1);
  }
  buf[recvbytes]='\0';
  printf("REceived:%s \n",buf);
  close(sockfd);
}]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>174</wp:post_id>
		<wp:post_date>2012-12-30 12:11:38</wp:post_date>
		<wp:post_date_gmt>2012-12-30 12:11:38</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>unix-socket-server-client</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>167</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>ubuntu livecd ~</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=176</link>
		<pubDate>Wed, 02 Jan 2013 07:13:07 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=176</guid>
		<description></description>
		<content:encoded><![CDATA[将现有的ubuntu系统打造成LiveCD ~下载Live Ubuntu Backup V2.2 (lub)

将所有环境装好后分别执行: 将lub放到家目录

1.sudo chmod 777 /home/lub

2.sudo /home/lub -b

然后按e或c来选择是英文提示，还是中文提示。第一次执行时，可能会提示需要安装lupin-casper和squashfs-tools，其中 lupin-casper可以忽略，而squashfs-tools必须安装，运行$sudo apt-get install squashfs-tools即可

之后再次运行$sudo /home/lub -b，依提示运行，就能在用户文件夹下生成一个backup-2013.01.02的目录了，其中有的backup-2013.01.02.squashfs文件就是我们想要的

3.将ubuntu-11.10-desktop.i386.iso拷贝到/home.acmer/下:

执行:sudo /home/acmer/mnt &amp;&amp; sudo mount -o loop /home/acmer/Ubuntu-11.10-desktop-i386.iso /home/acmer/mnt

4.sudo mkdir /home/acmer/livecd 将/home/acmer/mnt下的内容除了casper/filesystem.squashfs，同步到了/home/acmer/livecd目录下。

执行: $sudo rsync --exclude=/home/acmer/acmer/casper/filesystem.squashfs -a /home/acmer/mnt/ /home/acmer/livecd 

5.对/home/acmer/livecd/casper/目录下的filesystem.squashfs、 filesystem.manifest、filesystem.manifest-desktop这三个文件进行操作，由于它们只有读权限，所以先执行$sudo chmod o+w /home/acmer/livecd/casper/filesystem.*

将刚才lub生成的那个backup-2013.01.02.squashfs文件，拷贝成/home/acmer/livecd/casper/filesystem.squashfs

执行： $sudo cp /home/acmer/backup-2013.01.02/backup2013.01.02.squashfs /home/acmer/livecd/casper/filesystem.squashfs

6.

此外，还要更新/home/acmer/livecd/casper/目录下的filesystem.manifest和filesystem.manifest-remove，这两个文件实际上是系统所装包的列表，通过以下方式更新

$sudo dpkg -l | grep ii | awk '{print $2,$3}' &gt;/home/acmer/livecd/casper/filesystem.manifest

$sudo dpkg -l | grep ii | awk {print$2,$3}'&gt; /home/acmer/livecd/casper/filesystem.manifes-remove

7.

退回的LiveCD的工作目录 /home/acmer/livecd 下，

执行$sudo rm md5sum.txt

再执行$find -type f -print0 | sudo xargs -0 md5sum | grep -v ./isolinux/ | grep -v ./md5sum.txt | sudo tee md5sum.txt

更新原来的md5sum

8.

将工作目录下的内容打包成ISO

先运行$sudo apt-get install mkisofs 安装ISO打包工具，

执行$sudo mkisofs -D -r -V "mdk-linux" -cache-inodes -J -l -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -o ../cjlu-acmer.iso .

打包iso时最后一定加 . 来表示目前目录

参照文章来源（有删节）:<a href="http://www.linuxidc.com/Linux/2011-04/34097.htm">http://www.linuxidc.com/Linux/2011-04/34097.htm</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>176</wp:post_id>
		<wp:post_date>2013-01-02 07:13:07</wp:post_date>
		<wp:post_date_gmt>2013-01-02 07:13:07</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>ubuntu-livecd</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>8</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>内存动态分区管理</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=179</link>
		<pubDate>Wed, 02 Jan 2013 07:25:07 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=179</guid>
		<description></description>
		<content:encoded><![CDATA[1.分别使用首次适应算法,最佳适应算法分配内存空间

2.实现对内存空间的释放

3.显示内存分配情况

/*
* =====================================================================================
*
*       Filename:  memblockman.c
*
*    Description:  memory control
*
*        Version:  1.0
*        Created:  2012骞?2鏈?1鏃?14鏃?1鍒?4绉?
*       Revision:  none
*       Compiler:  gcc
*
*         Author:  ACman mdk (Orz Linux Sir Koma linyu zhujiajun), <a href="mailto:mdk@server.example.com">mdk@server.example.com</a>
*        Company:  ACM 309 JudgeOnline
*
* =====================================================================================
*/
/*杩涘叆绋嬪簭鍚庡彲浠ユ牴鎹彍鍗曢」杩涘叆涓嶅悓鐨勬ā鍧?/
/*1.浣跨敤棣栨閫傚簲绠楁硶鍒嗛厤绌洪棿            */
/*2.浣跨敤鏈€浣抽€傚簲绠楁硶鍒嗛厤绌洪棿            */
/*3.閲婃斁涓€鍧楀唴瀛樼┖闂?                   */
/*4.鏄剧ず鍐呭瓨鍒嗛厤鎯呭喌                    */
/*5.閫€鍑虹郴缁?                           */
/*--------------------------------------*/
#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;sys/wait.h&gt;
#include&lt;sys/types.h&gt;
#define MEMSIZE 100  /*瀹氫箟鍐呭瓨澶у皬涓?00*/
#define MINSIZE 2   /*鍒嗛厤鏃跺鏋滃墿浣欏皬浜庢鍊煎垯涓嶅啀鍒嗛厤*/
typedef struct MemoryInformation{
int start; /*寮€濮嬬殑鍦板潃*/
int size; /*澶у皬*/
char info; /*鐘舵€?f绌洪棽(FREE):'u'鍗犵敤(USED):'e'琛ㄧ粨鏉?END)*/
}MEMINFO;
MEMINFO MemList[MEMSIZE];
void Display();
/*-----------------------*/
/*鍑芥暟鍚嶏細InitAll()      */
/*鍔熻兘:鍒濆鍖栨墍鏈夊彉閲?   */
/*-----------------------*/
void InitAll()
{
int i;
MEMINFO temp={0,0,'e'};
for(i=0;i&lt;MEMSIZE;i++)
MemList[i]=temp;
MemList[0].start = 0;
MemList[0].size = MEMSIZE;
MemList[0].info = 'f';
}
/*--------------------------------*/
/*鍑芥暟鍚?FirstFit_new()          */
/*鍔熻兘锛氫娇鐢ㄩ娆￠€傚簲绠楁硶鍒嗛厤鍐呭瓨*/
/*------------------------------*/
void FirstFit_new()
{
int i,j,size;
char temp[10];
printf("How MAny MEMORY do you require?");
scanf("%d",&amp;size);
for(i=0;i &lt; MEMSIZE -1 &amp;&amp; MemList[i].info!='e';i++){
if(MemList[i].size &gt;= size &amp;&amp; MemList[i].info=='f'){
if(MemList[i].size - size &lt;= MINSIZE)
MemList[i].info='u';
else{
for(j=MEMSIZE - 2;j &gt; i;j--){
MemList[j+1] = MemList[j];
}
MemList[i+1].start = MemList[i].start + size;
MemList[i+1].size = MemList[i].size - size;
MemList[i+1].info = 'f';
MemList[i].size = size;
MemList[i].info = 'u';
}
break;
}
}
if(i == MEMSIZE - 1 || MemList[i].info == 'e'){
printf("NOT Enough Memory!\n");
getchar();
}
Display();
}
/*------------------------------*/
/*鍑芥暟鍚嶏細BestFit_new()         */
/*鍔熻兘锛氫娇鐢ㄦ渶浣抽€傚簲绠楁硶鍒嗛厤鍐呭瓨*/
/*------------------------------*/
void BestFit_new()
{
int i,j,k,flag,size;
char temp[10];
printf("How Many MEMORY require?");
scanf("%d",&amp;size);
j = 0;
flag = 0;
k = MEMSIZE;
for(i=0;i&lt;MEMSIZE - 1 &amp;&amp; MemList[i].info!='e';i++){
if(MemList[i].size &gt;= size &amp;&amp; MemList[i].info == 'f'){
flag = 1;
if(MemList[i].size &lt; k){
k = MemList[i].size;
j = i;
}
}
}
i=j;
if(flag == 0)
{
printf("NOT ENOUGH Memory!\n");
getchar();
}
else if(MemList[i].size - size &lt;= MINSIZE)
MemList[i].info = 'u';
else{
for(j=MEMSIZE-2;j &gt; i;j--){
MemList[j+1]=MemList[j];
}
MemList[i].start = MemList[i].start + size;
MemList[i].size = MemList[i].size - size;
MemList[i].info = 'f';
MemList[i].size = size;
MemList[i].info = 'u';
}
Display();
}
/*------------------------*/
/*鍑芥暟鍚嶏細del()          */
/*鍔熻兘:閲婃斁涓€鍧楀唴瀛?     */
/*-----------------------*/
void del()
{
int i,number;
printf("please input the NUMBER you want to delete:");
scanf("%d",&amp;number);
if(MemList[number].info == 'u'){
MemList[number].info = 'f';
if(MemList[number+1].info=='f'){
MemList[number].size += MemList[number+1].size;
for(i=number+1;i&lt;MEMSIZE - 1 &amp;&amp; MemList[i].info!='e';i++)
MemList[i]=MemList[i+1];
}
if(MemList[number - 1].info != 'f'){
MemList[number -1].size += MemList[number].size;
for(i=number;i&lt;MEMSIZE - 1 &amp;&amp; MemList[i].info!='e';i++)
MemList[i]=MemList[i+1];
}
}
else{
printf("This number is NOT exits or is NOT sued!\n");
getchar();
}
Display();
}
/*---------------------------*/
/*鍑芥暟鍚?Display()           */
/*鍔熻兘:鏄剧ず鍐呭瓨鐘舵€?         */
/*---------------------------*/
void Display()
{
int i,used = 0;
printf("\n------------------------------------------\n");
printf("%5s %15s %15s","Number","Start","Size","info");
printf("\n------------------------------------------\n");
for(i=0;i&lt;MEMSIZE &amp;&amp; MemList[i].info != 'e';i++){
if(MemList[i].info == 'u')
used+= MemList[i].size;
printf("%5d %15d %15d %15s\n",i,MemList[i].start,MemList[i].size,MemList[i].info == 'u'?"USED":"FREE");
}
printf("\n------------------------------------------\n");
printf("TotalSize : %-10d Used: %-10d Free:%-10d\n",MEMSIZE,used,MEMSIZE - used);
printf("\n\nPress Any Key to Return\n");
getchar();
}
/*----------------*/
/*鍑芥暟鍚?main()   */
/*鍔熻兘:涓诲嚱鏁?    */
/*----------------*/
int main()
{
char ch;
InitAll();
while(1)
{
printf("   Memory manager  \n");
printf("================================================\n");
printf("1. Get a block use the FIRSTFIT method\n");
printf("2. Get a block use the BESTFFIT method\n");
printf("3. Free or delete a block\n");
printf("4. Display Mem information\n");
printf("5. Exit\n");
printf("================================================\n");
ch = getchar();
switch(ch){
case '1':
FirstFit_new();
break;
case '2':
BestFit_new();
break;
case '3':
del();
break;
case '4':
Display();
break;
case '5':
exit(0);
}
}
}]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>179</wp:post_id>
		<wp:post_date>2013-01-02 07:25:07</wp:post_date>
		<wp:post_date_gmt>2013-01-02 07:25:07</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%86%85%e5%ad%98%e5%8a%a8%e6%80%81%e5%88%86%e5%8c%ba%e7%ae%a1%e7%90%86</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>72</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>新交通规则</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=181</link>
		<pubDate>Fri, 04 Jan 2013 07:30:42 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=181</guid>
		<description></description>
		<content:encoded><![CDATA[/*
 * =====================================================================================
 *
 *       Filename:  1314.cpp
 *
 *    Description:  new rules 
 *
 *        Version:  1.0
 *        Created:  2013/1/4 15:23:06
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  mdk-vim.cpp-c (mdk), <a href="mailto:mengdaikun@gmail.com">mengdaikun@gmail.com</a>
 *        Company:  cjluacm-vim-mdk
 *
 * =====================================================================================
 */
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    //before
    if(light == "green"){
      run();
    }else if(light == "red"){
      stop();
    }else if(light == "yellow"){
      holdOn();
    }

    //now
    if(light == "green"){
      run();
    }else if(light == "red"){
      stop();
    }else if(light == "yellow"){
      stop();
    }
    return 0;
}

&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>181</wp:post_id>
		<wp:post_date>2013-01-04 07:30:42</wp:post_date>
		<wp:post_date_gmt>2013-01-04 07:30:42</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%96%b0%e4%ba%a4%e9%80%9a%e8%a7%84%e5%88%99</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>167</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>acm的触动~</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=184</link>
		<pubDate>Sat, 12 Jan 2013 12:14:21 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=184</guid>
		<description></description>
		<content:encoded><![CDATA[致我热衷的acm:

我真的希望
大家加油！！！
不是因为别的原因，因为我们都曾经迷惑，无助，我们没有别人那么强的教练，没有别人那么好的基础，但是，我们都绝对不能放弃。绝对不能，因为，当我们坐在赛场上的时候，不管你是不是愿意，在你上空飘动的始终是你的校旗，别误会，我不是说什么要“为了学校争光”，那种话是用来哄小孩子的。我只想问大家，如果是你，坐在电脑前~~，你的背后有多少人在看着你？你的身上寄托的是什么？
是希望，是所有喜欢ACM的同学对你的希望，希望有这么一天，ACM也可以象其他的东西一样被其他的人所肯定，而不是什么需要被人怜悯的东西！！！！！！！！！

如果，现在我们寄托了这些东西的话，谁还会告诉我：我们不该奋斗呢？
如果可以，我宁愿安静的呆在一个不为人知的小角落，平平淡淡的过了这大学四年的生活，至少不会这么累。
如果可以，我宁愿在开始的时候，就找一个可以依靠的地方，傻傻的什么都不想，幸福的过了这四年。
如果可以，我宁愿只做一个ACM的看客，静静的品味他们成功的喜悦，分担失败的痛苦。
如果可以，我宁愿早早的放弃着艰苦的训练，因为我实在不愿意再做这样一个噩梦。
如果、可以…………
但是，只是如果……
而且，决不可以！！
当我们弱校的人喜欢上ACM的时候，就应该有这种觉悟！
如果，要后退，那么，就你就不要参加ACM，因为，你不适合。ACM比的并不仅仅是写程序的水平，而更多是三个人的综合素质。没有胆小的人可以赢得ACM的青睐，没有退缩的人可以赢得比赛的胜利。我们这些人，水平本来就有限，也没有什么很出色专业教练。那么如果我们连一拼的勇气都没有了。我们还剩下什么？
如果可以，让我再次站在大一时候的海报前，我还是会小声的说：“去试试吧，也许很好玩呢~~”
谢谢大家看了这么多，是不是烦了？呵呵，最后，我只希望大家能+U，同时弱校的队员，
我希望我们能互相帮助。
大家~~~~~~~~加油~~~~~~~~~]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>184</wp:post_id>
		<wp:post_date>2013-01-12 12:14:21</wp:post_date>
		<wp:post_date_gmt>2013-01-12 12:14:21</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>acm%e7%9a%84%e8%a7%a6%e5%8a%a8</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>61</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>计量OJ简史</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=186</link>
		<pubDate>Sat, 12 Jan 2013 12:19:53 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=186</guid>
		<description></description>
		<content:encoded><![CDATA[&nbsp;

/*
 * =====================================================================================
 *
 *       Filename:  oj.cpp
 *
 *    Description:  计量oj简史2
 *
 *        Version:  1.0
 *        Created:  2013/1/12 19:46:55
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  mdk-vim.cpp-c (mdk), <a href="mailto:mdk@server.example.com">mdk@server.example.com</a>
 *        Company:  cjluacm-vim-mdk
 *
 * =====================================================================================
 */
#pragma warning(disable:一切阻力)

#include &lt; 院领导 &gt;

#include &lt; 尤天师 &gt;

#include &lt; 308 全体成员 &gt;

using 一台很老的 DELL 台式机 std;

#define              OJ史前时代      ( 以UVA转载题为主 );

#define              OJ目前大事      ( 稳步发展月赛 );

#define              ACM基地记事     ( 出题解题做题 );

int main()

{

            time        = 2009 / 7 /28;

            place       = hdu 信息楼一楼;

            action      = *****ACM研讨交流会;

            person      = 院领导 + 尤天师 + 308 全体成员 + 部分08级同学;

            harvest     = " 领导一定支持 ~~! " + 水果若干;

            time        = 2009 / 9 / 12;

            action      = 尤天师提交月赛申请书;

            time       += 3;

            action      = 月赛审核通过;

            for(   time = 2009 / 9 / 28; time != 2009 / 10 / 5; ++time )

            {

                 action = OJ construting;

            }

            time        = 9 / 10 / 2009;

            action      = OJ 在后院论坛开辟子版块;               

            time        = 21 / 11 / 2009;

            action      = 招新赛完毕;

            time        = 1 / 12 / 2009;

            action      = 新人入住完毕;

            time        = 5/ 01/ 2010;

            action      = 月赛进入全校范围;

            while ( time++ != 2011 / 7 )

            {

                      action = OJ updating;

            }
           
            /*
             *未获得前辈们的认可就将OJ转换
             *在此向前辈们致歉
             * 我们的宗旨是将OJ打造成造福于全校搞IT的学生
             * */
           
            time        =  5 / 6 / 2012

            action      =  平台转换 windows-&gt;linux 内核开源
           
            time        =  25 / 6 / 2012
           
            action      =  web 端修改完毕 数据无损伤导入 新oj 新特性

            time        =  * / 7 / 2012

            action      =  投入使用(期间省赛被挫三人组组织两场比赛)

            time        = 28 / 10 / 2012

            action      = 域名重新对外(acm.cjlu.edu.cn)

            while ( time ++ != 2014 / 7 )
            
            {
                  
                   action1 = OJ updating
                  
                   action2 = CODE2AC()

            }

            return 0;

}]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>186</wp:post_id>
		<wp:post_date>2013-01-12 12:19:53</wp:post_date>
		<wp:post_date_gmt>2013-01-12 12:19:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e8%ae%a1%e9%87%8foj%e7%ae%80%e5%8f%b2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>61</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>as a coder </title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=189</link>
		<pubDate>Sun, 13 Jan 2013 09:29:07 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=189</guid>
		<description></description>
		<content:encoded><![CDATA[无论是选择学习C/C++还是Java，没有区别，仅仅是个语法规范而已，最难的是如何用这个语法规范，开发出具有灵魂的程序，大型的软件

或者说c/c++ 的开发效率比java高很多~~但这都不是问题~算法和数据结构才是内功和基本功~acm 真的是个好东西啊~~~]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>189</wp:post_id>
		<wp:post_date>2013-01-13 09:29:07</wp:post_date>
		<wp:post_date_gmt>2013-01-13 09:29:07</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>as-a-coder</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>53</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>程序媛</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=191</link>
		<pubDate>Mon, 14 Jan 2013 09:37:03 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=191</guid>
		<description></description>
		<content:encoded><![CDATA[说某学校有位大神，期末总挂科，没挂的科也是在及格线上徘徊。他一直跟他妈说他学习挺好啥的，有一次他妈要上教务处网站看他成绩，这位大神竟然自己做了个教务处的网站给他妈糊弄过去不说，他妈还因为他成绩好奖励他五百块钱！……ps:未来网站程序员（转）]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>191</wp:post_id>
		<wp:post_date>2013-01-14 09:37:03</wp:post_date>
		<wp:post_date_gmt>2013-01-14 09:37:03</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%a8%8b%e5%ba%8f%e5%aa%9b</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>63</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>版本控制之道svn 使用心得加笔记</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=194</link>
		<pubDate>Mon, 21 Jan 2013 18:35:16 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=194</guid>
		<description></description>
		<content:encoded><![CDATA[使用开源OJ后~~由于开源~内核也开源~~给了我们很大的改造空间~~由此搭建起subversion版本控制~subversion的安装略（可yum 或apt-get 安装或者源码安装）~安装成功后使用命令 svn --version 即可显示安装版本信息

本人使用是svnserve 建立版本库~基于apaches的有空再弄~

1. 建立版本目录:

svnadmin create --fs-type fsfs /usr/local/OJ

执行后在/usr/local/OJ/目录下生成一堆配置文件~主要文件还是conf/下的svnserve.conf文件，里面有关配置用户和匿名用户对版本库的使用权限设置 anon-access 和autho-access ,write对应的用户读写都可~read只可读

2.刚建立的版本库没有项目需引入项目(在本地引入用file://)

svn import hustoj2mdk file:///usr/local/OJ/project-oj -m "Initial import"

即可将hustoj2mdk目录的内容引入到版本库的project-oj目录

3.开启svnserve

svnserve -d -r /usr/local/OJ

-d 以独立进程的方式开启 -r 便于svn 访问省略/usr/local/OJ  只用project-oj即可

ps aux|grep svn 即可查看到svnserve

到此一个的版本库的项目引入以完成~即可用 svn list/checkout等命令 svn://URL 取出版本库的相关项目(后期补上基于apche的svn)

---by mdk-vimer]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>194</wp:post_id>
		<wp:post_date>2013-01-21 18:35:16</wp:post_date>
		<wp:post_date_gmt>2013-01-21 18:35:16</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e4%b9%8b%e9%81%93svn-%e4%bd%bf%e7%94%a8%e5%bf%83%e5%be%97%e5%8a%a0%e7%ac%94%e8%ae%b0</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>34</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>gentoo 最小化安装</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=199</link>
		<pubDate>Sat, 26 Jan 2013 12:56:05 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=199</guid>
		<description></description>
		<content:encoded><![CDATA[转载自有删减http://www.gentoo.org/doc/zh_cn/gentoo-x86-quickinstall.xml
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 1.1: 测试机器的规格</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>（下述配置和耗时情况帮你粗略估计完成整个安装过程大概需要的时间）

# grep bogo /proc/cpuinfo
bogomips       : 3337.81

# hdparm -tT /dev/sda
/dev/sda:
 Timing cached reads:   1100 MB in  2.00 seconds = 549.97 MB/sec
 Timing buffered disk reads:  224 MB in  3.01 seconds =  74.36 MB/sec

# grep MemTotal /proc/meminfo
MemTotal:       509248 kB</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2"></a>2.  快速安装指南

<a name="doc_chap2_sect1"></a>安装介质

从我们的<a href="http://www.gentoo.org/main/en/mirrors.xml">镜像</a>下载一张光盘。可以在releases/x86/current-iso/中找到最小光盘的ISO文件。最小安装光盘只适用于有网络环境的安装。本指南将使用最小光盘。

<a href="http://www.gentoo.org/doc/zh_cn/faq.xml#isoburning">刻制</a>光盘，用它引导机器。

<a name="doc_chap2_sect2"></a>从光盘启动

启动时按下F2查看有哪些引导选项。你可以启动gentoo或者gentoo-nofb，后者禁用帧缓冲。如果你用LiveCD引导，别忘了添上nox选项以防止启动X图形环境。有好几个选项可用于启用或禁用一些特性。正常情况下会检测出你的硬件并装载所有模块。如果内核无法正确引导或是在引导过程中挂机，你可能不得不尝试不同的配置。最安全的办法大概是使用nodetect选项，然后显式地载入需要的模块。

<a name="doc_chap2_pre1"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.1: 引导最小光盘</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>Gentoo Linux Installation LiveCD                     http://www.gentoo.org
Enter to Boot; F1 for kernels  F2 for options.
boot: gentoo-nofb
（或在有问题的情况下）
boot: gentoo-nofb nodetect</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_sect3"></a>可选：装载模块

如果使用了nodetect选项，就要在启动后载入必要的模块。你还要配置好网络并拥有访问磁盘的权限。lspci命令能帮助你确认硬件信息。

<a name="doc_chap2_pre2"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.2: 载入必要的模块</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd root # lspci
（根据lspci的输出查看需要哪些模块）

（以下只是个例子，实际以具体硬件为准）
livecd root # modprobe 3w-9xxx
livecd root # modprobe r8169</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_sect4"></a>网络配置

如果还没开启网络，可以用net-setup来配置网络。配置之前可能要先用modprobe为网卡载入支持模块。如果你有ADSL，请使用pppoe-setup和pppoe-start。要支持PPTP，首先编辑/etc/ppp/chap-secrets和/etc/ppp/options.pptp，然后使用pptp &lt;server ip&gt;。

如果是无线连接，用iwconfig设置无线连接参数，然后再次执行net-setup或者手动运行ifconfig、dhcpcd和/或route。

如果你用代理，不要忘了使用export http_proxy、ftp_proxy和RSYNC_PROXY初始化系统环境。

<a name="doc_chap2_pre3"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.3: 通过向导配置网络</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd root # net-setup eth0</pre>
</td>
</tr>
</tbody>
</table>
或者，你也可以手动打开网络。下面的例子把你电脑的IP地址配置为192.168.1.10，并把网关和域名服务器设为192.168.1.1。

<a name="doc_chap2_pre4"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.4: 手动配置网络</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd root # ifconfig eth0 192.168.1.10/24
livecd root # route add default gw 192.168.1.1
livecd root # echo nameserver 192.168.1.1 &gt; /etc/resolv.conf</pre>
</td>
</tr>
</tbody>
</table>
安装盘允许你启动一个sshd服务，添加用户，运行irssi（一个命令行的客户端聊天工具），还可以使用links进行网上冲浪。

<a name="doc_chap2_sect5"></a>可选：通过ssh连接到你的新机器

最有趣的功能当然是sshd。启动这个服务，从另一台机器连过来，然后从本指南复制/粘贴命令。

<a name="doc_chap2_pre5"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.5: 启动sshd</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd root # time /etc/init.d/sshd start
 * Generating hostkey ...
（sshd生成密钥并显示更多输出）
 * starting sshd ...                            [ok]

real   0m13.688s
user   0m9.420s
sys    0m0.090s</pre>
</td>
</tr>
</tbody>
</table>
现在设置一下安装盘的root密码，使你能通过另一台电脑连接。请注意正常情况下不推荐你允许root通过ssh连接。如果你的本地网络不太可靠，请设一个又长又复杂的密码。它只能使用一次，因为机器重启后就没掉了。

<a name="doc_chap2_pre6"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.6: 设置root密码</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd root # passwd
New UNIX password: 输入密码
Retype new UNIX password: 输入密码
passwd: password updated successfully</pre>
</td>
</tr>
</tbody>
</table>
现在就可以在另一台电脑上打开一个终端并连接到你的新机器，在新的窗口中继续本指南接下去的内容，复制/粘贴文中的命令。

<a name="doc_chap2_pre7"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.7: 从另一台电脑连到你的新机器</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>（使用你新机器的IP地址）
$ ssh root@192.168.1.10
The authenticity of host '192.168.1.10 (192.168.1.10)' can't be established.
RSA key fingerprint is 96:e7:2d:12:ac:9c:b0:94:90:9f:40:89:b0:45:26:8f.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.1.10' (RSA) to the list of known hosts.
Password: 输入密码</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_sect6"></a>准备磁盘

使用fdisk或者cfdisk创建分区规划。至少需要一个交换分区（类别为82）和一个Linux分区（类别为83）。下面是我们的手册选用的方案，创建包括一个/boot分区，一个交换分区和一个主分区。将/dev/sda替换为你自己的磁盘。大多数系统忽略启动标志，但有的系统需要它。使用fdisk的a命令在启动分区上设置这个标志。

<a name="doc_chap2_pre8"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.8: 创建分区</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd ~ # fdisk /dev/sda

（本手册接下去使用以下分区规划）
livecd ~ # fdisk -l /dev/sda

Disk /dev/sda: 599.9 GB, 599978409984 bytes
255 heads, 63 sectors/track, 72943 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          12       96358+  83  Linux
/dev/sda2              13         110      787185   82  Linux swap / Solaris
/dev/sda3             111       72943   585031072+  83  Linux</pre>
</td>
</tr>
</tbody>
</table>
使用mke2fs，mke2fs -j，mkreiserfs，mkfs.xfs和mkfs.jfs建立Linux分区的文件系统。使用mkswap和swapon初始化交换分区。

<a name="doc_chap2_pre9"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.9: 创建文件系统并激活交换分区</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>（ext2完全满足/boot分区的需要）
livecd ~ # mke2fs /dev/sda1

（主分区就用ext3吧）
livecd ~ # mke2fs -j /dev/sda3

（创建并激活交换分区）
livecd ~ # mkswap /dev/sda2 &amp;&amp; swapon /dev/sda2</pre>
</td>
</tr>
</tbody>
</table>
把新建的文件系统挂载到/mnt/gentoo。如果需要其他挂载点（如/mnt/gentoo/boot），也要为它们创建目录并挂载好。

<a name="doc_chap2_pre10"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.10: 挂载文件系统</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd ~ # mount /dev/sda3 /mnt/gentoo
livecd ~ # mkdir /mnt/gentoo/boot
livecd ~ # mount /dev/sda1 /mnt/gentoo/boot
livecd ~ # cd /mnt/gentoo</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_sect7"></a>安装Stage

首先确保正确设置了日期和时间。执行date MMDDhhmmYYYY，使用UTC时间。

<a name="doc_chap2_pre11"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.11: 设定日期和UTC时间</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>（查看时钟）
livecd gentoo # date
Mon Mar  6 00:14:13 UTC 2006

（设置当前日期和时间，如果需要的话）
livecd gentoo # date 030600162006 （格式为MMDDhhmmYYYY）
Mon Mar  6 00:16:00 UTC 2006</pre>
</td>
</tr>
</tbody>
</table>
接下来，从我们的<a href="http://www.gentoo.org/main/en/mirrors.xml">镜像</a>下载一份stage包：

<a name="doc_chap2_pre12"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.12: 下载一份stage3压缩包</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd gentoo # links http://www.gentoo.org/main/en/mirrors.xml
（选一个镜像，进入releases/x86/current-stage3/目录，高亮显示你需要的stage3包，
即i686 stage3，按下D键下载）</pre>
</td>
</tr>
</tbody>
</table>
进入/mnt/gentoo，执行tar xjpf &lt;stage3 tarball&gt;解压stage包。

<a name="doc_chap2_pre13"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.13: 解开stage3压缩包</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd gentoo # time tar xjpf stage3*

real  1m14.157s
user  1m2.920s
sys   0m7.530s</pre>
</td>
</tr>
</tbody>
</table>
安装最新的Portage快照。跟下载stage3压缩包一样：从我们的<a href="http://www.gentoo.org/main/en/mirrors.xml">列表</a>选择一个最近的镜像，下载最新的快照并解压。

<a name="doc_chap2_pre14"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.14: 下载最新的Portage快照</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre> 
livecd gentoo # cd /mnt/gentoo/usr
livecd usr # wget http://distfiles.gentoo.org/snapshots/portage-latest.tar.bz2</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_pre15"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.15: 解开Portage快照</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd usr # time tar xjf portage-lat*

real  0m40.523s
user  0m28.280s
sys   0m8.240s</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_sect8"></a>切换系统

挂载/proc &amp; /dev文件系统，拷贝/etc/resolv.conf文件，然后chroot到你的Gentoo环境。

<a name="doc_chap2_pre16"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.16: Chroot</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd usr # cd /
livecd / # mount -t proc proc /mnt/gentoo/proc
livecd / # mount -o bind /dev /mnt/gentoo/dev
livecd / # cp -L /etc/resolv.conf /mnt/gentoo/etc/
livecd / # chroot /mnt/gentoo /bin/bash
livecd / # env-update &amp;&amp; source /etc/profile
&gt;&gt;&gt; Regenerating /etc/ld.so.cache...</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_sect9"></a>设定时区

设置你的时区信息：使用/usr/share/zoneinfo中的正确条目。

<a name="doc_chap2_pre17"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.17: 设置时区</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd / # ls /usr/share/zoneinfo
（以上海为例）
livecd / # cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
livecd / # date
Thu Aug 30 11:03:16 CST 2007</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_sect10"></a>设定主机名和域名

在/etc/conf.d/hostname和/etc/hosts中设置主机名。以下例子中我们用mybox作为主机名，用at.myplace作为域名。可以用nano编辑这些配置文件，或者使用下面的命令：

<a name="doc_chap2_pre18"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.18: 设置主机名和域名</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd / # cd /etc
livecd etc # echo "127.0.0.1 mdk-server.vim.myplace mybox localhost" &gt; hosts
livecd etc # sed -i -e 's/HOSTNAME.*/HOSTNAME="mdk-server"/' conf.d/hostname
（使用指定的主机名并检查）
livecd etc # hostname mdk-server
livecd etc # hostname -f
mdk-server.vim.myplace</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_sect11"></a>内核配置

安装一个内核源码包（通常为gentoo-sources），配置、编译并拷贝arch/i386/boot/bzImage文件到/boot。

<a name="doc_chap2_pre19"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.19: 安装内核源码包，编译和安装内核</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd etc # time emerge gentoo-sources

real  2m51.435s
user  0m58.220s
sys   0m29.890s
livecd etc # cd /usr/src/linux
livecd linux # make menuconfig
（配置内核）
livecd linux # time make -j2

（所花的时间很大程度上决定于你所选的选项）
real  3m51.962s
user  3m27.060s
sys   0m24.310s

livecd linux # make modules_install
livecd linux # cp arch/i386/boot/bzImage /boot/kernel</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_sect12"></a>配置系统

编辑/etc/fstab，用实际的分区名代替BOOT、ROOT和SWAP。记得确认一下文件系统是否与所安装的相匹配。

<a name="doc_chap2_pre20"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.20: fstab范例</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd linux # cd /etc
livecd etc # nano -w fstab
/dev/sda1   /boot     ext2    noauto,noatime     1 2
/dev/sda3   /         ext3    noatime            0 1
/dev/sda2   none      swap    sw                 0 0</pre>
</td>
</tr>
</tbody>
</table>
在/etc/conf.d/net中配置网络。把net.eth0启动脚本添加到默认运行级别。如果有多张网卡，分别为它们建立符号链接到net.eth0启动脚本，并一起添加到默认运行级别。用nano编辑/etc/conf.d/net，或者使用如下命令：

<a name="doc_chap2_pre21"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.21: 配置网络</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd etc # cd conf.d
livecd conf.d # echo 'config_eth0=( "192.168.1.10/24" )' &gt;&gt; net
livecd conf.d # echo 'routes_eth0=( "default via 192.168.1.1" )' &gt;&gt; net
livecd conf.d # rc-update add net.eth0 default
（如果你把网卡驱动编译为模块，
需要将它添加到/etc/modules.autoload.d/kernel-2.6）
livecd conf.d # echo r8169 &gt;&gt; /etc/modules.autoload.d/kernel-2.6
（如果希望重启后通过ssh重新连接到新机器）
livecd conf.d # rc-update add sshd default</pre>
</td>
</tr>
</tbody>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#bbffbb"><strong>注意: </strong> 如果需要支持PCMCIA卡，请emerge pcmciautils。</td>
</tr>
</tbody>
</table>
执行passwd设置root密码。

<a name="doc_chap2_pre22"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.22: 设置root密码</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd conf.d # passwd
New UNIX password: 输入密码
Retype new UNIX password: 再输入密码
passwd: password updated successfully</pre>
</td>
</tr>
</tbody>
</table>
编辑/etc/conf.d/clock以定义前面所使用的时区。

<a name="doc_chap2_pre23"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.23: 编辑/etc/conf.d/clock</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd conf.d # nano -w /etc/conf.d/clock
TIMEZONE="Asia/Shanghai"</pre>
</td>
</tr>
</tbody>
</table>
检查系统配置，查看并编辑这些配置文件：/etc/rc.conf， /etc/conf.d/rc，/etc/conf.d/keymaps。

<a name="doc_chap2_pre24"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.24: 可选：编辑一些配置文件</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd conf.d # nano -w /etc/rc.conf
livecd conf.d # nano -w /etc/conf.d/rc
livecd conf.d # nano -w /etc/conf.d/keymaps</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_sect13"></a>安装系统工具

安装一个系统日志如syslog-ng和一个cron守护进程如vixie-cron，并把它们添加到默认运行级别。
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#bbffbb"><strong>注意: </strong> Cron守护进程依赖于MTA。mail-mta/ssmtp会因依赖性而被一起安装。如果你想使用一种更高级的MTA，可以现在安装它。要是现在没空，暂时先安装ssmtp，以后再卸载并安装你要的MTA。</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_pre25"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.25: 安装系统日志和cron守护进程</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd conf.d # time emerge syslog-ng vixie-cron

real  1m54.099s
user  1m2.630s
sys   0m34.620s
livecd conf.d # rc-update add syslog-ng default
livecd conf.d # rc-update add vixie-cron default</pre>
</td>
</tr>
</tbody>
</table>
安装必要的文件系统工具（xfsprogs，reiserfsprogs或jfsutils）和网络工具（dhcpcd或ppp）。

<a name="doc_chap2_pre26"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.26: 安装其它工具</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd conf.d # emerge xfsprogs       （如果使用XFS文件系统）
livecd conf.d # emerge jfsutils       （如果使用JFS文件系统）
livecd conf.d # emerge reiserfsprogs  （如果使用Reiser文件系统）
livecd conf.d # emerge dhcpcd         （如果使用DHCP客户端）
livecd conf.d # emerge ppp            （如果使用PPPoE ADSL连接）</pre>
</td>
</tr>
</tbody>
</table>
<a name="grub"></a><a name="doc_chap2_sect14"></a>配置引导程序

安装并配置grub。

<a name="doc_chap2_pre27"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.27: Emerge grub并编辑它的配置文件</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd conf.d # time emerge grub

real  1m4.634s
user  0m39.460s
sys   0m15.280s
livecd conf.d # nano -w /boot/grub/grub.conf</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_pre28"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.28: grub.conf范例</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>default 0
timeout 10

title Gentoo
root (hd0,0)
kernel /boot/kernel root=/dev/sda3</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_pre29"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.29: 安装grub</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd conf.d # grub
Probing devices to guess BIOS drives. This may take a long time.

grub&gt; root (hd0,0)
 Filesystem type is ext2fs, partition type 0xfd

grub&gt; setup (hd0)
 Checking if "/boot/grub/stage1" exists... yes
 Checking if "/boot/grub/stage2" exists... yes
 Checking if "/boot/grub/e2fs_stage1_5" exists... yes
 Running "embed /boot/grub/e2fs_stage1_5 (hd0)"...  16 sectors are embedded.
succeeded
 Running "install /boot/grub/stage1 (hd0) (hd0)1+16 p (hd0,0)/boot/grub/stage2 /boot/
grub/menu.lst"... succeeded
Done.

grub&gt; quit</pre>
</td>
</tr>
</tbody>
</table>
<a name="reboot"></a><a name="doc_chap2_sect15"></a>重启

退出chroot环境，卸载所有文件系统并重启：

<a name="doc_chap2_pre30"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.30: 重启</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>livecd conf.d # exit
livecd / # umount /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo/boot /mnt/gentoo
livecd / # reboot
（别忘了取出光盘）</pre>
</td>
</tr>
</tbody>
</table>
<a name="after-reboot"></a><a name="doc_chap2_sect16"></a>完成安装
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#bbffbb"><strong>注意: </strong> 在我们这台测试机器上，从minimal CD启动显示boot提示符开始，到重启后显示登录提示符， <strong>总用时</strong>为<strong>00:42:31</strong> 。没错，不到一个小时！注意这个时间还包含了stage3包、Portage快照和一些软件包的下载时间，以及配置内核所花的时间。</td>
</tr>
</tbody>
</table>
以root身份登录，用useradd添加一个或多个用户，作为日常使用。

<a name="doc_chap2_pre31"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.31: 从另一台电脑连到你的新机器</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>（清理known_hosts文件中的内容，因为你的新机器已生成一个新的
通用主机密钥）
$ nano -w ~/.ssh/known_hosts
（找出新机器的IP并删除那一行，保存并退出nano）

（使用你新机器的IP地址）
$ ssh root@192.168.1.10
The authenticity of host '192.168.1.10 (192.168.1.10)' can't be established.
RSA key fingerprint is 96:e7:2d:12:ac:9c:b0:94:90:9f:40:89:b0:45:26:8f.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.1.10' (RSA) to the list of known hosts.
Password: 输入密码</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_pre32"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.32: 添加一个新用户</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>mybox ~ # adduser -g users -G lp,wheel,audio,cdrom,portage,cron -m john
mybox ~ # passwd john
New UNIX password: 设置John的密码
Retype new UNIX password: 再次输入John的密码
passwd: password updated successfully</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_sect17"></a>最后涉及的配置

开始选择最近的镜像，在/etc/make.conf中定义SYNC变量和GENTOO_MIRRORS变量，或者也可以使用mirrorselect。此时你还可以定义并行编译的进程数。

<a name="doc_chap2_pre33"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.33: 使用mirrorselect并设置MAKEOPTS</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>mybox ~ # emerge mirrorselect
mybox ~ # mirrorselect -i -o &gt;&gt; /etc/make.conf
mybox ~ # mirrorselect -i -r -o &gt;&gt; /etc/make.conf
（通常，一个较好的值为处理器数加一）
mybox ~ # echo 'MAKEOPTS="-j2"' &gt;&gt; /etc/make.conf</pre>
</td>
</tr>
</tbody>
</table>
现在是启用或禁用一些USE标记的好时机。运行emerge -vpe world，列出所有当前已安装的软件包以及它们被启用和禁用的USE标记。编辑/etc/make.conf或使用下列命令定义USE变量：

<a name="doc_chap2_pre34"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.34: 查看当前使用的USE标记并启用或禁用一些</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>mybox ~ # emerge -vpe world
（Portage列出软件包和它们的USE标记。作为例子，让我们禁用ipv6和fortran，
并启用unicode）
mybox ~ # echo 'USE="nptl nptlonly -ipv6 -fortran unicode"' &gt;&gt; /etc/make.conf</pre>
</td>
</tr>
</tbody>
</table>
新版本的glibc使用/etc/locale.gen来定义语言环境。

<a name="doc_chap2_pre35"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.35: 定义语言环境</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>mybox ~ # cd /etc
mybox etc # nano -w locale.gen
mybox etc # locale-gen</pre>
</td>
</tr>
</tbody>
</table>
最后但并非最轻松的，你可能想修改/etc/make.conf中的CFLAGS变量来优化编码，以满足你的特定需要。请注意极少需要一长串的标记列表，那样甚至可能导致系统崩溃。建议通过march选项指定处理器类型并赋上-O2 -pipe。

可能你还想转到 <strong>~x86</strong>。只有当你能够对付那些脆弱不良的ebuild和软件包时才能这么做。如果你倾向于保持系统的稳定性，请不要添加ACCEPT_KEYWORDS变量。添加FEATURES="ccache"却是个好主意。

<a name="doc_chap2_pre36"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.36: 为make.conf作最后的修改</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>mybox etc # nano -w make.conf
（在CFLAGS中将-march设为你的CPU类型）
CFLAGS="-O2 -march=athlon-xp -pipe"
（添加下面一行）
FEATURES="ccache"
（只有清楚自己在干什么才添加下面一行）
ACCEPT_KEYWORDS="~x86"</pre>
</td>
</tr>
</tbody>
</table>
可能你会想重编译整个系统两次，以使你所作的最新配置完全生效。这要花很长的时间来完成，而只能得到微小的速度提升。你可以让系统自己随着以后新软件包的发布而逐步完成优化。不过，站在保持系统一致性的立场来看，重编译仍不失为一个好主意。请参考文档<a href="http://www.gentoo.org/doc/zh_cn/gcc-upgrading.xml">Gentoo GCC升级指南</a>，其中讨论了如何搭建一个具有良好一致性的system和world，以及这样做的好处。

只重编译那些因你应用了新的USE标记或受此影响而需要升级的软件包，也要花费不少时间。可能还必须卸载会阻止你升级的软件包。在emerge -vpuD --newuse world的输出中寻找“[blocks <span style="color: #ff0000;"><strong>B</strong></span> ]”，用emerge -C卸载它们。

<a name="doc_chap2_pre37"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.37: 升级软件包</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>（安装ccache）
mybox etc # emerge ccache

（请注意转到~x86会导致很多软件包要升级）
mybox etc # emerge -vpuD --newuse world
（好好看一看软件包列表和它们的USE标记，
有阻止的包就先卸载，然后启动漫长的过程）
mybox etc # time emerge -vuD --newuse world
（（重）编译了79个软件包）

real  180m13.276s
user  121m22.905s
sys   36m31.472s

（重编译libtool以避免一些潜在的问题）
mybox etc # emerge --oneshot libtool

（更新配置文件，确保<strong>不要</strong>让dispatch-conf更新你配置好的文件）
mybox etc # dispatch-conf

（如果升级了perl，应该执行perl-cleaner脚本）
mybox etc # time perl-cleaner all
real  1m6.495s
user  0m42.699s
sys   0m10.641s

（如果升级了python的主要软件包，应该执行python-updater脚本）
mybox etc # python-updater</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_sect18"></a>接下来该做什么

想安装服务器应用程序还是一个桌面系统，取决于你打算让你的新Gentoo做什么。以下仅作为一个例子，统计了emerge gnome和emerge kde在~x86系统（按之前的描述安装的）上所花费的时间。两者是在同一起点开始安装的。

去看看我们的<a href="http://www.gentoo.org/doc/zh_cn/">文档目录</a>，研究一下如何安装和配置你挑选的软件。
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#ffffbb"><strong>重要: </strong> 以下只是举个例子，并不意味着就作为推荐设置。</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_pre38"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.38: Emerge GNOME</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>mybox etc # emerge -vp gnome
（查看软件包列表和它们的USE标记，
如果需要请编辑make.conf
mybox etc # nano -w /etc/make.conf
（定义了以下USE标记）
USE="nptl nptlonly -ipv6 -fortran unicode svg hal dbus \
     -kde -qt4 -arts -eds -esd gnome gstreamer gtk firefox"

mybox etc # time emerge gnome
（安装了326个软件包）

real  520m44.532s
user  339m21.144s
sys   146m22.337s</pre>
</td>
</tr>
</tbody>
</table>
<a name="doc_chap2_pre39"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td bgcolor="#7a5ada">代码 2.39: Emerge KDE</td>
</tr>
<tr>
<td dir="ltr" align="left" bgcolor="#eeeeff">
<pre>mybox etc # emerge -vp kde-meta
（查看软件包列表和它们的USE标记，
如果需要请编辑make.conf
mybox etc # nano -w /etc/make.conf
定义了以下USE标记）
USE="nptl nptlonly -ipv6 -fortran unicode svg hal dbus \
     kde qt4 -arts -eds -esd -gnome -gstreamer -gtk -firefox"

mybox etc # time emerge kde-meta
（安装了391个软件包）

real  1171m25.318s
user  851m26.393s
sys   281m45.629s</pre>
</td>
</tr>
</tbody>
</table>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>199</wp:post_id>
		<wp:post_date>2013-01-26 12:56:05</wp:post_date>
		<wp:post_date_gmt>2013-01-26 12:56:05</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>gentoo-%e6%9c%80%e5%b0%8f%e5%8c%96%e5%ae%89%e8%a3%85</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>167</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>自动化脚本</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=203</link>
		<pubDate>Sun, 27 Jan 2013 06:40:24 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=203</guid>
		<description></description>
		<content:encoded><![CDATA[@echo off

%systemroot%\system32\shutdown -s -f

: 以上为关机脚本

@echo off

%systemroot%\system32\shutdowm -r -t 0

: 以上为重启脚本]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>203</wp:post_id>
		<wp:post_date>2013-01-27 06:40:24</wp:post_date>
		<wp:post_date_gmt>2013-01-27 06:40:24</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e8%87%aa%e5%8a%a8%e5%8c%96%e8%84%9a%e6%9c%ac</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>63</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>C++虚函数及虚函数表解析</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=206</link>
		<pubDate>Sun, 24 Feb 2013 04:40:40 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=206</guid>
		<description></description>
		<content:encoded><![CDATA[<div id="cnblogs_post_body">转自:http://www.cnblogs.com/realyan/archive/2011/07/14/2106339.html</div>
<div><strong>虚函数的定义：</strong></div>
<div id="cnblogs_post_body">

<strong>　　虚函数必须是类的非静态成员函数（且非构造函数），其访问权限是public（可以定义为private or proteceted， 但是对于多态来说，没有意义。），在基类的类定义中定义虚函数的一般形式：</strong>

<strong>　　virtual 函数返回值类型 虚函数名（形参表）</strong>

<strong>　　{ 函数体 }</strong>

<strong>　　虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，</strong>

<strong>　　可以在基类的派生类中对虚函数重新定义（形式也 是：virtual 函数返回值类型 虚函数名（形参表）{ 函数体 }），在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继 承其基类的虚函数。当程序发现虚函数名前的关键字virtual后，会自动将其作为动态联编处理，即在程序运行时动态地选择合适的成员函数。</strong>

<strong>　　实现动态联编需要三个条件：</strong>

<strong>　　1、 必须把需要动态联编的行为定义为类的公共属性的虚函数。</strong>

<strong>　　2、 类之间存在子类型关系，一般表现为一个类从另一个类公有派生而来。</strong>

<strong>　　3、 必须先使用基类指针指向子类型的对象，然后直接或者间接使用基类指针调用虚函数。</strong>

<strong>　　定义虚函数的限制：</strong>

<strong>　　（1）非类的成员函数不能定义为虚函数，类的成员函数中静态 成员函数和构造函数也不能定义为虚函数，但可以将析构函数定义为虚函数。实际上，优秀的程序员常常把基类的析构函数定义为虚函数。因为，将基类的析构函数 定义为虚函数后，当利用delete删除一个指向派生类定义的对象指针时，系统会调用相应的类的析构函数。而不将析构函数定义为虚函数时，只调用基类的析 构函数。</strong>

<strong>　　（2）只需要在声明函数的类体中使用关键字“virtual”将函数声明为虚函数，而定义函数时不需要使用关键字“virtual”。</strong>

<strong>　　（3）如果声明了某个成员函数为虚函数，则在该类中不能出现和这个成员函数同名并且返回值、参数个数、参数类型都相同的非虚函数。在以该类为基类的派生类中，也不能出现这种非虚的同名同返回值同参数个数同参数类型函数。</strong>

<strong>　　为什么虚函数必须是类的成员函数：</strong>

<strong>　　虚函数诞生的目的就是为了实现多态，在类外定义虚函数毫无实际用处。</strong>

<strong>　　为什么类的静态成员函数不能为虚函数：</strong>

<strong>　　如果定义为虚函数，那么它就是动态绑定的，也就是在派生类中可以被覆盖的，这与静态成员函数的定义（：在内存中只有一份拷贝；通过类名或对象引用访问静态成员）本身就是相矛盾的。</strong>

<strong>　　为什么构造函数不能为虚函数：</strong>

<strong>　　因为如果构造函数为虚函数的话，它将在执行期间被构造，而执行期则需要对象已经建立，构造函数所完成的<a target="_self">工作</a>就 是为了建立合适的对象，因此在没有构建好的对象上不可能执行多态（虚函数的目的就在于实现多态性）的工作。在继承体系中，构造的顺序就是从基类到派生类， 其目的就在于确保对象能够成功地构建。构造函数同时承担着虚函数表的建立，如果它本身都是虚函数的话，如何确保vtbl的构建成功呢？</strong>

<strong>　　注意：当基类的构造函数内部有虚函数时，会出现什么情况呢？ 结果是在构造函数中，虚函数机制不起作用了，调用虚函数如同调用一般的成员函数一样。当基类的析构函数内部有虚函数时，又如何工作呢？与构造函数相同，只 有“局部”的版本被调用。但是，行为相同，原因是不一样的。构造函数只能调用“局部”版本，是因为调用时还没有派生类版本的信息。析构函数则是因为派生类 版本的信息已经不可靠了。我们知道，析构函数的调用顺序与构造函数相反，是从派生类的析构函数到基类的析构函数。当某个类的析构函数被调用时，其派生类的 析构函数已经被调用了，相应的数据也已被丢失，如果再调用虚函数的派生类的版本，就相当于对一些不可靠的数据进行操作，这是非常危险的。因此，在析构函数 中，虚函数机制也是不起作用的。</strong>

<strong>　　C++中的虚函数的作用主要是实现了多态的机制。关于多态， 简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技 术。所谓泛型技术，说白了就是试图使用不变的代码（Or 不变的 接口）来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。</strong>

<strong>　　关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇<a target="_self">文章</a>中，我只想从虚函数的实现机制上面为大家一个清晰的剖析。</strong>

<strong>　　当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于<a target="_self">学习</a>和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见</strong>

<strong>言归正传，让我们一起进入虚函数的世界。</strong>

<strong>　　虚函数表</strong>

<strong>　　对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。 这样，在有虚函数的类的实例（注：抽象类即有纯虚函数的类不能被实例化。）中这个表被分配在了这个实例的内存中（注：一个类的虚函数表是静态的，也就是说 对这个类的每个实例，他的虚函数表的是固定的，不会为每个实例生成一个相应的虚函数表。），所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表 就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</strong>

<strong>　　这里我们着重看一下这张虚函数表。在C++的标准规格说明书 中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。这意味着我们通过对象实例的地址得到这张 虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</strong>

<strong>　　假设我们有这样的一个类：</strong>
<table align="center">
<tbody>
<tr>
<td><strong>　　class Base { 　</strong>

<strong>　　　public: 　　</strong>

<strong>　　　　virtual void f() { cout &lt;&lt; "Base::f" &lt;&lt; endl; } 　</strong>

<strong>　　　　virtual void g() { cout &lt;&lt; "Base::g" &lt;&lt; endl; } 　</strong>

<strong>　　　　virtual void h() { cout &lt;&lt; "Base::h" &lt;&lt; endl; } 　</strong>

<strong>　};</strong></td>
</tr>
</tbody>
</table>
<strong>　　按照上面的说法，我们可以通过Base的实例来得到Base的虚函数表。 下面是实际例程：</strong>
<table align="center">
<tbody>
<tr>
<td><strong>　　{ 　　... 　　typedef void(*Fun)(void); 　　</strong>

<strong>Base b; 　</strong>

<strong>　　　Fun pFun = NULL; </strong>

<strong>　　 　cout &lt;&lt; "虚函数表地址：" &lt;&lt; (int*)(&amp;b) &lt;&lt; endl; 　</strong>

<strong>　　　cout &lt;&lt; "虚函数表 — 第一个函数地址：" &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl; 　</strong><strong>　// Invoke the first virtual function </strong>

<strong>　　　pFun = (Fun)*((int*)*(int*)(&amp;b)); </strong>

<strong>　　　pFun(); 　　... 　</strong>

<strong>　}</strong></td>
</tr>
</tbody>
</table>
<strong>　　实际运行经果如下(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3) ：</strong>

<strong>　　虚函数表地址：0012FED4</strong>

<strong>　　虚函数表 — 第一个函数地址：0044F148</strong>

<strong>　　Base::f</strong>

<strong>　　通过这个示例，我们可以看到，我们可以通过强行 把&amp;b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下：</strong>

<strong>　　(Fun)*((int*)*(int*)(&amp;b)+0); // Base::f()</strong>

<strong>　　(Fun)*((int*)*(int*)(&amp;b)+1); // Base::g()</strong>

<strong>　　(Fun)*((int*)*(int*)(&amp;b)+2); // Base::h()</strong>

<strong>　　画个图解释一下。如下所示：</strong>

<strong><a href="http://www.51testing.com/batch.download.php?aid=16802" target="_blank"><img src="http://www.51testing.com/attachments/2009/11/2_2009112710570818Cxg.jpg" alt="" border="0" /></a></strong>

<strong>　　注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“\0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。</strong>

<strong>　　在WinXP+VS2003下，这个值是NULL。</strong>

<strong>　　而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。</strong>

<strong>　　下面，我将分别说明“无覆盖”和“有覆盖”时的子类虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。</strong>

<strong>一般继承（无虚函数覆盖）</strong>

<strong>　　下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：</strong>
<p align="center"><strong><a href="http://www.51testing.com/batch.download.php?aid=16803" target="_blank"><img src="http://www.51testing.com/attachments/2009/11/2_200911271057121sq6l.jpg" alt="" border="0" /></a></strong></p>
<strong>　　请注意，在这个继承关系中，子类没有重写任何父类的函数。那么，在派生类的实例的虚函数表如下所示：</strong>

<strong>　　对于实例：Derive d; 的虚函数表如下： （overload（重载） 和 override（重写），重载就是所谓的名同而签名不同，重写就是对子类对虚函数的重新实现。）</strong>
<p align="center"><strong><a href="http://www.51testing.com/batch.download.php?aid=16804" target="_blank"><img src="http://www.51testing.com/attachments/2009/11/2_20091127105717135Iv.jpg" alt="" border="0" /></a></strong></p>
<strong>　　我们可以看到下面几点：</strong>

<strong>　　1）虚函数按照其声明顺序放于表中。</strong>

<strong>　　2）父类的虚函数在子类的虚函数前面。</strong>

<strong>　　一般继承（有虚函数覆盖）</strong>

<strong>　　覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。</strong>
<p align="center"><strong><a href="http://www.51testing.com/batch.download.php?aid=16805" target="_blank"><img src="http://www.51testing.com/attachments/2009/11/2_200911271057211pTm6.jpg" alt="" border="0" /></a></strong></p>
<strong>　　为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例的虚函数表会是下面的样子：</strong>
<p align="center"><strong><a href="http://www.51testing.com/batch.download.php?aid=16806" target="_blank"><img src="http://www.51testing.com/attachments/2009/11/2_200911271057251Ri8y.jpg" alt="" border="0" /></a></strong></p>
<strong>　　我们从表中可以看到下面几点，</strong>

<strong>　　1）覆盖的f()函数被放到了子类虚函数表中原来父类虚函数的位置。</strong>

<strong>　　2）没有被覆盖的函数依旧。</strong>

<strong>　　这样，我们就可以看到对于下面这样的程序，</strong>

<strong>　　Base *b = new Derive();</strong>

<strong>　　b-&gt;f();</strong>

<strong>　　由b所指的内存中的虚函数表（子类的虚函数表）的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。</strong>

<strong>多重继承（无虚函数覆盖）</strong>

<strong>　　下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。</strong>
<p align="center"><strong><a href="http://www.51testing.com/batch.download.php?aid=16807" target="_blank"><img src="http://www.51testing.com/attachments/2009/11/2_200911271057301D1x4.jpg" alt="" border="0" /></a></strong></p>
<strong>　　对于子类实例中的虚函数表，是下面这个样子：</strong>
<p align="center"><strong><a href="http://www.51testing.com/batch.download.php?aid=16808" target="_blank"><img src="http://www.51testing.com/attachments/2009/11/2_200911271057351C8H2.jpg" alt="" border="0" /></a></strong></p>
<strong>　　我们可以看到：</strong>

<strong>　　1） 每个父类都有自己的虚表。</strong>

<strong>　　2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</strong>

<strong>　　这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</strong>

<strong>　　多重继承（有虚函数覆盖）</strong>

<strong>　　下面我们再来看看，如果发生虚函数覆盖的情况。</strong>

<strong>　　下图中，我们在子类中覆盖了父类的f()函数。</strong>
<p align="center"><strong><a href="http://www.51testing.com/batch.download.php?aid=16809" target="_blank"><img src="http://www.51testing.com/attachments/2009/11/2_2009112710574115sQ3.jpg" alt="" border="0" /></a></strong></p>
<p align="left"><strong>　　下面是对于子类实例中的虚函数表的图：</strong></p>
<p align="center"><strong><a href="http://www.51testing.com/batch.download.php?aid=16810" target="_blank"><img src="http://www.51testing.com/attachments/2009/11/2_200911271109011PbgC.jpg" alt="" border="0" /></a></strong></p>
<strong>　　我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以用任一个父类指针来指向子类，并调用子类的f()了。如：</strong>

<strong>　　　Derive d; 　</strong>

<strong>　　　Base1 *b1 = &amp;d; 　</strong>

<strong>　　　Base2 *b2 = &amp;d; 　　</strong>

<strong>　　　Base3 *b3 = &amp;d; 　</strong>

<strong>　　　b1-&gt;f(); //Derive::f() </strong>

<strong>　　　b2-&gt;f(); //Derive::f() 　</strong>

<strong>　　　b3-&gt;f(); //Derive::f() 　　</strong>

<strong>　　　b1-&gt;g(); //Base1::g() 　　</strong>

<strong>　　　b2-&gt;g(); //Base2::g() 　</strong>

<strong>　　　b3-&gt;g(); //Base3::g()</strong>

<strong>安全性</strong>

<strong>　　每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。</strong>

<strong>　　一、尝试：通过父类型的指针（指向子类对象）访问子类自己的虚函数</strong>

<strong>　　我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到子类的虚表中有Derive自己的虚函数，但我们根本不可能使用基类的指针来调用子类的自有虚函数：</strong>

<strong>　　Base1 *b1 = new Derive();</strong>

<strong>　　b1-&gt;f1(); //编译出错</strong>

<strong>　　任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。</strong>

<strong>　　但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。</strong>

<strong>　　二、尝试：通过父类型的指针（指向子类对象）访问父类的non-public虚函数</strong>

<strong>　　另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于子类虚函数表中，所以我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。</strong>

<strong>　　如：</strong>
<table align="center">
<tbody>
<tr>
<td><strong>　　class Base { 　　private: 　　virtual void f() { cout &lt;&lt; "Base::f" &lt;&lt; endl; } 　　}; </strong>

<strong>　　class Derive : public Base{ 　　}; 　　</strong>

<strong>　　typedef void(*Fun)(void); 　　</strong>

<strong>　　void main()</strong>

<strong>　　 { 　</strong>

<strong>　　　Derive d; 　</strong>

<strong>　　　Fun pFun = (Fun)*((int*)*(int*)(&amp;d)+0); </strong>

<strong>　　　　pFun(); 　　</strong>

<strong>　　}</strong></td>
</tr>
</tbody>
</table>
<strong>　　结束语</strong>

<strong>　　C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。</strong>

</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>206</wp:post_id>
		<wp:post_date>2013-02-24 04:40:40</wp:post_date>
		<wp:post_date_gmt>2013-02-24 04:40:40</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>c%e8%99%9a%e5%87%bd%e6%95%b0%e5%8f%8a%e8%99%9a%e5%87%bd%e6%95%b0%e8%a1%a8%e8%a7%a3%e6%9e%90</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>53</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>C++中的虚函数(virtual function)</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=208</link>
		<pubDate>Sun, 24 Feb 2013 04:43:46 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=208</guid>
		<description></description>
		<content:encoded><![CDATA[<div id="cnblogs_post_body">

转自:http://www.cnblogs.com/realyan/archive/2011/07/13/2105801.html

<strong>一.简介</strong>

虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。假设我们有下面的类层次：

class A {

public: virtual void foo()

{

cout &lt;&lt; "A::foo() is called" &lt;&lt; endl;

}

};
class B: public A

{

public: virtual void foo()

{

cout &lt;&lt; "B::foo() is called" &lt;&lt; endl;

}

};

那么，在使用的时候，我们可以：　 A * a = new B();

a-&gt;foo(); // 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!

这个例子是虚函数的一个典型应用，通过这个例子，也许你就对虚函数有了一些概念。它虚就虚在所谓“推迟联编”或者“动态联编”上，一个类函数的 调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函 数。
虚函数只能借助于指针或者引用来达到多态的效果，如果是下面这样的代码，则虽然是虚函数，但它不是多态的：

class A

{

public: virtual void foo();

};

class B: public A

{

virtual void foo();

};
void bar()

{

A a; a.foo(); // A::foo()被调用

}

<strong>1.1 多态</strong>　　在了解了虚函数的意思之后，再考虑什么是多态就很容易了。仍然针对上面的类层次，但是使用的方法变的复杂了一些：void bar(A * a)

{ a-&gt;foo(); // 被调用的是A::foo() 还是B::foo()？ }

因为foo()是个虚函数，所以在bar这个函数中，只根据这段代码，无从确定这里被调用的是A::foo()还是B::foo()，但是可以肯定的说：如果a指向的是A类的实例，则A::foo()被调用，如果a指向的是B类的实例，则B::foo()被调用。
这种同一代码可以产生不同效果的特点，被称为“多态”。
<strong>1.2 多态有什么用？</strong> 　　多态这么神奇，但是能用来做什么呢？这个命题我难以用一两句话概括，一般的C++教程（或者其它面向对象语言的教程）都用一个画图的例子来展示多态的 用途，我就不再重复这个例子了，如果你不知道这个例子，随便找本书应该都有介绍。我试图从一个抽象的角度描述一下，回头再结合那个画图的例子，也许你就更 容易理解。
在面向对象的编程中，首先会针对数据进行抽象（确定基类）和继承（确定派生类），构成类层次。这个类层次的使用者在使用它们的时 候，如果仍然在需要基类的时候写针对基类的代码，在需要派生类的时候写针对派生类的代码，就等于类层次完全暴露在使用者面前。如果这个类层次有任何的改变 （增加了新类），都需要使用者“知道”（针对新类写代码）。这样就增加了类层次与其使用者之间的耦合，有人把这种情况列为程序中的“bad smell”之一。
多态可以使程序员脱离这种窘境。再回头看看1.1中的例子，bar()作为A-B这个类层次的使用者，它并不知道这个类层 次中有多少个类，每个类都叫什么，但是一样可以很好的工作，当有一个C类从A类派生出来后，bar()也不需要“知道”（修改）。这完全归功于多态--编 译器针对虚函数产生了可以在运行时刻确定被调用函数的代码。

<strong>1.3 如何“动态联编”</strong> 　　编译器是如何针对虚函数产生可以再运行时刻确定被调用函数的代码呢？也就是说，虚函数实际上是如何被编译器处理的呢？Lippman在深度探索C++对象模型[1]中的不同章节讲到了几种方式，这里把“标准的”方式简单介绍一下。
我所说的“标准”方式，也就是所谓的“VTABLE”机制。编译器发现一个类中有被声明为virtual的函数，就会为其搞一个虚函数表，也就是 VTABLE。VTABLE实际上是一个函数指针的数组，每个虚函数占用这个数组的一个slot。一个类只有一个VTABLE，不管它有多少个实例。派生 类有自己的VTABLE，但是派生类的VTABLE与基类的VTABLE有相同的函数排列顺序，同名的虚函数被放在两个数组的相同位置上。在创建类实例的 时候，编译器还会在每个实例的内存布局中增加一个vptr字段，该字段指向本类的VTABLE。通过这些手段，编译器在看到一个虚函数调用的时候，就会将 这个调用改写，针对1.1中的例子：

void bar(A * a) { a-&gt;foo(); }

会被改写为：

void bar(A * a) { (a-&gt;vptr[1])(); }

因为派生类和基类的foo()函数具有相同的VTABLE索引，而他们的vptr又指向不同的VTABLE，因此通过这样的方法可以在运行时刻决定调用哪个foo()函数。
虽然实际情况远非这么简单，但是基本原理大致如此。
<strong>1.4 overload和override</strong> 　　虚函数总是在派生类中被改写，这种改写被称为“override”。我经常混淆“overload”和“override”这两个单词。但是随着各类C++的书越来越多，后来的程序员也许不会再犯我犯过的错误了。但是我打算澄清一下：
override是指派生类重写基类的虚函数，就象我们前面B类中重写了A类中的foo()函数。重写的函数必须有一致的参数表和返回值（C++标准允 许返回值不同的情况，这个我会在“语法”部分简单介绍，但是很少编译器支持这个feature）。这个单词好象一直没有什么合适的中文词汇来对应，有人译 为“覆盖”，还贴切一些。 overload约定成俗的被翻译为“重载”。是指编写一个与已有函数同名但是参数表不同的函数。例如一个函数即可以接受整型数作为参数，也可以接受浮点 数作为参数。
<strong>二. 虚函数的语法</strong> 　　虚函数的标志是“virtual”关键字。
<strong>2.1 使用virtual关键字</strong>　　考虑下面的类层次：

class A { public: virtual void foo(); };
class B: public A { public: void foo(); // 没有virtual关键字! };
class C: public B // 从B继承，不是从A继承！ { public: void foo(); // 也没有virtual关键字！ };

这种情况下，B::foo()是虚函数，C::foo()也同样是虚函数。因此，可以说，基类声明的虚函数，在派生类中也是虚函数，即使不再使用virtual关键字。
<strong>2.2 纯虚函数</strong>　　如下声明表示一个函数为纯虚函数：

class A { public: virtual void foo()=0; // =0标志一个虚函数为纯虚函数 };

一个函数声明为纯虚后，纯虚函数的意思是：我是一个抽象类！不要把我实例化！纯虚函数用来规范派生类的行为，实际上就是所谓的“接口”。它告诉使用者，我的派生类都会有这个函数。
<strong>2.3 虚析构函数</strong>　　析构函数也可以是虚的，甚至是纯虚的。例如：

class A { public: virtual ~A()=0; // 纯虚析构函数 };

&nbsp;

当一个类打算被用作其它类的基类时，它的析构函数必须是虚的。考虑下面的例子：

class A {

public: A() { ptra_ = new char[10];}

~A() { delete[] ptra_;} // 非虚析构函数

private: char * ptra_; };
class B: public A { public: B() { ptrb_ = new char[20];}

~B() { delete[] ptrb_;} private: char * ptrb_; };
void foo() { A * a = new B; delete a; }

在这个例子中，程序也许不会象你想象的那样运行，在执行delete a的时候，实际上只有A::~A()被调用了，而B类的析构函数并没有被调用！这是否有点儿可怕？
如果将上面A::~A()改为virtual，就可以保证B::~B()也在delete a的时候被调用了。因此基类的析构函数都必须是virtual的。
纯虚的析构函数并没有什么作用，是虚的就够了。通常只有在希望将一个类变成抽象类（不能实例化的类），而这个类又没有合适的函数可以被纯虚化的时候，可以使用纯虚的析构函数来达到目的。
<strong>2.4 虚构造函数？</strong> 　　构造函数不能是虚的。
<strong>三. 虚函数使用技巧</strong>

<strong>3.1 private的虚函数</strong> 　　考虑下面的例子：

class A { public:

void foo() { bar();}

private:

virtual void bar() { ...}

};
class B: public A

{

private: virtual void bar() { ...}

};

在这个例子中，虽然bar()在A类中是private的，但是仍然可以出现在派生类中，并仍然可以与public 或者protected的虚函数一样产生多态的效果。并不会因为它是private的，就发生A::foo()不能访问B::bar()的情况，也不会发 生B::bar()对A::bar()的override不起作用的情况。
这种写法的语意是：A告诉B，你最好override我的bar()函数，但是你不要管它如何使用，也不要自己调用这个函数。
<strong>3.2 构造函数和析构函数中的虚函数调用</strong>　　一个类的虚函数在它自己的构造函数和析构函数中被调用的时候，它们就变成普通函数了，不“虚”了。也就是说不能在构造函数和析构函数中让自己“多态”。例如：

class A {

public: A() { foo();} // 在这里，无论如何都是A::foo()被调用！

~A() { foo();} // 同上

virtual void foo();

};
class B: public A

{

public: virtual void foo();

};
void bar()

{

A * a = new B;

delete a;

}

如果你希望delete a的时候，会导致B::foo()被调用，那么你就错了。同样，在new B的时候，A的构造函数被调用，但是在A的构造函数中，被调用的是A::foo()而不是B::foo()。
<strong>3.3 多继承中的虚函数 3.4 什么时候使用虚函数</strong> 　　在你设计一个基类的时候，如果发现一个函数需要在派生类里有不同的表现，那么它就应该是虚的。从设计的角度讲，出现在基类中的虚函数是接口，出现在派生类中的虚函数是接口的具体实现。通过这样的方法，就可以将对象的行为抽象化。
以设计模式[2]中Factory Method模式为例，Creator的factoryMethod()就是虚函数，派生类override这个函数后，产生不同的Product类，被 产生的Product类被基类的AnOperation()函数使用。基类的AnOperation()函数针对Product类进行操作，当然 Product类一定也有多态（虚函数）。

另外一个例子就是集合操作，假设你有一个以A类为基类的类层次，又用了一个std::vector<a>来保存这个类层次中不同类的实例指针，那么你一定希望在对这个集合中的类进行操作的时候，不要把每个指针再cast回到它原来的类型（派生类），而是希望对他们进行同样的操作。那么就应该将这个“一样的操作”声明为virtual。
现实中，远不只我举的这两个例子，但是大的原则都是我前面说到的“如果发现一个函数需要在派生类里有不同的表现，那么它就应该是虚的”。这句话也可以反过来说：“如果你发现基类提供了虚函数，那么你最好override它”。</a>

附：<strong>C++中的虚函数和纯虚函数用法</strong>

<strong>1</strong>.虚函数和纯虚函数可以定义在同一个类(class)中，含有纯虚函数的类被称为抽象类（abstract class），而只含有虚函数的类（class）不能被称为抽象类（abstract class）。
<strong>2</strong>.虚函数可以被直接使用，也可以被子类（sub class）重载以后以多态的形式调用，而纯虚函数必须在子类（sub class）中实现该函数才可以使用，因为纯虚函数在基类（base class） 只有声明而没有定义。
<strong>3</strong>.虚函数和纯虚函数都可以在子类（sub class）中被重载，以多态的形式被调用。
<strong>　　4</strong>.虚函数和纯虚函数通常存在于抽象基类（abstract base class -ABC）之中，被继承的子类重载，目的是提供一个统一的接口。
<strong>　　5</strong>. 虚函数的定义形式：virtual {method body} ；纯虚函数的定义形式：virtual { } = 0; 在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,然而虚函数却是动态绑定 （run-time bind），而且被两者修饰的函数生命周期（life recycle）也不一样。

<strong>6</strong>.如果一个类中含有纯虚函数，那么任何试图对该类进行实例化的语句都将导致错误的产生，因为抽象基类（ABC）是不能被直接调用的。必须被子类继承重载以后，根据要求调用其子类的方法。
以下为一个简单的虚函数和纯虚寒数的使用演示，目的是抛砖引玉！

class Virtualbase

{

public:

virtual void Demon()= 0; //prue virtual function

virtual void Base() {cout&lt;&lt;"this is farther class"&lt;}; //sub class

void main() {  Virtualbase* inst = new SubVirtual(); //multstate pointer

inst-&gt;Demon();

inst-&gt;Base(); // inst = new Virtualbase(); // inst-&gt;Base()

return ;

}

</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>208</wp:post_id>
		<wp:post_date>2013-02-24 04:43:46</wp:post_date>
		<wp:post_date_gmt>2013-02-24 04:43:46</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>c%e4%b8%ad%e7%9a%84%e8%99%9a%e5%87%bd%e6%95%b0virtual-function</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>53</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>linux运维常用命令</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=211</link>
		<pubDate>Mon, 25 Feb 2013 02:44:11 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=211</guid>
		<description></description>
		<content:encoded><![CDATA[<h1>转自:http://deepin.iteye.com/blog/711813</h1>
<h1>1.删除0字节文件
find -type f -size 0 -exec rm -rf {} \;

2.查看进程
按内存从大到小排列
ps -e   -o "%C   : %p : %z : %a"|sort -k5 -nr

3.按cpu利用率从大到小排列
ps -e   -o "%C   : %p : %z : %a"|sort   -nr

4.打印说cache里的URL
grep -r -a   jpg /data/cache/* | strings | grep "http:" | awk -F'http:' '{print "http:"$2;}'

5.查看http的并发请求数及其TCP连接状态：
netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'


6. sed -i '/Root/s/no/yes/' /etc/ssh/sshd_config   sed在这个文里Root的一行，匹配Root一行，将no替换成yes.</h1>
<h1>7.1.如何杀掉mysql进程：
ps aux |grep mysql |grep -v grep  |awk '{print $2}' |xargs kill -9 (从中了解到awk的用途)

killall -TERM mysqld

kill -9 `cat /usr/local/apache2/logs/httpd.pid`   试试查杀进程PID

8.显示运行3级别开启的服务:
ls /etc/rc3.d/S* |cut -c 15-   (从中了解到cut的用途，截取数据)

9.如何在编写SHELL显示多个信息，用EOF
cat &lt;&lt; EOF
+--------------------------------------------------------------+
|       === Welcome to Tunoff services ===                |
+--------------------------------------------------------------+
EOF

10. for 的巧用(如给mysql建软链接)
cd /usr/local/mysql/bin
for i in *
do ln /usr/local/mysql/bin/$i /usr/bin/$i
done

11. 取IP地址：
ifconfig eth0 |grep "inet addr:" |awk '{print $2}'|cut -c 6-   或者

ifconfig   | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}'

12.内存的大小:
free -m |grep "Mem" | awk '{print $2}'

13.
netstat -an -t | grep ":80" | grep ESTABLISHED | awk '{printf "%s %s\n",$5,$6}' | sort

14.查看Apache的并发请求数及其TCP连接状态：
netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'

15.因为同事要统计一下服务器下面所有的jpg的文件的大小,写了个shell给他来统计.原来用xargs实现,但他一次处理一部分,搞的有多个总和....,下面的命令就能解决啦.
find / -name *.jpg -exec wc -c {} \;|awk '{print $1}'|awk '{a+=$1}END{print a}'

CPU的数量（多核算多个CPU，cat /proc/cpuinfo |grep -c processor）越多，系统负载越低，每秒能处理的请求数也越多。

---------------------------------------------------------------------------------------
16   CPU负载   # cat /proc/loadavg
检查前三个输出值是否超过了系统逻辑CPU的4倍。

18   CPU负载   #mpstat 1 1
检查%idle是否过低(比如小于5%)

19   内存空间   # free
检查free值是否过低   也可以用 # cat /proc/meminfo

20   swap空间   # free
检查swap used值是否过高   如果swap used值过高，进一步检查swap动作是否频繁：
# vmstat 1 5
观察si和so值是否较大

21   磁盘空间   # df -h
检查是否有分区使用率(Use%)过高(比如超过90%)   如发现某个分区空间接近用尽，可以进入该分区的挂载点，用以下命令找出占用空间最多的文件或目录：
# du -cks * | sort -rn | head -n 10

22   磁盘I/O负载   # iostat -x 1 2
检查I/O使用率(%util)是否超过100%

23   网络负载   # sar -n DEV
检查网络流量(rxbyt/s, txbyt/s)是否过高

24   网络错误   # netstat -i
检查是否有网络错误(drop fifo colls carrier)   也可以用命令：# cat /proc/net/dev

25 网络连接数目   # netstat -an | grep -E “^(tcp)” | cut -c 68- | sort | uniq -c | sort -n

26   进程总数   # ps aux | wc -l
检查进程个数是否正常 (比如超过250)

27   可运行进程数目   # vmwtat 1 5
列给出的是可运行进程的数目，检查其是否超过系统逻辑CPU的4倍

28   进程   # top -id 1
观察是否有异常进程出现

29   网络状态   检查DNS, 网关等是否可以正常连通

30   用户   # who | wc -l
检查登录用户是否过多 (比如超过50个)   也可以用命令：# uptime

31   系统日志   # cat /var/log/rflogview/*errors
检查是否有异常错误记录   也可以搜寻一些异常关键字，例如：
# grep -i error /var/log/messages
# grep -i fail /var/log/messages

32   核心日志   # dmesg
检查是否有异常错误记录

33   系统时间   # date
检查系统时间是否正确

34   打开文件数目   # lsof | wc -l
检查打开文件总数是否过多

35   日志   # logwatch –print   配置/etc/log.d/logwatch.conf，将 Mailto 设置为自己的email 地址，启动mail服务 (sendmail或者postfix)，这样就可以每天收到日志报告了。
缺省logwatch只报告昨天的日志，可以用# logwatch –print –range all 获得所有的日志分析结果。
可以用# logwatch –print –detail high 获得更具体的日志分析结果(而不仅仅是出错日志)。

36.杀掉80端口相关的进程
lsof -i :80|grep -v "PID"|awk '{print "kill -9",$2}'|sh

37.清除僵死进程。
ps -eal | awk '{ if ($2 == "Z") {print $4}}' | kill -9

38.tcpdump 抓包 ，用来防止80端口被人攻击时可以分析数据
# tcpdump -c 10000 -i eth0 -n dst port 80 &gt; /root/pkts

39.然后检查IP的重复数 并从小到大排序 注意 "-t\ +0"   中间是两个空格
# less pkts | awk {'printf $3"\n"'} | cut -d. -f 1-4 | sort | uniq -c | awk {'printf $1" "$2"\n"'} | sort -n -t\ +0

40.查看有多少个活动的php-cgi进程
netstat -anp | grep php-cgi | grep ^tcp | wc -l</h1>
chkconfig --list | awk '{if ($5=="3:on") print $1}'

41.kudzu查看网卡型号
kudzu --probe --class=network

匹配中文字符的正则表达式： [\u4e00-\u9fa5]
评注：匹配中文还真是个头疼的事，有了这个表达式就好办了

匹配双字节字符(包括汉字在内)：[^\x00-\xff]
评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）

匹配空白行的正则表达式：\n\s*\r
评注：可以用来删除空白行

匹配HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;
评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力

匹配首尾空白字符的正则表达式：^\s*|\s*$
评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式

匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
评注：表单验证时很实用

匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*
评注：网上流传的版本功能很有限，上面这个基本可以满足需求

匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
评注：表单验证时很实用

匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}
评注：匹配形式如 0511-4405222 或 021-87888822

匹配腾讯QQ号：[1-9][0-9]{4,}
评注：腾讯QQ号从10000开始

匹配中国邮政编码：[1-9]\d{5}(?!\d)
评注：中国邮政编码为6位数字

匹配身份证：\d{15}|\d{18}
评注：中国的身份证为15位或18位

匹配ip地址：\d+\.\d+\.\d+\.\d+

评注：提取ip地址时有用

匹配特定数字：
^[1-9]\d*$　 　 //匹配正整数
^-[1-9]\d*$ 　 //匹配负整数
^-?[1-9]\d*$　　 //匹配整数
^[1-9]\d*|0$　 //匹配非负整数（正整数 + 0）
^-[1-9]\d*|0$　　 //匹配非正整数（负整数 + 0）
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$　　 //匹配正浮点数
^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$　 //匹配负浮点数
^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$　 //匹配浮点数
^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）
^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$　　//匹配非正浮点数（负浮点数 + 0）
评注：处理大量数据时有用，具体应用时注意修正

匹配特定字符串：
^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串
^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串
^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串
^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串
^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串
评注：最基本也是最常用的一些表达式]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>211</wp:post_id>
		<wp:post_date>2013-02-25 02:44:11</wp:post_date>
		<wp:post_date_gmt>2013-02-25 02:44:11</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>linux%e8%bf%90%e7%bb%b4%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>8</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Linux常用系统信息查看命令 系统</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=213</link>
		<pubDate>Mon, 25 Feb 2013 05:47:13 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=213</guid>
		<description></description>
		<content:encoded><![CDATA[<div>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<div>1   2

3

4

5

6

7

8

</div></td>
<td>
<div># uname -a               # 查看内核/操作系统/CPU信息   # head -n 1 /etc/issue   # 查看操作系统版本

# cat /proc/cpuinfo      # 查看CPU信息

# hostname               # 查看计算机名

# lspci -tv              # 列出所有PCI设备

# lsusb -tv              # 列出所有USB设备

# lsmod                  # 列出加载的内核模块

# env                    # 查看环境变量

</div></td>
</tr>
</tbody>
</table>
</div>
<h1>资源</h1>
<div>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<div>1   2

3

4

5

6

7

</div></td>
<td>
<div># free -m                # 查看内存使用量和交换区使用量   # df -h                  # 查看各分区使用情况

# du -sh &amp;lt;目录名&amp;gt;        # 查看指定目录的大小

# grep MemTotal /proc/meminfo   # 查看内存总量

# grep MemFree /proc/meminfo    # 查看空闲内存量

# uptime                 # 查看系统运行时间、用户数、负载

# cat /proc/loadavg      # 查看系统负载

</div></td>
</tr>
</tbody>
</table>
</div>
<h1>磁盘和分区</h1>
<div>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<div>1   2

3

4

5

</div></td>
<td>
<div># mount | column -t      # 查看挂接的分区状态   # fdisk -l               # 查看所有分区

# swapon -s              # 查看所有交换分区

# hdparm -i /dev/hda     # 查看磁盘参数(仅适用于IDE设备)

# dmesg | grep IDE       # 查看启动时IDE设备检测状况

</div></td>
</tr>
</tbody>
</table>
</div>
<h1>网络</h1>
<div>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<div>1   2

3

4

5

6

</div></td>
<td>
<div># ifconfig               # 查看所有网络接口的属性   # iptables -L            # 查看防火墙设置

# route -n               # 查看路由表

# netstat -lntp          # 查看所有监听端口

# netstat -antp          # 查看所有已经建立的连接

# netstat -s             # 查看网络统计信息

</div></td>
</tr>
</tbody>
</table>
</div>
<h1>进程</h1>
<div>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<div>1   2

</div></td>
<td>
<div># ps -ef                 # 查看所有进程   # top                    # 实时显示进程状态

</div></td>
</tr>
</tbody>
</table>
</div>
<h1>用户</h1>
<div>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<div>1   2

3

4

5

6

</div></td>
<td>
<div># w                      # 查看活动用户   # id &amp;lt;用户名&amp;gt;            # 查看指定用户信息

# last                   # 查看用户登录日志

# cut -d: -f1 /etc/passwd   # 查看系统所有用户

# cut -d: -f1 /etc/group    # 查看系统所有组

# crontab -l             # 查看当前用户的计划任务

</div></td>
</tr>
</tbody>
</table>
</div>
<h1>服务</h1>
<div>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<div>1   2

</div></td>
<td>
<div># chkconfig --list       # 列出所有系统服务   # chkconfig --list | grep on    # 列出所有启动的系统服务

</div></td>
</tr>
</tbody>
</table>
</div>
<h1>程序</h1>
<div>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>
<div>1

</div></td>
<td>
<div># rpm -qa                # 查看所有安装的软件包</div></td>
</tr>
</tbody>
</table>
</div>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>213</wp:post_id>
		<wp:post_date>2013-02-25 05:47:13</wp:post_date>
		<wp:post_date_gmt>2013-02-25 05:47:13</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>linux%e5%b8%b8%e7%94%a8%e7%b3%bb%e7%bb%9f%e4%bf%a1%e6%81%af%e6%9f%a5%e7%9c%8b%e5%91%bd%e4%bb%a4-%e7%b3%bb%e7%bb%9f</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>34</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>来杭州三年了</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=217</link>
		<pubDate>Thu, 14 Mar 2013 13:45:51 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=217</guid>
		<description></description>
		<content:encoded><![CDATA[~今天在qq空间上对以高中同学爆粗了~今天来实验室做了一个下午的题目~~发现真的老了~prim+bfs code了老半天~╮(╯▽╰)╭~~gvim以后不想用了~杭州来三年了~成长了不少了~~也经历不少~总之呢有收获也有痛苦~运维+系统管理机器是那么在手~~为其自个的人生啊~我其实想对那些什么都学的人说一声啊~~没有侧重点就做算法和数据结构~真心的~]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>217</wp:post_id>
		<wp:post_date>2013-03-14 13:45:51</wp:post_date>
		<wp:post_date_gmt>2013-03-14 13:45:51</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%9d%a5%e6%9d%ad%e5%b7%9e%e4%b8%89%e5%b9%b4%e4%ba%86</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>117</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title> 这三天</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=221</link>
		<pubDate>Wed, 27 Mar 2013 13:38:55 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=221</guid>
		<description></description>
		<content:encoded><![CDATA[逃了三天课，这三天来~也算是对三年来的验证吧。星期一，浙大玉泉校区参加163.com的笔试（sa反垃圾邮件工程师）,星期二，笔试太累,基本一天在实验室睡觉。今天去了趟滨江。在163.com的c座大厦里就吃了一个他们的小面包和一杯水。╮(╯▽╰)╭，不管结果如何~或许都得到历练了~
星期一，下午两点多，自个火急火燎的赶到浙大，看到玉泉校区才知道什么是读书人的地方，人家的校园，人家的读书氛围，看的像我这种二本掉渣的院校心里不是一般滋味.在里面逛了一圈后终于找到了曹光彪科技楼.晚上的宣讲会赵HR看起来很年轻，讲得很有渲染力。演讲的能力让我打心底里佩服。到场有三百多个人~大部分都是浙大~好不自卑吗~我是坐b1去的玉泉校区~然后我的笔试座位号也B1(神座啊)~八点的考试~主考官最后一个把考卷给我~算是从8:10开始的~我是9:01交的卷子~当时在场的我第三个交卷~自我感觉不错的~就赶着坐公交回下沙了~回到学校的时候已经10:30了~所以没回寝室~在实验室睡了一晚~还因此感冒了~杭州的天气还真是易变啊
星期二，因为笔试那天晚上赶着回来太累了~而且这一天就一节软件工程~所以逃了~也因HR告诉我们笔试的通知最晚在第二天的晚上告诉我们~这一天我是在焦虑中度过的~但我觉得自己的笔试很好~可以拿到面试的~晚上跟着老聂从实验室回去~吃了个饭洗了个澡~然后突然发现163.com的面试通知短信~很兴奋~跑去特地要老聂找去滨江的公交路线~一整晚睡得还可以~
今天~怎么说呢~一切的一切或许又回归了吧~今天又逃了一天的课~早上八点跑来实验室拿简历~九点的时候去书店给天师取快递~快十点的时候坐着566前往滨江~快中午的时候到达滨江~好久都不出去了~下车后有点找不着北的感觉~找了好久才找到面试的地点~快下午一点的时候开始前往面试地点~路上认识一位从上海赶过来的哥们~他研二搞安卓的~他说饿想找吃的~最后我们一起来到了163.com大厦的C座签到，发现面试区域居然提供吃喝~163.com的研究所所在地的确很偏僻~跟我一起的哥们也这么说~他一口气吃了两个面包~我们才坐下不久我就面试开始了~面我的是个很年轻的技术哥~他首先让我自我介绍~然后他开始看我的网上简历和我的笔试卷子~边看边问~当时也是脑子一片空白~随性也跟他扯起来~我记得他让我介绍了我的两个项目~一个是在线评判系统~另一个是ftp（半成品的项目）~我糊里糊涂的也不知道怎么说了~最后依稀记得他向我问了tcpdump和smtp协议~我记得笔试的卷有两道tcp/ip的题目~我答得都挺好的~一个是tcp的三次握手过程和那七层协议~其实我看到面试官手里我的卷子上打着一个不错的分数~心里窃喜啊~最后面试官让我问他问题~我问了几个后就不问了~然后他说面试结束了让我去面试区等待HR通知~走出来的时候我问面试官怎么不问shell啊？他没回答~他过了会问我课多吗~我随性的回答了~出来后发现跟我一起来的那哥们也刚面完出来~我们彼此谈了感受~期间他又吃了两个面包~我们在等待区侯着期间认识了一位中国科技大学的研一的也搞安卓的~他还没有面~他不断地询问都面了啥~我看了他的简历~光项目他就有了一页纸了~牛人啊~然后的然后~那个女HR告诉我结果~我没有追问为何~走出来的时候也挺释然的~╮(╯▽╰)╭╮(╯▽╰)╭~
一句话概括：面包挺好吃的，水也挺甜的~这三天也算是攒了经验值吧~结果已经不重要了~过程已经享受了~在此之前在群里也吼了好多~╮(╯▽╰)╭~回去洗个澡~睡个觉明天的太阳依旧灿烂~一个掉渣的二本院校的技术屌丝男的小逆袭？或许吧~]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>221</wp:post_id>
		<wp:post_date>2013-03-27 13:38:55</wp:post_date>
		<wp:post_date_gmt>2013-03-27 13:38:55</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e8%bf%99%e4%b8%89%e5%a4%a9</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>59</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>如何通过给MM修电脑培养感情</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=227</link>
		<pubDate>Thu, 28 Mar 2013 11:02:24 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=227</guid>
		<description></description>
		<content:encoded><![CDATA[在修之前，向 MM 反复声明，这电脑故障是有硬件和软件之分的，如果是硬件故障，例如显卡风扇不转了，显示器连线老化，显示器分辨率超出显示器指标，等等都会导致黑屏啊，这个我不回家用专门的工具是修不好的！

这样一旦真的没修好，就立刻耸肩膀作无奈装：真的是硬件问题，还是送去保修吧。而 MM 当作硬件问题去保修，JS 大人即使发现是软件问题，也会毫不犹豫作为硬件问题处理，所以决计不会有败露的麻烦。

<strong>表演篇（中） – 不管问题一律重装系统！</strong>

不管发生什么，只要 MM 同意，一律重装系统！这是最简单的方法，虽然很菜。但是如果要感动 MM，这也是最好的方法，因为 MM 会在漫长的等待中觉得你真是很有耐心和爱心的好男人！哈哈哈哈，太阴险了，所以给恐龙修电脑，一般还是对症下药，速战速决，确实当恐龙看上你的时候，你就 知道这不是 RPWT，而是生命问题！

<strong>表演篇（下） – 关心 MM 要体现在细节！</strong>

如果选择重装，一定要反复问 MM：真的可以吗？MM 第一遍一般就说可以，这时候要问：没有重要的照片、文档吗？MM 会犹豫，但是还是会说不要好了；这时候接着问：QQ 聊天记录也会丢掉的！MM 会说不要了；记着这时要作思考状，然后问：有没有重要的邮件啊，邮件也会丢掉的。一般啊，很多 MM 这个时候会反悔，她们就会觉得你是超级贴心人了。

如果选择打开机箱，一定要作惊讶状！怎么这么多灰尘啊！！！（我只见过一个 MM 的机箱里没有灰尘的，她是实在太爱干净了）这时候 MM 一般都会不知道怎么回答，你立刻要作出为电脑难过的样子：这么好的电脑，灰尘太多怎么跑得快啊，散热也会受影响的，当然容易出问题了。哈哈哈哈，MM 内疚的同时就会觉得你这个人特别懂得爱惜珍惜疼惜是新好男人。

<strong>技术篇（上） – MM 电脑出的通常都是弱智问题</strong>

所以不要用特别专业的眼光去分析，一般都是系统设置没设置好，例如曾经一个 MM，帮她新配的电脑，说音箱左边的不响，过去检查，果然不响，怎么调都只有电流声，心想坏了，买到坏的了，结果不死心一看，音量控制里她全搁到右声道了，昏死！

对于显示屏黑屏这种事情，要多看看显示器开关有没有开，显示器有没有插上电源，显示器线有没有连到主机等等问题！

稍微高级一点，看看 BIOS 设定，显示器分辨率设定，对比度设定等等再高级一点，看看是不是显卡风扇停转了在有别的电脑的情况下，和别的电脑对调一下显示器看看，容易分辨是不是显示器的问题。

但是要注意，要是女生寝室的话，慎用！！！因为女生寝室一般好像关系都不好，就是好也不愿意为别人的电脑奉献自己的电脑，这一点和男生寝室不一样，要鄙视一下！要想帅，带上可以外接显示器的本本去，要轻薄的，2.3kg 以上就不要驮过去丢脸了。

<strong>技术篇（中） – 要想 MM 崇拜请务必拆机箱</strong>

不管是不是硬件问题，如果你想 MM 崇拜到要嫁给你的地步，记住一定要带上一根较大的十字起子，推荐电脑城装机的那种，很长很长的，超帅！我一般带上两根，一个十字头，一个一字头，一个红色 有机玻璃柄，一个绿色玻璃柄，就像两把短剑，有了这两柄利器，感觉立马不一样！MM 立刻觉得你就是专业的，如果 MM 看到后觉得害怕，别忘趁势解释一句：修的多了，随身带着方便，你的问题不一定那么大，或许用不上。MM 这个时候只会希望自己的电脑坏的彻底一点，好见识你挥动长剑的潇洒身姿！哈哈哈哈，这句是丫丫而已。

<strong>技术篇（下） – 熟练掌握 BIOS 的窍门是看说明书</strong>

其实很多时候问题和解决问题的方法都在 BIOS 设定上，例如必须掌握的光驱启动，就在 BIOS 设定里面，这个时候万一忘记了怎么办，求助于说明书吧！！！其实在说明书中，一般都有详尽的说明，甚至包括常见问题的解决方法，只是 MM 们比较娇嫩，不适宜阅读这么生硬的文字罢了你的责任就是阅读它们！！！

不要觉得临时看说明书很丢脸！如果说拆机箱可以展现你武的一面，那么你专注阅读的神情正是你展现自己文的一面最好机会！！！能文能武才是你获取 MM 芳心的致胜法宝，只知道挥着袖子与主板上的灰尘大战的土匪只会让 MM 觉得这些喜欢硬件的 GG 都是脏兮兮的疯子。

而你要求获得主板、显卡及其他相关说明书最好的方法，要么就是一开始索要，一进门就让她把她放这些东西的盒子搬出来放好；要么就是拆开机箱以 后，惊讶一句：啊！这不是公版设计，我要看一下出厂时的说明书！！！甭管是什么设计，你这一句话出去，MM 只会觉得你暴有水准，一眼就能看出是什么设计，其实她们也不知道什么叫公版设计母版设计的。

<img title="repair computer" src="http://images.cnitblog.com/news/66372/201303/28121507-7cea73a0483d499db9eaacdca1e45a05.jpg" alt="repair computer" width="578" height="368" />

<strong>感情篇（上） – MM 的电脑永远都是最好的</strong>

MM 一般最要面子，但是找你修电脑总是电脑出了问题，所以你这个时候一定不能在伤口上散盐，切忌在修电脑的时候说：啊这种配置啊，该升级了。或者：这种杂牌的 显卡最好不要用。或者：XXX 的显示器最烂了。表以为这样可以显示你对硬件市场品牌的了解和个人的品位，这只会让 MM 恨死你！早期我就犯过类似口不遮拦的错误，结果有一段时间 MM 们电脑坏了也不敢来找我，唉，前车之鉴啊！

对于 MM 的电脑，如果牌子好，哪怕是集成主板，也要说这个牌子我最喜欢了，稳定性超好，这次多半是软件问题，D版毛病就是多！（甭管她机子装的系统是不是正版，用 的软件总有盗版吧）如果牌子不好，立刻说，这个牌子性价比一直就是最好的，你真会过日子！不要忘记说“你真会过日子”的时候，一定要注视 MM 面带百分百诚恳的微笑！！！如果真的什么都不行，就是完全该被淘汰的机子，尽量就不要说话了！！！说什么只会让场面更难堪！！！ 把电脑当作 MM 的脸，你就知道该怎么做了！

<strong>感情篇（中） – 准确把握时间营造相遇空间</strong>

一般 MM 让你修电脑，如果答谢的话，一般都是请你吃饭，如果她请你吃饭的规格远远超过正常修电脑的花费，不妨检查一下电脑是否有人为破坏的因素对于不同的 MM，土匪当然是有的求之不得，有的避之不及因而准确控制维修过程的时间就很重要。这里教初学者一些计算时间的方法：

用 GHOST 装一个 XP 系统，一般是 25 分钟左右（如果你很熟练，20 分钟内就够了）用自动方式装一个 XP 系统，大约是 1 个小时（具体没算过，如果是烂威盛主板，装好驱动还不止）装一个 OFFICE，大约还是要半个小时（这个可以在自定义里中选择，想拖延时间就全选，大概可以多争取半小时）时间还不到吃饭时间，或者时间到了吃饭时间但是 你不想去，都可以通过装软件来慢慢消耗，实在不行，就卸载了多装几遍！

当你长年累月修电脑产生厌烦心理时，推荐使用市面上的高度集成版的 XP 的 GHOST 版，一次把乱七八糟的软件都给装上了，整个时间和装一个 XP 干净系统也差不多，装完就走人。

<strong>感情篇（下） – 通过修电脑检验 MM 人品的方法</strong>

实际上利用修电脑这一机会来泡 MM 的土匪，一般平时都是花了较多时间陪着自己的电脑和网友，没有太多时间和固定场所（例如大学自修室、英语角或者公共社交场所）接触真实 MM 的人。很多这方面的高手也都是成功地在修好电脑的同时弥补了自己姻缘的缺憾，顺利找到另一半！但是并不是所有的相遇都是美满的结局，这除了土匪个人的 RPWT，主要还在于他们在修理电脑的时候没有注意 MM 们的 RPWT。给出一些个人建议：

如果 MM 只会站在一边看着你修，连杯水都不给你倒，除非她年纪太小太不懂事，不然这样的 MM 基本不懂关心照顾别人，也不懂尊重别人的劳动和付出。这样的 MM 若不是超级大美女，还是算了！

如果 MM 会一直问这问那，特别是如果主要问你为什么要这样修的原因，这种 MM 不够重视分工，喜欢主导一切，不能够尊重权威和相信理性，娶回家只会让你多一个唠唠叨叨的监工。如果你不喜欢被人呼来唤去，没有自疟倾向，这种 MM 还是算了！

如果 MM 一直问你要不要喝水，要不要歇一会儿，还问一些和修电脑无关的情况，例如问你这么好的技术都怎么学来的啊，如果殷勤到一反常态的地步，恭喜你！这个 MM 想泡你！！！如果这个 MM 一贯对人热情，那么这种 MM 属于擅长公关，有很强的管理和组织能力，这种 MM 也会成为未来家中的主管，但是好在是一种以人为本的管理，你不至于太痛苦这样的 MM，只要平时不是那种过分往上爬巴结领导的类型，实际上还算不错的选择。

如果 MM 话并不多，默默地给你倒杯水，然后再一旁看着，不时跑过来帮你递东西，这种是贤妻良母型，是那种甘愿在背后默默支持你的类型，你要是事业主导型的土匪，毫不犹豫泡这个 MM 吧！！！极品赞不绝口。（就是恐龙也不妨考虑一下）

如果 MM 给你东西吃，证明对你不见外；从来没见过的 MM 话，证明对你很有好感！小子，你赚了！

MM 站着看你修电脑，有座位不坐，离得近的是关心电脑！离得远的还站着，如果不是眼睛超好的那种，这种 MM 有同甘共苦的意识，一般富有同情心，比较爱国（自己到时候对照一下）

MM 坐着看你修电脑，正常；MM 坐着但是不看你，眼光会游移到别的地方或者做自己的小动作，死了心吧！她已经有意中人了！

MM 躺着看你修电脑（还真的有！）遇到的都是和我太熟悉的才这样！第一次就这样没遇到过，真有的话，就是 RPWT！！！

MM 在你修电脑的时候去洗澡了（遇到一次！）这个 MM 如果不是三天没洗澡，那就是把你当成家人看待了，我觉得关系很熟这样的话就不算什么；如果第一次就这样，建议逃走或者躺下！！！

MM 修电脑的时候把父母介绍给你（到她家修电脑）或者给你看她存在电脑上家人的照片，她很希望成为你重要的朋友。

MM 修电脑的时候把 MM 介绍给你，电脑其实没问题，这个 MM 觉得你人不错，肥水不流外人田，便宜自己的姐妹先。或者她姐妹最近刚失恋，需要找个凯子过渡一下。
<div id="up_down">
<div id="digg_tip"></div>
</div>
<div id="come_from">来自: <a id="link_source2" href="http://bbs.whnet.edu.cn" target="_blank">bbs.whnet.edu.cn</a></div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>227</wp:post_id>
		<wp:post_date>2013-03-28 11:02:24</wp:post_date>
		<wp:post_date_gmt>2013-03-28 11:02:24</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%a6%82%e4%bd%95%e9%80%9a%e8%bf%87%e7%bb%99mm%e4%bf%ae%e7%94%b5%e8%84%91%e5%9f%b9%e5%85%bb%e6%84%9f%e6%83%85</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>72</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>闲扯与喷火</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=230</link>
		<pubDate>Sun, 31 Mar 2013 12:29:32 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=230</guid>
		<description></description>
		<content:encoded><![CDATA[╮(╯▽╰)╭~前段日子跟人闲扯研发与开发~扯着扯，扯出了一些：
开发与研发，前者是工程派，后者是理论派，后者太过于看重理论基础的东西，两者都重要。从商业的角度来说，前者重要，从研究的角度来说，后者重要。单本质还是工程带动研发，研发补充开发。上层框架的设计比纯做理论的要复杂得多，他们构造的是一个生态系统，例如：操作系统,1+1&lt;2.研发解决现有的技术解决不了的问题，开发是利用现有的技术解决现实的问题，但是研发总能解决。开发能够提出研发的课题，研发完了，再回归开发，就好比开发调用研发这个函数。开发与研发就好比cpu和主板，哪个不行都不行~

从大一下开始接触开源，现在想喷喷火~是有关技术的~不要用鄙视的目光看待其它东西

1. 能在最快时间创造最高价值的东西，就是好的；
2. 技术是用来做产品的，不是耍酷的，需求至上。

GCC+VIM+GDB+MAKEFILE无敌最能学到东西,理解了编译的过程,挺重要的。其实不一定啦连编译过程也要费脑子纯粹是没事找事（VS,VC6把makefile整合了挺好）。玩了两三天的linux/unix就装B的，就好像 mysql用户 看不起 Sqlserver用户 ，以为用两天linux，就觉得自己牛逼哄哄的，到处鄙视 Windows； 接触了两天开源就觉得用微软产品的人**，自己多么高尚。如果你花5年，10年，20年来深入Linux，你再来鄙视微软的东西，我不会说什么，可是大部 分用了没有5个月，就开始装B，其实TM毛都不会。天天吹 GCC+VIM+GDB+MAKEFILE多么牛逼的同时，自己TM纯粹不写程序的人大有人在

玩linux/unix的菜鸟现在还是装X windows的居多，但这算什么呢~Mac和windows的GUI对用户才是最有亲和力的~尽管现在的ubuntu在X windwos方面做得不错~学linux/unix首先会先恨它才能爱上它]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>230</wp:post_id>
		<wp:post_date>2013-03-31 12:29:32</wp:post_date>
		<wp:post_date_gmt>2013-03-31 12:29:32</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e9%97%b2%e6%89%af%e4%b8%8e%e5%96%b7%e7%81%ab</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>32</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Linux系统调用列表</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=232</link>
		<pubDate>Wed, 03 Apr 2013 10:19:52 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=232</guid>
		<description></description>
		<content:encoded><![CDATA[<div id="cnblogs_post_body">

以下是Linux系统调用的一个列表，包含了大部分常用系统调用和由系统调用派生出的的函数。这可能是你在互联网上所能看到的唯一一篇中文注释的Linux系统调用列表，即使是简单的字母序英文列表，能做到这么完全也是很罕见的。

按照惯例，这个列表以man pages第2节，即系统调用节为蓝本。按照笔者的理解，对其作了大致的分类，同时也作了一些小小的修改，删去了几个仅供内核使用，不允许用户调用的系统调用，对个别本人稍觉不妥的地方作了一些小的修改，并对所有列出的系统调用附上简要注释。

其中有一些函数的作用完全相同，只是参数不同。（可能很多熟悉C++朋友马上就能联想起函数重载，但是别忘了Linux核心是用C语言写的，所以只 能取成不同的函数名）。还有一些函数已经过时，被新的更好的函数所代替了（gcc在链接这些函数时会发出警告），但因为兼容的原因还保留着，这些函数我会 在前面标上“*”号以示区别。
<h1><a name="1"></a><strong>一、进程控制：</strong></h1>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">fork</td>
<td>创建一个新进程</td>
</tr>
<tr>
<td>clone</td>
<td>按指定条件创建子进程</td>
</tr>
<tr>
<td>execve</td>
<td>运行可执行文件</td>
</tr>
<tr>
<td>exit</td>
<td>中止进程</td>
</tr>
<tr>
<td>_exit</td>
<td>立即中止当前进程</td>
</tr>
<tr>
<td>getdtablesize</td>
<td>进程所能打开的最大文件数</td>
</tr>
<tr>
<td>getpgid</td>
<td>获取指定进程组标识号</td>
</tr>
<tr>
<td>setpgid</td>
<td>设置指定进程组标志号</td>
</tr>
<tr>
<td>getpgrp</td>
<td>获取当前进程组标识号</td>
</tr>
<tr>
<td>setpgrp</td>
<td>设置当前进程组标志号</td>
</tr>
<tr>
<td>getpid</td>
<td>获取进程标识号</td>
</tr>
<tr>
<td>getppid</td>
<td>获取父进程标识号</td>
</tr>
<tr>
<td>getpriority</td>
<td>获取调度优先级</td>
</tr>
<tr>
<td>setpriority</td>
<td>设置调度优先级</td>
</tr>
<tr>
<td>modify_ldt</td>
<td>读写进程的本地描述表</td>
</tr>
<tr>
<td>nanosleep</td>
<td>使进程睡眠指定的时间</td>
</tr>
<tr>
<td>nice</td>
<td>改变分时进程的优先级</td>
</tr>
<tr>
<td>pause</td>
<td>挂起进程，等待信号</td>
</tr>
<tr>
<td>personality</td>
<td>设置进程运行域</td>
</tr>
<tr>
<td>prctl</td>
<td>对进程进行特定操作</td>
</tr>
<tr>
<td>ptrace</td>
<td>进程跟踪</td>
</tr>
<tr>
<td>sched_get_priority_max</td>
<td>取得静态优先级的上限</td>
</tr>
<tr>
<td>sched_get_priority_min</td>
<td>取得静态优先级的下限</td>
</tr>
<tr>
<td>sched_getparam</td>
<td>取得进程的调度参数</td>
</tr>
<tr>
<td>sched_getscheduler</td>
<td>取得指定进程的调度策略</td>
</tr>
<tr>
<td>sched_rr_get_interval</td>
<td>取得按RR算法调度的实时进程的时间片长度</td>
</tr>
<tr>
<td>sched_setparam</td>
<td>设置进程的调度参数</td>
</tr>
<tr>
<td>sched_setscheduler</td>
<td>设置指定进程的调度策略和参数</td>
</tr>
<tr>
<td>sched_yield</td>
<td>进程主动让出处理器,并将自己等候调度队列队尾</td>
</tr>
<tr>
<td>vfork</td>
<td>创建一个子进程，以供执行新程序，常与execve等同时使用</td>
</tr>
<tr>
<td>wait</td>
<td>等待子进程终止</td>
</tr>
<tr>
<td>wait3</td>
<td>参见wait</td>
</tr>
<tr>
<td>waitpid</td>
<td>等待指定子进程终止</td>
</tr>
<tr>
<td>wait4</td>
<td>参见waitpid</td>
</tr>
<tr>
<td>capget</td>
<td>获取进程权限</td>
</tr>
<tr>
<td>capset</td>
<td>设置进程权限</td>
</tr>
<tr>
<td>getsid</td>
<td>获取会晤标识号</td>
</tr>
<tr>
<td>setsid</td>
<td>设置会晤标识号</td>
</tr>
</tbody>
</table>
&nbsp;
<h1><a name="2"></a><strong>二、文件系统控制</strong></h1>
<a name="N101B0"></a><strong>1、文件读写操作</strong>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">fcntl</td>
<td>文件控制</td>
</tr>
<tr>
<td>open</td>
<td>打开文件</td>
</tr>
<tr>
<td>creat</td>
<td>创建新文件</td>
</tr>
<tr>
<td>close</td>
<td>关闭文件描述字</td>
</tr>
<tr>
<td>read</td>
<td>读文件</td>
</tr>
<tr>
<td>write</td>
<td>写文件</td>
</tr>
<tr>
<td>readv</td>
<td>从文件读入数据到缓冲数组中</td>
</tr>
<tr>
<td>writev</td>
<td>将缓冲数组里的数据写入文件</td>
</tr>
<tr>
<td>pread</td>
<td>对文件随机读</td>
</tr>
<tr>
<td>pwrite</td>
<td>对文件随机写</td>
</tr>
<tr>
<td>lseek</td>
<td>移动文件指针</td>
</tr>
<tr>
<td>_llseek</td>
<td>在64位地址空间里移动文件指针</td>
</tr>
<tr>
<td>dup</td>
<td>复制已打开的文件描述字</td>
</tr>
<tr>
<td>dup2</td>
<td>按指定条件复制文件描述字</td>
</tr>
<tr>
<td>flock</td>
<td>文件加/解锁</td>
</tr>
<tr>
<td>poll</td>
<td>I/O多路转换</td>
</tr>
<tr>
<td>truncate</td>
<td>截断文件</td>
</tr>
<tr>
<td>ftruncate</td>
<td>参见truncate</td>
</tr>
<tr>
<td>umask</td>
<td>设置文件权限掩码</td>
</tr>
<tr>
<td>fsync</td>
<td>把文件在内存中的部分写回磁盘</td>
</tr>
</tbody>
</table>
<a name="N10279"></a><strong>2、文件系统操作</strong>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">access</td>
<td>确定文件的可存取性</td>
</tr>
<tr>
<td>chdir</td>
<td>改变当前工作目录</td>
</tr>
<tr>
<td>fchdir</td>
<td>参见chdir</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件方式</td>
</tr>
<tr>
<td>fchmod</td>
<td>参见chmod</td>
</tr>
<tr>
<td>chown</td>
<td>改变文件的属主或用户组</td>
</tr>
<tr>
<td>fchown</td>
<td>参见chown</td>
</tr>
<tr>
<td>lchown</td>
<td>参见chown</td>
</tr>
<tr>
<td>chroot</td>
<td>改变根目录</td>
</tr>
<tr>
<td>stat</td>
<td>取文件状态信息</td>
</tr>
<tr>
<td>lstat</td>
<td>参见stat</td>
</tr>
<tr>
<td>fstat</td>
<td>参见stat</td>
</tr>
<tr>
<td>statfs</td>
<td>取文件系统信息</td>
</tr>
<tr>
<td>fstatfs</td>
<td>参见statfs</td>
</tr>
<tr>
<td>readdir</td>
<td>读取目录项</td>
</tr>
<tr>
<td>getdents</td>
<td>读取目录项</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建目录</td>
</tr>
<tr>
<td>mknod</td>
<td>创建索引节点</td>
</tr>
<tr>
<td>rmdir</td>
<td>删除目录</td>
</tr>
<tr>
<td>rename</td>
<td>文件改名</td>
</tr>
<tr>
<td>link</td>
<td>创建链接</td>
</tr>
<tr>
<td>symlink</td>
<td>创建符号链接</td>
</tr>
<tr>
<td>unlink</td>
<td>删除链接</td>
</tr>
<tr>
<td>readlink</td>
<td>读符号链接的值</td>
</tr>
<tr>
<td>mount</td>
<td>安装文件系统</td>
</tr>
<tr>
<td>umount</td>
<td>卸下文件系统</td>
</tr>
<tr>
<td>ustat</td>
<td>取文件系统信息</td>
</tr>
<tr>
<td>utime</td>
<td>改变文件的访问修改时间</td>
</tr>
<tr>
<td>utimes</td>
<td>参见utime</td>
</tr>
<tr>
<td>quotactl</td>
<td>控制磁盘配额</td>
</tr>
</tbody>
</table>
&nbsp;
<h1><a name="3"></a><strong>三、系统控制</strong></h1>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">ioctl</td>
<td>I/O总控制函数</td>
</tr>
<tr>
<td>_sysctl</td>
<td>读/写系统参数</td>
</tr>
<tr>
<td>acct</td>
<td>启用或禁止进程记账</td>
</tr>
<tr>
<td>getrlimit</td>
<td>获取系统资源上限</td>
</tr>
<tr>
<td>setrlimit</td>
<td>设置系统资源上限</td>
</tr>
<tr>
<td>getrusage</td>
<td>获取系统资源使用情况</td>
</tr>
<tr>
<td>uselib</td>
<td>选择要使用的二进制函数库</td>
</tr>
<tr>
<td>ioperm</td>
<td>设置端口I/O权限</td>
</tr>
<tr>
<td>iopl</td>
<td>改变进程I/O权限级别</td>
</tr>
<tr>
<td>outb</td>
<td>低级端口操作</td>
</tr>
<tr>
<td>reboot</td>
<td>重新启动</td>
</tr>
<tr>
<td>swapon</td>
<td>打开交换文件和设备</td>
</tr>
<tr>
<td>swapoff</td>
<td>关闭交换文件和设备</td>
</tr>
<tr>
<td>bdflush</td>
<td>控制bdflush守护进程</td>
</tr>
<tr>
<td>sysfs</td>
<td>取核心支持的文件系统类型</td>
</tr>
<tr>
<td>sysinfo</td>
<td>取得系统信息</td>
</tr>
<tr>
<td>adjtimex</td>
<td>调整系统时钟</td>
</tr>
<tr>
<td>alarm</td>
<td>设置进程的闹钟</td>
</tr>
<tr>
<td>getitimer</td>
<td>获取计时器值</td>
</tr>
<tr>
<td>setitimer</td>
<td>设置计时器值</td>
</tr>
<tr>
<td>gettimeofday</td>
<td>取时间和时区</td>
</tr>
<tr>
<td>settimeofday</td>
<td>设置时间和时区</td>
</tr>
<tr>
<td>stime</td>
<td>设置系统日期和时间</td>
</tr>
<tr>
<td>time</td>
<td>取得系统时间</td>
</tr>
<tr>
<td>times</td>
<td>取进程运行时间</td>
</tr>
<tr>
<td>uname</td>
<td>获取当前UNIX系统的名称、版本和主机等信息</td>
</tr>
<tr>
<td>vhangup</td>
<td>挂起当前终端</td>
</tr>
<tr>
<td>nfsservctl</td>
<td>对NFS守护进程进行控制</td>
</tr>
<tr>
<td>vm86</td>
<td>进入模拟8086模式</td>
</tr>
<tr>
<td>create_module</td>
<td>创建可装载的模块项</td>
</tr>
<tr>
<td>delete_module</td>
<td>删除可装载的模块项</td>
</tr>
<tr>
<td>init_module</td>
<td>初始化模块</td>
</tr>
<tr>
<td>query_module</td>
<td>查询模块信息</td>
</tr>
<tr>
<td>*get_kernel_syms</td>
<td>取得核心符号,已被query_module代替</td>
</tr>
</tbody>
</table>
&nbsp;
<h1><a name="4"></a><strong>四、内存管理</strong></h1>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">brk</td>
<td>改变数据段空间的分配</td>
</tr>
<tr>
<td>sbrk</td>
<td>参见brk</td>
</tr>
<tr>
<td>mlock</td>
<td>内存页面加锁</td>
</tr>
<tr>
<td>munlock</td>
<td>内存页面解锁</td>
</tr>
<tr>
<td>mlockall</td>
<td>调用进程所有内存页面加锁</td>
</tr>
<tr>
<td>munlockall</td>
<td>调用进程所有内存页面解锁</td>
</tr>
<tr>
<td>mmap</td>
<td>映射虚拟内存页</td>
</tr>
<tr>
<td>munmap</td>
<td>去除内存页映射</td>
</tr>
<tr>
<td>mremap</td>
<td>重新映射虚拟内存地址</td>
</tr>
<tr>
<td>msync</td>
<td>将映射内存中的数据写回磁盘</td>
</tr>
<tr>
<td>mprotect</td>
<td>设置内存映像保护</td>
</tr>
<tr>
<td>getpagesize</td>
<td>获取页面大小</td>
</tr>
<tr>
<td>sync</td>
<td>将内存缓冲区数据写回硬盘</td>
</tr>
<tr>
<td>cacheflush</td>
<td>将指定缓冲区中的内容写回磁盘</td>
</tr>
</tbody>
</table>
&nbsp;
<h1><a name="5"></a><strong>五、网络管理</strong></h1>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">getdomainname</td>
<td>取域名</td>
</tr>
<tr>
<td>setdomainname</td>
<td>设置域名</td>
</tr>
<tr>
<td>gethostid</td>
<td>获取主机标识号</td>
</tr>
<tr>
<td>sethostid</td>
<td>设置主机标识号</td>
</tr>
<tr>
<td>gethostname</td>
<td>获取本主机名称</td>
</tr>
<tr>
<td>sethostname</td>
<td>设置主机名称</td>
</tr>
</tbody>
</table>
&nbsp;
<h1><a name="6"></a><strong>六、socket控制</strong></h1>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">socketcall</td>
<td>socket系统调用</td>
</tr>
<tr>
<td>socket</td>
<td>建立socket</td>
</tr>
<tr>
<td>bind</td>
<td>绑定socket到端口</td>
</tr>
<tr>
<td>connect</td>
<td>连接远程主机</td>
</tr>
<tr>
<td>accept</td>
<td>响应socket连接请求</td>
</tr>
<tr>
<td>send</td>
<td>通过socket发送信息</td>
</tr>
<tr>
<td>sendto</td>
<td>发送UDP信息</td>
</tr>
<tr>
<td>sendmsg</td>
<td>参见send</td>
</tr>
<tr>
<td>recv</td>
<td>通过socket接收信息</td>
</tr>
<tr>
<td>recvfrom</td>
<td>接收UDP信息</td>
</tr>
<tr>
<td>recvmsg</td>
<td>参见recv</td>
</tr>
<tr>
<td>listen</td>
<td>监听socket端口</td>
</tr>
<tr>
<td>select</td>
<td>对多路同步I/O进行轮询</td>
</tr>
<tr>
<td>shutdown</td>
<td>关闭socket上的连接</td>
</tr>
<tr>
<td>getsockname</td>
<td>取得本地socket名字</td>
</tr>
<tr>
<td>getpeername</td>
<td>获取通信对方的socket名字</td>
</tr>
<tr>
<td>getsockopt</td>
<td>取端口设置</td>
</tr>
<tr>
<td>setsockopt</td>
<td>设置端口参数</td>
</tr>
<tr>
<td>sendfile</td>
<td>在文件或端口间传输数据</td>
</tr>
<tr>
<td>socketpair</td>
<td>创建一对已联接的无名socket</td>
</tr>
</tbody>
</table>
<a name="7"></a>
<h1><strong>七、用户管理</strong></h1>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">getuid</td>
<td>获取用户标识号</td>
</tr>
<tr>
<td>setuid</td>
<td>设置用户标志号</td>
</tr>
<tr>
<td>getgid</td>
<td>获取组标识号</td>
</tr>
<tr>
<td>setgid</td>
<td>设置组标志号</td>
</tr>
<tr>
<td>getegid</td>
<td>获取有效组标识号</td>
</tr>
<tr>
<td>setegid</td>
<td>设置有效组标识号</td>
</tr>
<tr>
<td>geteuid</td>
<td>获取有效用户标识号</td>
</tr>
<tr>
<td>seteuid</td>
<td>设置有效用户标识号</td>
</tr>
<tr>
<td>setregid</td>
<td>分别设置真实和有效的的组标识号</td>
</tr>
<tr>
<td>setreuid</td>
<td>分别设置真实和有效的用户标识号</td>
</tr>
<tr>
<td>getresgid</td>
<td>分别获取真实的,有效的和保存过的组标识号</td>
</tr>
<tr>
<td>setresgid</td>
<td>分别设置真实的,有效的和保存过的组标识号</td>
</tr>
<tr>
<td>getresuid</td>
<td>分别获取真实的,有效的和保存过的用户标识号</td>
</tr>
<tr>
<td>setresuid</td>
<td>分别设置真实的,有效的和保存过的用户标识号</td>
</tr>
<tr>
<td>setfsgid</td>
<td>设置文件系统检查时使用的组标识号</td>
</tr>
<tr>
<td>setfsuid</td>
<td>设置文件系统检查时使用的用户标识号</td>
</tr>
<tr>
<td>getgroups</td>
<td>获取后补组标志清单</td>
</tr>
<tr>
<td>setgroups</td>
<td>设置后补组标志清单</td>
</tr>
</tbody>
</table>
&nbsp;
<h1><a name="8"></a><strong>八、进程间通信</strong></h1>
<strong> </strong>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">ipc</td>
<td>进程间通信总控制调用</td>
</tr>
</tbody>
</table>
<a name="N10759"></a><strong>1、信号</strong>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">sigaction</td>
<td>设置对指定信号的处理方法</td>
</tr>
<tr>
<td>sigprocmask</td>
<td>根据参数对信号集中的信号执行阻塞/解除阻塞等操作</td>
</tr>
<tr>
<td>sigpending</td>
<td>为指定的被阻塞信号设置队列</td>
</tr>
<tr>
<td>sigsuspend</td>
<td>挂起进程等待特定信号</td>
</tr>
<tr>
<td>signal</td>
<td>参见signal</td>
</tr>
<tr>
<td>kill</td>
<td>向进程或进程组发信号</td>
</tr>
<tr>
<td>*sigblock</td>
<td>向被阻塞信号掩码中添加信号,已被sigprocmask代替</td>
</tr>
<tr>
<td>*siggetmask</td>
<td>取得现有阻塞信号掩码,已被sigprocmask代替</td>
</tr>
<tr>
<td>*sigsetmask</td>
<td>用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替</td>
</tr>
<tr>
<td>*sigmask</td>
<td>将给定的信号转化为掩码,已被sigprocmask代替</td>
</tr>
<tr>
<td>*sigpause</td>
<td>作用同sigsuspend,已被sigsuspend代替</td>
</tr>
<tr>
<td>sigvec</td>
<td>为兼容BSD而设的信号处理函数,作用类似sigaction</td>
</tr>
<tr>
<td>ssetmask</td>
<td>ANSI C的信号处理函数,作用类似sigaction</td>
</tr>
</tbody>
</table>
<a name="N107E3"></a><strong>2、消息</strong>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">msgctl</td>
<td>消息控制操作</td>
</tr>
<tr>
<td>msgget</td>
<td>获取消息队列</td>
</tr>
<tr>
<td>msgsnd</td>
<td>发消息</td>
</tr>
<tr>
<td>msgrcv</td>
<td>取消息</td>
</tr>
</tbody>
</table>
<a name="N1081C"></a><strong>3、管道</strong>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">pipe</td>
<td>创建管道</td>
</tr>
</tbody>
</table>
<a name="N1083A"></a><strong>4、信号量</strong>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">semctl</td>
<td>信号量控制</td>
</tr>
<tr>
<td>semget</td>
<td>获取一组信号量</td>
</tr>
<tr>
<td>semop</td>
<td>信号量操作</td>
</tr>
</tbody>
</table>
<a name="N1086A"></a><strong>5、共享内存</strong>
<table border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30">shmctl</td>
<td>控制共享内存</td>
</tr>
<tr>
<td>shmget</td>
<td>获取共享内存</td>
</tr>
<tr>
<td>shmat</td>
<td>连接共享内存</td>
</tr>
<tr>
<td>shmdt</td>
<td>拆卸共享内存</td>
</tr>
</tbody>
</table>
&nbsp;

<a name="resources"></a>参考资料
<ul>
	<li>Linux man pages</li>
	<li>Advanced Programming in the UNIX Environment, W. Richard Stevens, 1993</li>
</ul>
&nbsp;

转自:<a href="http://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html">http://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html</a>

</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>232</wp:post_id>
		<wp:post_date>2013-04-03 10:19:52</wp:post_date>
		<wp:post_date_gmt>2013-04-03 10:19:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>linux%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e5%88%97%e8%a1%a8</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>72</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Linux 内核启动流程(转)</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=235</link>
		<pubDate>Wed, 03 Apr 2013 11:10:40 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=235</guid>
		<description></description>
		<content:encoded><![CDATA[<div id="cnblogs_post_body">
<h2><strong>启动流程一览</strong></h2>
<div>

既然启动是很严肃的一件事，那我们就来了解一下整个启动的过程吧！ 好让大家比较容易发现启动过程里面可能会发生问题的地方，以及出现问题后的解决之道！ 不过，由於启动的过程中，那个启动管理程序 (Boot Loader) 使用的软件可能不一样，例如目前各大 Linux distributions 的主流为 grub，但早期 Linux 默认是使用 LILO 。 但无论如何，我们总是得要了解整个 boot loader 的工作情况，才能了解为何进行多重启动的配置时， 老是听人家讲要先安装 Windows 再安装 Linux 的原因～

假设以个人计算机架设的 Linux 主机为例 ， 当你按下电源按键后计算机硬件会主动的读取 BIOS 来加载硬件资讯及进行硬件系统的自我测试， 之后系统会主动的去读取第一个可启动的装置 (由 BIOS 配置的) ，此时就可以读入启动管理程序了。

启动管理程序可以指定使用哪个核心文件来启动，并实际加载核心到内存当中解压缩与运行， 此时核心就能够开始在内存内活动，并侦测所有硬件资讯与加载适当的驱动程序来使整部主机开始运行， 等到核心侦测硬件与加载驱动程序完毕后，一个最阳春的操作系统就开始在你的 PC 上面跑了。

主机系统开始运行后，此时 Linux 才会呼叫外部程序开始准备软件运行的环境， 并且实际的加载所有系统运行所需要的软件程序哩！最后系统就会开始等待你的登陆与操作啦！ 简单来说，系统启动的经过可以汇整成底下的流程的：
<ol>
	<li>加载 BIOS 的硬件资讯与进行自我测试，并依据配置取得第一个可启动的装置；</li>
	<li>读取并运行第一个启动装置内 MBR 的 boot Loader (亦即是 grub, spfdisk 等程序)；</li>
	<li>依据 boot loader 的配置加载 Kernel ，Kernel 会开始侦测硬件与加载驱动程序；</li>
</ol>
<h2><strong>BIOS, 启动自我测试与 MBR</strong></h2>
在个人计算机架构下，你想要启动整部系统首先就得要让系统去加载 BIOS (Basic Input Output System)，并透过 BIOS 程序去加载 CMOS 的资讯，并且藉由 CMOS 内的配置值取得主机的各项硬件配置， 例如 CPU 与周边设备的沟通时脉啊、启动装置的搜寻顺序啊、硬盘的大小与类型啊、 系统时间啊、各周边汇流排的是否启动 Plug and Play (PnP, 随插即用装置) 啊、 各周边设备的 I/O 位址啊、以及与 CPU 沟通的 IRQ 岔断等等的资讯。

在取得这些资讯后，BIOS 还会进行启动自我测试 (Power-on Self Test, POST) 。 然后开始运行硬件侦测的初始化，并配置 PnP 装置，之后再定义出可启动的装置顺序， 接下来就会开始进行启动装置的数据读取了 (MBR 相关的任务开始)。

由於我们的系统软件大多放置到硬盘中嘛！所以 BIOS 会指定启动的装置好让我们可以读取磁碟中的操作系统核心文件。 但由於不同的操作系统他的文件系统格式不相同，因此我们必须要以一个启动管理程序来处理核心文件加载 (load) 的问题， 因此这个启动管理程序就被称为 Boot Loader 了。那这个 Boot Loader 程序安装在哪里呢？就在启动装置的第一个磁区 (sector) 内，也就是我们一直谈到的 MBR (Master Boot Record, 主要启动记录区)。

那你会不会觉得很奇怪啊？既然核心文件需要 loader 来读取，那每个操作系统的 loader 都不相同， 这样的话 BIOS 又是如何读取 MBR 内的 loader 呢？很有趣的问题吧！其实 BIOS 是透过硬件的 INT 13 中断功能来读取 MBR 的，也就是说，只要 BIOS 能够侦测的到你的磁碟 (不论该磁碟是 SATA 还是 IDE 介面)，那他就有办法透过 INT 13 这条通道来读取该磁碟的第一个磁区内的 MBR 啦！这样 boot loader 也就能够被运行罗！

我们知道每颗硬盘的第一个磁区内含有 446 bytes的 MBR 区域，那么如果我的主机上面有两颗硬盘的话， 系统会去哪颗硬盘的 MBR 读取 boot loader 呢？这个就得要看 BIOS 的配置了。 基本上，我们常常讲的『系统的 MBR』其实指的是 第一个启动装置的 MBR 才对！ 所以，改天如果你要将启动管理程序安装到某颗硬盘的 MBR 时， 要特别注意当时系统的『第一个启动装置』是哪个，否则会安装到错误的硬盘上面的 MBR 喔！
<div align="right"></div>
<h2 align="right"><strong>Boot Loader</strong></h2>
<div align="right">

刚刚说到 Loader 的最主要功能是要认识操作系统的文件格式并据以加载核心到主内存中去运行。 由於不同操作系统的文件格式不一致，因此每种操作系统都有自己的 boot loader 啦！用自己的 loader 才有办法加载核心文件嘛！那问题就来啦，你应该有听说过多重操作系统吧？也就是在一部主机上面安装多种不同的操作系统。 既然你 (1)必须要使用自己的 loader 才能够加载属於自己的操作系统核心，而 (2)系统的 MBR 只有一个，那你怎么会有办法同时在一部主机上面安装 Windows 与 Linux 呢？

其实每个文件系统 (filesystem, 或者是 partition) 都会保留一块启动磁区 (boot sector) 提供操作系统安装 boot loader ， 而通常操作系统默认都会安装一份 loader 到他根目录所在的文件系统的 boot sector 上。如果我们在一部主机上面安装 Windows 与 Linux 后，该 boot sector, boot loader 与 MBR 的相关性会有点像下图：

<center><img src="http://pic002.cnblogs.com/images/2012/360373/2012101315292941.gif" alt="" />
图 1.2.1、 boot loader 安装在 MBR, boot sector 与操作系统的关系</center>如上图所示，每个操作系统默认是会安装一套 boot loader 到他自己的文件系统中 (就是每个 filesystem 左下角的方框)，而在 Linux 系统安装时，你可以选择将 boot loader 安装到 MBR 去，也可以选择不安装。 如果选择安装到 MBR 的话，那理论上你在 MBR 与 boot sector 都会保有一份 boot loader 程序的。 至於 Windows 安装时，他默认会主动的将 MBR 与 boot sector 都装上一份 boot loader！所以啦， 你会发现安装多重操作系统时，你的 MBR 常常会被不同的操作系统的 boot loader 所覆盖啦！ ^_^

我们刚刚提到的两个问题还是没有解决啊！虽然各个操作系统都可以安装一份 boot loader 到他们的 boot sector 中， 这样操作系统可以透过自己的 boot loader 来加载核心了。问题是系统的 MBR 只有一个哩！ 你要怎么运行 boot sector 里面的 loader 啊？

boot loader 主要的功能如下：
<ul>
	<li><strong>提供菜单</strong>：使用者可以选择不同的启动项目，这也是多重启动的重要功能！</li>
	<li><strong>加载核心文件</strong>：直接指向可启动的程序区段来开始操作系统；</li>
	<li><strong>转交其他 loader</strong>：将启动管理功能转交给其他 loader 负责。</li>
</ul>
由於具有菜单功能，因此我们可以选择不同的核心来启动。而由於具有控制权转交的功能，因此我们可以加载其他 boot sector 内的 loader 啦！不过 Windows 的 loader 默认不具有控制权转交的功能，因此你不能使用 Windows 的 loader 来加载 Linux 的 loader 喔！这也是为啥第三章谈到 MBR 与多重启动时，会特别强调先装 Windows 再装 Linux 的缘故。 我们将上述的三个功能以底下的图示来解释你就看的懂了！(与第三章的图示也非常类似啦！)

<center><img src="http://pic002.cnblogs.com/images/2012/360373/2012101315294418.gif" alt="" />
图 1.2.2、 启动管理程序的菜单功能与控制权转交功能示意图</center>如上图所示，我的 MBR 使用 Linux 的 grub 这个启动管理程序，并且里面假设已经有了三个菜单， 第一个菜单可以直接指向 Linux 的核心文件并且直接加载核心来启动；第二个菜单可以将启动管理程序控制权交给 Windows 来管理，此时 Windows 的 loader 会接管启动流程，这个时候他就能够启动 windows 了。第三个菜单则是使用 Linux 在 boot sector 内的启动管理程序，此时就会跳出另一个 grub 的菜单啦！了解了吗？

而最终 boot loader 的功能就是『加载 kernel 文件』啦！

&nbsp;
<h2><strong>加载核心侦测硬件与 initrd</strong></h2>
当我们藉由 boot loader 的管理而开始读取核心文件后，接下来， Linux 就会将核心解压缩到主内存当中， 并且利用核心的功能，开始测试与驱动各个周边装置，包括储存装置、CPU、网络卡、声卡等等。 此时 Linux 核心会以自己的功能重新侦测一次硬件，而不一定会使用 BIOS 侦测到的硬件资讯喔！也就是说，核心此时才开始接管 BIOS 后的工作了。 那么核心文件在哪里啊？一般来说，他会被放置到 /boot 里面，并且取名为 /boot/vmlinuz 才对！
<div>
<pre>[root@www ~]# ls --format=single-column -F /boot
config-2.6.18-92.el5      &lt;==此版本核心被编译时选择的功能与模块配置档
grub/                     &lt;==就是启动管理程序 grub 相关数据目录
initrd-2.6.18-92.el5.img  &lt;==虚拟文件系统档！
System.map-2.6.18-92.el5  &lt;==核心功能放置到内存位址的对应表
vmlinuz-2.6.18-92.el5     &lt;==就是核心文件啦！最重要者！</pre>
</div>
从上表我们也可以知道此版本的 Linux 核心为 2.6.18-92.el5 这个版本！为了硬件开发商与其他核心功能开发者的便利， 因此 Linux 核心是可以透过动态加载核心模块的 (就请想成驱动程序即可)，这些核心模块就放置在 /lib/modules/ 目录内。 由于模块放置到磁盘根目录内 (要记得 /lib 不可以与 / 分别放在不同的 partition ！)， 因此在启动的过程中核心必须要挂载根目录，这样才能够读取核心模块提供加载驱动程序的功能。 而且为了担心影响到磁碟内的文件系统，因此启动过程中根目录是以唯读的方式来挂载的喔。

一般来说，非必要的功能且可以编译成为模块的核心功能，目前的 Linux distributions 都会将他编译成为模块。 因此 U盘, SATA, SCSI... 等磁碟装置的驱动程序通常都是以模块的方式来存在的。 现在来思考一种情况，假设你的 linux 是安装在 SATA 磁碟上面的，你可以透过 BIOS 的 INT 13 取得 boot loader 与 kernel 文件来启动，然后 kernel 会开始接管系统并且侦测硬件及尝试挂载根目录来取得额外的驱动程序。

&nbsp;

问题是，核心根本不认识 SATA 磁碟，所以需要加载 SATA 磁碟的驱动程序， 否则根本就无法挂载根目录。但是 SATA 的驱动程序在 /lib/modules 内，你根本无法挂载根目录又怎么读取到 /lib/modules/ 内的驱动程序？是吧！非常的两难吧！在这个情况之下，你的 Linux 是无法顺利启动的！ 那怎办？没关系，我们可以透过虚拟文件系统来处理这个问题。

虚拟文件系统 (Initial RAM Disk) 一般使用的档名为 /boot/initrd ，这个文件的特色是，他也能够透过 boot loader 来加载到内存中， 然后这个文件会被解压缩并且在内存当中模拟成一个根目录， 且此模拟在内存当中的文件系统能够提供一支可运行的程序，透过该程序来加载启动过程中所最需要的核心模块， 通常这些模块就是 U盘, RAID, LVM, SCSI 等文件系统与磁碟介面的驱动程序啦！等加载完成后， 会帮助核心重新呼叫 /sbin/init 来开始后续的正常启动流程。

<img src="http://pic002.cnblogs.com/images/2012/360373/2012101315301471.jpg" alt="" />

如上图所示，boot loader 可以加载 kernel 与 initrd ，然后在内存中让 initrd 解压缩成为根目录， kernel 就能够藉此加载适当的驱动程序，最终释放虚拟文件系统，并挂载实际的根目录文件系统， 就能够开始后续的正常启动流程。更详细的 initrd 说明，你可以自行使用 man initrd 去查阅看看。 底下让我们来了解一下 CentOS 5.x 的 initrd 文件内容有什么吧！
<div>
<div><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></div>
<pre># 1. 先将 /boot/initrd 复制到 /tmp/initrd 目录中，等待解压缩：
[root@www ~]# mkdir /tmp/initrd
[root@www ~]# cp /boot/initrd-2.6.18-92.el5.img /tmp/initrd/
[root@www ~]# cd /tmp/initrd
[root@www initrd]# file initrd-2.6.18-92.el5.img
initrd-2.6.18-92.el5.img: gzip compressed data, ...
# 原来是 gzip 的压缩档！因为是 gzip ，所以扩展名给他改成 .gz 吧！

# 2. 将上述的文件解压缩：
[root@www initrd]# mv initrd-2.6.18-92.el5.img initrd-2.6.18-92.el5.gz
[root@www initrd]# gzip -d initrd-2.6.18-92.el5.gz
[root@www initrd]# file initrd-2.6.18-92.el5
initrd-2.6.18-92.el5: ASCII cpio archive (SVR4 with no CRC)
# 搞了老半天，原来还是 cpio 的命令压缩成的文件啊！解压缩看看！

# 3. 用 cpio 解压缩
[root@www initrd]# cpio -ivcdu &lt; initrd-2.6.18-92.el5
[root@www initrd]# ll
drwx------ 2 root root    4096 Apr 10 02:05 bin
drwx------ 3 root root    4096 Apr 10 02:05 dev
drwx------ 2 root root    4096 Apr 10 02:05 etc
-rwx------ 1 root root    1888 Apr 10 02:05 init
-rw------- 1 root root 5408768 Apr 10 02:00 initrd-2.6.18-92.el5
drwx------ 3 root root    4096 Apr 10 02:05 lib
drwx------ 2 root root    4096 Apr 10 02:05 proc
lrwxrwxrwx 1 root root       3 Apr 10 02:05 sbin -&gt; bin
drwx------ 2 root root    4096 Apr 10 02:05 sys
drwx------ 2 root root    4096 Apr 10 02:05 sysroot
# 看！是否很像根目录！尤其也是有 init 这个运行档！务必看一下权限！
# 接下来看看 init 这个文件内有啥咚咚？

# 4. 观察 init 文件内较重要的运行项目
[root@www initrd]# cat init
#!/bin/nash                  &lt;==使用类似 bash 的 shell 来运行
mount -t proc /proc /proc    &lt;==挂载内存的虚拟文件系统
....(中间省略)....
echo Creating initial device nodes
mknod /dev/null c 1 3        &lt;==创建系统所需要的各项装置！
....(中间省略)....
echo "Loading ehci-hcd.ko module"
insmod /lib/ehci-hcd.ko      &lt;==加载各项核心模块，就是驱动程序！
....(中间省略)....
echo Creating root device.
mkrootdev -t ext3 -o defaults,ro hdc2 &lt;==尝试挂载根目录啦！
....(底下省略)....</pre>
<div><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></div>
</div>
透过上述运行档的内容，我们可以知道 initrd 有加载模块并且尝试挂载了虚拟文件系统。 接下来就能够顺利的运行啦！那么是否一定需要 initrd 呢？
<div>
<pre>是否没有 initrd 就无法顺利启动？
答：
不见得的！需要 initrd 最重要的原因是，当启动时无法挂载根目录的情况下， 此时就一定需要 initrd ，例如你的根目录在特殊的磁碟介面 (U盘, SATA, SCSI) ， 或者是你的文件系统较为特殊 (LVM, RAID) 等等，才会需要 initrd。

如果你的 Linux 是安装在 IDE 介面的磁碟上，并且使用默认的 ext2/ext3 文件系统， 那么不需要 initrd 也能够顺利的启动进入 Linux 的！</pre>
</div>
在核心完整的加载后，您的主机应该就开始正确的运行了

&nbsp;

转自 <a href="http://vbird.dic.ksu.edu.tw/linux_basic/0510osloader_1.php">http://vbird.dic.ksu.edu.tw/linux_basic/0510osloader_1.php</a>

</div>
</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>235</wp:post_id>
		<wp:post_date>2013-04-03 11:10:40</wp:post_date>
		<wp:post_date_gmt>2013-04-03 11:10:40</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>linux-%e5%86%85%e6%a0%b8%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b%e8%bd%ac</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>72</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>shell</title>
		<link>http://10.131.10.73/mdk-vimer/?p=6</link>
		<pubDate>Sun, 18 Nov 2012 05:09:58 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?p=6</guid>
		<description></description>
		<content:encoded><![CDATA[here is a shell world!!!for a vimer and linuxer!!!!]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>6</wp:post_id>
		<wp:post_date>2012-11-18 05:09:58</wp:post_date>
		<wp:post_date_gmt>2012-11-18 05:09:58</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>shell</wp:post_name>
		<wp:status>draft</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>自己的博客我做主!!!</title>
		<link>http://10.131.10.73/mdk-vimer/?p=12</link>
		<pubDate>Sun, 18 Nov 2012 05:18:10 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?p=12</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>12</wp:post_id>
		<wp:post_date>2012-11-18 05:18:10</wp:post_date>
		<wp:post_date_gmt>2012-11-18 05:18:10</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e8%87%aa%e5%b7%b1%e7%9a%84%e5%8d%9a%e5%ae%a2%e6%88%91%e5%81%9a%e4%b8%bb</wp:post_name>
		<wp:status>draft</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>shell</title>
		<link>http://10.131.10.73/mdk-vimer/?p=14</link>
		<pubDate>Sun, 18 Nov 2012 05:19:54 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?p=14</guid>
		<description></description>
		<content:encoded><![CDATA[]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>14</wp:post_id>
		<wp:post_date>2012-11-18 05:19:54</wp:post_date>
		<wp:post_date_gmt>2012-11-18 05:19:54</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>shell-2</wp:post_name>
		<wp:status>draft</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>个人杂记</title>
		<link>http://10.131.10.73/mdk-vimer/?p=57</link>
		<pubDate>Thu, 22 Nov 2012 12:52:53 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://192.168.1.108/wordpress/?p=57</guid>
		<description></description>
		<content:encoded><![CDATA[最近比较暴躁~~什么都不想想说~~看到不爽的我就暴脾气了~~代码静我心~~太闷骚了~~~╮(╯▽╰)╭]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>57</wp:post_id>
		<wp:post_date>2012-11-22 12:52:53</wp:post_date>
		<wp:post_date_gmt>2012-11-22 12:52:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>windows</wp:post_name>
		<wp:status>trash</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_trash_meta_status</wp:meta_key>
			<wp:meta_value><![CDATA[publish]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_trash_meta_time</wp:meta_key>
			<wp:meta_value><![CDATA[1365056021]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>python 天气预报</title>
		<link>http://10.131.10.73/mdk-vimer/?p=94</link>
		<pubDate>Mon, 17 Dec 2012 12:36:39 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?p=94</guid>
		<description></description>
		<content:encoded><![CDATA[~搞了一个下午~终于把自己的天气预报系统搭建起来~用的是python的网页抓取~抓取html文件后然后提取精华部分并写入一个文件~~跟网上的有点不一样的~然后用shell提取今明两天做fetion发送的内容~一切都是自动化~~脚本让人变得更懒了~crontab~本想xml的~~却是乱码~~所以。。。。。。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>94</wp:post_id>
		<wp:post_date>2012-12-17 12:36:39</wp:post_date>
		<wp:post_date_gmt>2012-12-17 12:36:39</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>python-%e5%a4%a9%e6%b0%94%e9%a2%84%e6%8a%a5</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>有好多话想说~却不知道想说什么~</title>
		<link>http://10.131.10.73/mdk-vimer/?p=101</link>
		<pubDate>Mon, 17 Dec 2012 13:21:20 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?p=101</guid>
		<description></description>
		<content:encoded><![CDATA[~明天考计算机信息安全技术~管他呢~纯属扯淡~我承认现在现在用delphi写基础应用层软件还是很多的~但是跟c/c++比起来~其代码风格真心难看啊~╮(╯▽╰)╭~算了~还是本分点吧~~我真心不想吐糟的~~但他TM的物质了~~牛真能吹啊~~天都给他黑下来了~~做件事总要磨叽磨叽老半天~~尼玛~~好吧~~心情有点小激动了~

今天搭建起了手机预报系统~打算给她每天发天气预报~~告诉她那里今明两天的天气情况~我感觉还是很温馨的~

个人移动技术博客所在地:http://mdk-vimer/]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>101</wp:post_id>
		<wp:post_date>2012-12-17 13:21:20</wp:post_date>
		<wp:post_date_gmt>2012-12-17 13:21:20</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%9c%89%e5%a5%bd%e5%a4%9a%e8%af%9d%e6%83%b3%e8%af%b4%e5%8d%b4%e4%b8%8d%e7%9f%a5%e9%81%93%e6%83%b3%e8%af%b4%e4%bb%80%e4%b9%88</wp:post_name>
		<wp:status>trash</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_trash_meta_status</wp:meta_key>
			<wp:meta_value><![CDATA[publish]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_trash_meta_time</wp:meta_key>
			<wp:meta_value><![CDATA[1365056757]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Bye world</title>
		<link>http://10.131.10.73/mdk-vimer/?p=109</link>
		<pubDate>Thu, 20 Dec 2012 07:14:46 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?p=109</guid>
		<description></description>
		<content:encoded><![CDATA[c:

#include&lt;stdio.h&gt;

int main()

{

printf("bye world!\n");

 return 0;

}

c++:

#include&lt;iostream&gt;

using namespace std;

int main()

{

cout&lt;&lt;"bye world!"&lt;&lt;endl;

return 0;

}

pascal

begin

        writeln("bye world!");

end;

bash

#!/bin/bash

echo "bye world!"

python

#!/usr/bin/env python

print "bye world"

 #/usr/bin/perl
 #
 use strict;
 use warnings;


 print "Bey Wrold\n";]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>109</wp:post_id>
		<wp:post_date>2012-12-20 07:14:46</wp:post_date>
		<wp:post_date_gmt>2012-12-20 07:14:46</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>bye-world</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>Centos启动流程(转)</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=237</link>
		<pubDate>Wed, 03 Apr 2013 11:12:09 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=237</guid>
		<description></description>
		<content:encoded><![CDATA[<div id="cnblogs_post_body">
<h2><strong>启动流程概览</strong></h2>
<ol>
	<li>在硬件驱动成功后，Kernel 会主动呼叫 init 程序，而 init 会取得 run-level 资讯；</li>
	<li>init 运行 /etc/rc.d/rc.sysinit 文件来准备软件运行的作业环境 (如网络、时区等)；</li>
	<li>init 运行 run-level 的各个服务之启动 (script 方式)；</li>
	<li>init 运行 /etc/rc.d/rc.local 文件；</li>
	<li>init 运行终端机模拟程序 mingetty 来启动 login 程序，最后就等待使用者登陆啦；</li>
</ol>
<h2><strong> </strong></h2>
<h2><strong> init,/etc/inittab,runlevel介绍</strong></h2>
<div>

在核心加载完毕、进行完硬件侦测与驱动程序加载后，此时你的主机硬件应该已经准备就绪了 (ready) ， 此时核心会主动的呼叫第一支程序，那就是 /sbin/init 罗。 init 的 PID 号码是一号啦。 /sbin/init 最主要的功能就是准备软件运行的环境，包括系统的主机名称、网络配置、语系处理、文件系统格式及其他服务的启动等。 而所有的动作都会透过 init 的配置档，亦即是 /etc/inittab 来规划，而 inittab 内还有一个很重要的配置项目，那就是默认的 runlevel (启动运行等级) 啦！
<h4><strong>Run level：运行等级有哪些？</strong></h4>
那么什么是 run level 呢？他有什么功用啊？其实很简单啦， Linux 就是藉由配置 run level 来规定系统使用不同的服务来启动，让 Linux 的使用环境不同。基本上，依据有无网络与有无 X Window 而将 run level 分为 7 个等级，分别是：
<ul>
	<li>0 - halt (系统直接关机)</li>
	<li>1 - single user mode (单人维护模式，用在系统出问题时的维护)</li>
	<li>2 - Multi-user, without NFS (类似底下的 runlevel 3，但无 NFS 服务)</li>
	<li>3 - Full multi-user mode (完整含有网络功能的纯文字模式)</li>
	<li>4 - unused (系统保留功能)</li>
	<li>5 - X11 (与 runlevel 3 类似，但加载使用 X Window)</li>
	<li>6 - reboot (重新启动)</li>
</ul>
由於 run level 0, 4, 6 不是关机、重新启动就是系统保留的，所以：『 您当然不能将默认的 run level 配置为这三个值 』， 否则系统就会不断的自动关机或自动重新启动.... 好了，那么我们启动时，到底是如何取得系统的 run level 的？当然是 /etc/inittab 所配置的罗！ 那么 /etc/inittab 到底有什么资讯呢？我们先来看看这个文件的内容好了：
<h4><strong>/etc/inittab 的内容与语法</strong></h4>
<div>
<div><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></div>
<pre>[root@www ~]# vim /etc/inittab
id:5:initdefault:                 &lt;==默认的 runlevel 配置, 此 runlevel 为 5 

si::sysinit:/etc/rc.d/rc.sysinit  &lt;==准备系统软件运行的环境的脚本运行档

# 7 个不同 run level 的，需要启动的服务的 scripts 放置路径：
l0:0:wait:/etc/rc.d/rc 0    &lt;==runlevel 0 在 /etc/rc.d/rc0.d/
l1:1:wait:/etc/rc.d/rc 1    &lt;==runlevel 1 在 /etc/rc.d/rc1.d/
l2:2:wait:/etc/rc.d/rc 2    &lt;==runlevel 2 在 /etc/rc.d/rc2.d/
l3:3:wait:/etc/rc.d/rc 3    &lt;==runlevel 3 在 /etc/rc.d/rc3.d/
l4:4:wait:/etc/rc.d/rc 4    &lt;==runlevel 4 在 /etc/rc.d/rc4.d/
l5:5:wait:/etc/rc.d/rc 5    &lt;==runlevel 5 在 /etc/rc.d/rc5.d/
l6:6:wait:/etc/rc.d/rc 6    &lt;==runlevel 6 在 /etc/rc.d/rc6.d/

# 是否允许按下 [ctrl]+[alt]+[del] 就重新启动的配置项目：
ca::ctrlaltdel:/sbin/shutdown -t3 -r now

# 底下两个配置则是关於不断电系统的 (UPS)，一个是没电力时的关机，一个是复电的处理
pf::powerfail:/sbin/shutdown -f -h +2 "Power Failure; System Shutting Down"
pr:12345:powerokwait:/sbin/shutdown -c "Power Restored; Shutdown Cancelled"

1:2345:respawn:/sbin/mingetty tty1  &lt;==其实 tty1~tty6 是由底下这六行决定的。
2:2345:respawn:/sbin/mingetty tty2
3:2345:respawn:/sbin/mingetty tty3
4:2345:respawn:/sbin/mingetty tty4
5:2345:respawn:/sbin/mingetty tty5
6:2345:respawn:/sbin/mingetty tty6

x:5:respawn:/etc/X11/prefdm -nodaemon &lt;==X window 则是这行决定的！</pre>
<div><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></div>
</div>
让我们解析一下这个文件吧！首先，这个文件的语法是利用冒号 (:) 将配置分隔成为四个栏位，每个栏位的意义与说明如下：
<div>
<pre>[配置项目]:[run level]:[init 的动作行为]:[命令项目]</pre>
</div>
<ol>
	<li>配置项目：最多四个字节，代表 init 的主要工作项目，只是一个简单的代表说明。</li>
	<li>run level：该项目在哪些 run level 底下进行的意思。如果是 35 则代表 runlevel 3 与 5 都会运行。</li>
	<li>init 的动作项目：主要可以进行的动作项目意义有：
<table border="1" cellspacing="0" cellpadding="3" bgcolor="lightyellow">
<tbody>
<tr align="center" bgcolor="#182448">
<td width="100">inittab 配置值</td>
<td>意义说明</td>
</tr>
<tr>
<td align="center">initdefault</td>
<td>代表默认的 run level 配置值</td>
</tr>
<tr>
<td align="center">sysinit</td>
<td>代表系统初始化的动作项目</td>
</tr>
<tr>
<td align="center">ctrlaltdel</td>
<td>代表 [ctrl]+[alt]+[del] 三个按键是否可以重新启动的配置</td>
</tr>
<tr>
<td align="center">wait</td>
<td>代表后面栏位配置的命令项目必须要运行完毕才能继续底下其他的动作</td>
</tr>
<tr>
<td align="center">respawn</td>
<td>代表后面栏位的命令可以无限制的再生 (重新启动)。举例来说， tty1 的 mingetty 产生的可登陆画面， 在你注销而结束后，系统会再开一个新的可登陆画面等待下一个登陆。</td>
</tr>
</tbody>
</table>
更多的配置项目请参考 man inittab 的说明。</li>
	<li>命令项目：亦即应该可以进行的命令，通常是一些 script 罗。</li>
</ol>
<h2><strong> </strong></h2>
<h2><strong>init 的处理流程</strong></h2>
事实上 /etc/inittab 的配置也有点类似 shell script 啦，因为该文件内容的配置也是一行一行的从上往下处理的， 因此我们可以知道 CentOS 的 init 依据 inittab 配置的处理流程会是：
<ol>
	<li>先取得 runlevel 亦即默认运行等级的相关等级 (以鸟哥的测试机为例，为 5 号)；</li>
	<li>使用 /etc/rc.d/rc.sysinit 进行系统初始化</li>
	<li>由於 runlevel 是 5 ，因此只进行『l5:5:wait:/etc/rc.d/rc 5』，其他行则略过</li>
	<li>配置好 [ctrl]+[alt]+[del] 这组的组合键功能</li>
	<li>配置不断电系统的 pf, pr 两种机制；</li>
	<li>启动 mingetty 的六个终端机 (tty1 ~ tty6)</li>
	<li>最终以 /etc/X11/perfdm -nodaemon 启动图形介面啦！</li>
</ol>
现在你可以知道为啥 [ctrl]+[alt]+[del] 可以重新启动而我们默认提供 6 个虚拟终端机 (tty1~tty6) 给你使用了吧！由於整个配置都是依据 /etc/inittab 来决定的，因此如果你想要修改任何细节的话， 可以这样做喔：
<ul>
	<li>如果不想让使用者利用 [crtl]+[alt]+[del] 来重新启动系统，可以将『 ca::ctrlaltdel:/sbin/shutdown -t3 -r now 』加上注解 (#) 来取消该配置</li>
	<li>规定启动的默认 run level 是纯文字的 3 号或者是具有图形介面的 5 号 ，可经由 『 id:5:initdefault: 』那个数字来决定！ 以鸟哥自己这个文件为例，我是使用默认的图形介面。如果你想要关闭图形介面的话，将该行 5 改成 3 即可。</li>
	<li>如果不想要启动六个终端机 (tty1~tty6)，那么可以将『 6:2345:respawn:/sbin/mingetty tty6』关闭数个。但务必至少启动一个喔！</li>
</ul>
所以说，你现在会自行修改登陆时的默认 run level 配置值了吗？够简单的吧？ 一般来说，我们默认都是 3 或者是 5 来作为默认的 run level 的。但有时后可能需要进入 run level 1， 也就是单人维护模式的环境当中。这个 run level 1 有点像是 Windows 系统当中的『安全模式』啦， 专门用来处理当系统有问题时的操作环境。此外，当系统发现有问题时，举例来说，不正常关机造成 filesystem 的不一致现象时，系统会主动的进入单人维护模式呢！

好了， init 在取得 run level 之后，接下来要干嘛？ 上面 /etc/inittab 文件内容不是有提到 sysinit 吗？准备初始化系统了吧！
<h2><strong> </strong></h2>
<h2><strong>init 处理系统初始化流程 (/etc/rc.d/rc.sysinit)</strong></h2>
还记得上面提到 /etc/inittab 里头有这一句『 si::sysinit:/etc/rc.d/rc.sysinit 』吧？ 这表示：『我开始加载各项系统服务之前，得先做好整个系统环境，我主要利用 /etc/rc.d/rc.sysinit 这个 shell script 来配置好我的系统环境的。』够清楚了吧？ 所以，我想要知道到底 CentOS 启动的过程当中帮我进行了什么动作，就得要仔细的分析 /etc/rc.d/rc.sysinit 罗。

如果你使用 vim 去查阅过 /etc/rc.d/rc.sysinit 的话，那么可以发现他主要的工作大抵有这几项：
<ol>
	<li>取得网络环境与主机类型：
读取网络配置档 /etc/sysconfig/network ，取得主机名称与默认通讯闸 (gateway) 等网络环境。</li>
	<li>测试与挂载内存装置 /proc 及 U盘 装置 /sys：
除挂载内存装置 /proc 之外，还会主动侦测系统上是否具有 usb 的装置， 若有则会主动加载 usb 的驱动程序，并且尝试挂载 usb 的文件系统。</li>
	<li>决定是否启动 SELinux ：
SELinux 在此时进行一些检测， 并且检测是否需要帮所有的文件重新编写标准的 SELinux 类型 (auto relabel)。</li>
	<li>启动系统的乱数产生器
乱数产生器可以帮助系统进行一些口令加密演算的功能，在此需要启动两次乱数产生器。</li>
	<li>配置终端机 (console) 字形：</li>
	<li>配置显示於启动过程中的欢迎画面 (text banner)；</li>
	<li>配置系统时间 (clock) 与时区配置：需读入 /etc/sysconfig/clock 配置值</li>
	<li>周边设备的侦测与 Plug and Play (PnP) 参数的测试：
根据核心在启动时侦测的结果 (/proc/sys/kernel/modprobe ) 开始进行 ide / scsi / 网络 / 音效 等周边设备的侦测，以及利用以加载的核心模块进行 PnP 装置的参数测试。</li>
	<li>使用者自订模块的加载
使用者可以在 /etc/sysconfig/modules/*.modules 加入自订的模块，则此时会被加载到系统当中</li>
	<li>加载核心的相关配置：
系统会主动去读取 /etc/sysctl.conf 这个文件的配置值，使核心功能成为我们想要的样子。</li>
	<li>配置主机名称与初始化电源管理模块 (ACPI)</li>
	<li>初始化软件磁盘阵列：主要是透过 /etc/mdadm.conf 来配置好的。</li>
	<li>初始化 LVM 的文件系统功能</li>
	<li>以 fsck 检验磁碟文件系统：会进行 filesystem check</li>
	<li>进行磁碟配额 quota 的转换 (非必要)：</li>
	<li>重新以可读写模式挂载系统磁碟：</li>
	<li>启动 quota 功能：所以我们不需要自订 quotaon 的动作</li>
	<li>启动系统虚拟乱数产生器 (pseudo-random)：</li>
	<li>清除启动过程当中的缓存文件：</li>
	<li>将启动相关资讯加载 /var/log/dmesg 文件中。</li>
</ol>
在 /etc/rc.d/rc.sysinit 将基本的系统配置数据都写好了，也将系统的数据配置完整！ 而如果你想要知道到底启动的过程中发生了什么事情呢？那么就运行『 dmesg 』吧。 另外，基本上，在这个文件当中所进行的很多工作的默认配置档，其实都在 /etc/sysconfig/ 当中呢！ 所以，请记得将 /etc/sysconfig/ 内的文件好好的瞧一瞧喔！ ^_^

在这个过程当中，比较值得注意的是自订模块的加载！在 CentOS 当中，如果我们想要加载核心模块的话， 可以将整个模块写入到 /etc/sysconfig/modules/*.modules 当中，在该目录下， 只要记得档名最后是以 .modules 结尾即可。 这个过程是非必要的，因为我们目前的默认模块实在已经很够用了，除非是您的主机硬件实在太新了， 非要自己加载新的模块不可，否则，在经过 /etc/rc.d/rc.sysinit 的处理后， 你的主机系统应该是已经跑得很顺畅了啦！就等著你将系统相关的服务与网络服务启动罗！

&nbsp;
<h2><strong>启动系统服务与相关启动配置档 (/etc/rc.d/rc N &amp; /etc/sysconfig)</strong></h2>
加载核心让整个系统准备接受命令来工作，再经过 /etc/rc.d/rc.sysinit 的系统模块与相关硬件资讯的初始化后，你的 CentOS 系统应该已经顺利工作了。 只是，我们还得要启动系统所需要的各项『服务』啊！这样主机才能提供我们相关的网络或者是主机功能嘛！ 这个时候，依据我们在 /etc/inittab 里面提到的 run level 配置值，就可以来决定启动的服务项目了。 举例来说，使用 run level 3 当然就不需要启动 X Window 的相关服务罗，您说是吧？

那么各个不同的 run level 服务启动的各个 shell script 放在哪？还记得 /etc/inittab 里面提到的：
<div>
<div><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></div>
<pre>l0:0:wait:/etc/rc.d/rc 0
l1:1:wait:/etc/rc.d/rc 1
l2:2:wait:/etc/rc.d/rc 2
l3:3:wait:/etc/rc.d/rc 3
l4:4:wait:/etc/rc.d/rc 4
l5:5:wait:/etc/rc.d/rc 5  &lt;==本例中，以此项目来解释
l6:6:wait:/etc/rc.d/rc 6</pre>
<div><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></div>
</div>
上面提到的就是各个 run level 要运行的各项脚本放置处啦！主要是透过 /etc/rc.d/rc 这个命令来处理相关任务！ 由於鸟哥使用默认的 runlevel 5 ，因此我们主要针对上述特殊字体那行来解释好了： /etc/rc.d/rc 5 的意义是这样的 (建议您自行使用 vim 去观察一下 /etc/rc.d/rc 这个文件，你会更有概念！)：
<ul>
	<li>透过外部第一号参数 ($1) 来取得想要运行的脚本目录。亦即由 /etc/rc.d/rc <strong>5</strong> 可以取得 /etc/rc<strong>5</strong>.d/ 这个目录来准备处理相关的脚本程序；</li>
	<li>找到 /etc/rc5.d/K??* 开头的文件，并进行『 /etc/rc5.d/K??* stop 』的动作；</li>
	<li>找到 /etc/rc5.d/S??* 开头的文件，并进行『 /etc/rc5.d/S??* start 』的动作；</li>
</ul>
透过上面的说明我们可以知道所有的项目都与 /etc/rc5.d/ 有关，那么我们就来瞧瞧这个目录下有些什么玩意儿吧！
<div>
<div><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></div>
<pre>[root@www ~]# ll /etc/rc5.d/
lrwxrwxrwx 1 root root 16 Sep  4  2008 K02dhcdbd -&gt; ../init.d/dhcdbd
....(中间省略)....
lrwxrwxrwx 1 root root 14 Sep  4  2008 K91capi -&gt; ../init.d/capi
lrwxrwxrwx 1 root root 23 Sep  4  2008 S00microcode_ctl -&gt; ../init.d/microcode_ctl
lrwxrwxrwx 1 root root 22 Sep  4  2008 S02lvm2-monitor -&gt; ../init.d/lvm2-monitor
....(中间省略)....
lrwxrwxrwx 1 root root 17 Sep  4  2008 S10network -&gt; ../init.d/network
....(中间省略)....
lrwxrwxrwx 1 root root 11 Sep  4  2008 S99local -&gt; ../rc.local
lrwxrwxrwx 1 root root 16 Sep  4  2008 S99smartd -&gt; ../init.d/smartd
....(底下省略)....</pre>
<div><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></div>
</div>
在这个目录下的文件很有趣，主要具有几个特点：
<ul>
	<li>档名全部以 Sxx 或 Kxx ，其中 xx 为数字，且这些数字在文件之间是有相关性的！</li>
	<li>全部是连结档，连结到 stand alone 服务启动的目录 /etc/init.d/ 去</li>
</ul>
服务的启动主要是以『/etc/init.d/服务档名 {start,stop}』 来启动与关闭的，那么透过刚刚 /etc/rc.d/rc 程序的解说，我们可以清楚的了解到了 /etc/rc5.d/[SK]xx 其实就是跑到 /etc/init.d/ 去找到相对应的服务脚本， 然后分别进行 start (Sxx) 或 stop (Kxx) 的动作而已啦！举例来说，以上述的表格内的 K91capi 及 S10network 为例好了， 透过 /etc/rc.d/rc 5 的运行，这两个文件会这样进行：
<ul>
	<li>/etc/rc5.d/K91capi stop --&gt; /etc/init.d/capi stop</li>
	<li>/etc/rc5.d/S10network start --&gt; /etc/init.d/network start</li>
</ul>
所以说，你有想要启动该 runlevel 时就运行的服务，那么利用 Sxx 并指向 /etc/init.d/ 的特定服务启动脚本后， 该服务就能够在启动时启动啦！就这么简单！问题是，你需要自行处理这个 K, S 开头的连结档吗？ 并不需要的，chkconfig 就是在负责处理这个连结档啦！这样有没有跟第十八章的观念串在一起了呢？ ^_^

那么为什么 K 与 S 后面要有数字呢？因为各不同的服务其实还是互有关系的。举例来说，如果要启动 WWW 服务，总是得要有网络吧？所以 /etc/init.d/network 就会比较先被启动啦！那么您就会知道在 S 或者是 K 后面接的数字是啥意思了吧？嘿嘿，那就是运行的顺序啦！那么哪个文件被最后运行呢？ 看到最后一个被运行的项目是啥？没错，就是 S99local ，亦即是：/etc/rc.d/rc.local 这个文件啦！

&nbsp;
<h2><strong>使用者自订启动启动程序 (/etc/rc.d/rc.local)</strong></h2>
<div>

在完成默认 runlevel 指定的各项服务的启动后，如果我还有其他的动作想要完成时，举例来说， 我还想要寄一封 mail 给某个系统管理帐号，通知他，系统刚刚重新启动完毕，那么是否应该要制作一个 shell script 放置在 /etc/init.d/ 里面，然后再以连结方式连结到 /etc/rc5.d/ 里面呢？呵呵！当然不需要！还记得上一小节提到的 /etc/rc.d/rc.local 吧？ 这个文件就可以运行您自己想要运行的系统命令了。

也就是说，我有任何想要在启动时就进行的工作时，直接将他写入 /etc/rc.d/rc.local ， 那么该工作就会在启动的时候自动被加载喔！而不必等我们登陆系统去启动呢！ 是否很方便啊！一般来说，鸟哥就很喜欢把自己制作的 shell script 完整档名写入 /etc/rc.d/rc.local ，如此一来，启动就会将我的 shell script 运行过，真是好棒那！

&nbsp;

</div>
<h2><strong>根据 /etc/inittab 之配置，加载终端机或 X-Window 介面</strong></h2>
<div>
<div>

在完成了系统所有服务的启动后，接下来 Linux 就会启动终端机或者是 X Window 来等待使用者登陆啦！ 实际参考的项目是 /etc/inittab 内的这一段：

</div>
<div>
<div>
<div><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></div>
<pre>1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2
3:2345:respawn:/sbin/mingetty tty3
4:2345:respawn:/sbin/mingetty tty4
5:2345:respawn:/sbin/mingetty tty5
6:2345:respawn:/sbin/mingetty tty6
x:5:respawn:/etc/X11/prefdm -nodaemon</pre>
<div><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></div>
</div>
这一段代表，在 run level 2, 3, 4, 5 时，都会运行 /sbin/mingetty 这个咚咚， 而且运行六个，这也是为何我们 Linux 会提供『六个纯文字终端机』的配置所在啊！ 因为 mingetty 就是在启动终端机的命令说。

要注意的是那个 respawn 的 init 动作项目，他代表『当后面的命令被终止 (terminal) 时， init 会主动的重新启动该项目。』这也是为何我们登陆 tty1 终端机介面后，以 exit 离开后， 系统还是会重新显示等待使用者输入的画面的原因啊！

如果改天您不想要有六个终端机时，可以取消某些终端机介面吗？当然可以啊！ 就将上面表格当中的某些项目注解掉即可！例如不想要 tty5 与 tty6 ，就将那两行注解， 则下次重新启动后，您的 Linux 就只剩下『 F1 ~ F4 』有效而已，这样说，可以了解吧！！^_^

至於如果我们使用的是 run level 5 呢？那么除了这六个终端机之外， init 还会运行 /etc/X11/prefdm -nodaemon 那个命令喔！ 他主要的功能就是在启动 X Window 啦！

&nbsp;
<h2><strong>启动过程会用到的主要配置档</strong></h2>
我们在 /sbin/init 的运行过程中有谈到许多运行脚本，包括 /etc/rc.d/rc.sysinit 以及 /etc/rc.d/rc 等等， 其实这些脚本都会使用到相当多的系统配置档，这些启动过程会用到的配置档则大多放置在 /etc/sysconfig/ 目录下。 同时，由於核心还是需要加载一些驱动程序 (核心模块)，此时系统自订的装置与模块对应档 (/etc/modprobe.conf) 就显的挺重要了喔！
<h3><strong>关於模块： /etc/modprobe.conf</strong></h3>
/etc/rc.d/rc.sysinit 当中的加载使用者自订模块的地方吗？就是在 /etc/sysconfig/modules/ 目录下啊！ 虽然核心提供的默认模块已经很足够我们使用了，但是，某些条件下我们还是得对模块进行一些参数的规划， 此时就得要使用到 /etc/modprobe.conf 罗！举例来说，鸟哥的 CentOS 主机的 modprobe.conf 有点像这样：
<div>
<pre>[root@www ~]# cat /etc/modprobe.conf
alias eth0 8139too               &lt;==让 eth0 使用 8139too 的模块
alias scsi_hostadapter pata_sis
alias snd-card-0 snd-trident
options snd-card-0 index=0       &lt;==额外指定 snd-card-0 的参数功能
options snd-trident index=0</pre>
</div>
以上表的第一行为例，鸟哥使用螃蟹卡 (Realtek 的芯片组) 来作为我的网络卡，那螃蟹卡使用的模块就是 8139too 啦！这样看的懂了吧？当我要启动网络卡时，系统会跑到这个文件来查阅一下，然后加载 8139too 驱动程序来驱动网络卡罗！更多的相关说明，请 man modprobe.conf 喔！这个文件大多在指定系统内的硬件所使用的模块啦！这个文件通常系统是可以自行产生的，所以你不必手动去订正他！ 不过，如果系统捉到错误的驱动程序，或者是你想要使用升级的驱动程序来对应相关的硬件配备时， 你就得要自行手动的处理一下这个文件了。
<h3> /etc/sysconfig/*</h3>
不说您也知道，整个启动的过程当中，老是读取的一些服务的相关配置档都是记录在 /etc/sysconfig 目录下的！那么该目录底下有些啥玩意儿？我们找几个重要的文件来谈谈：
<ul>
	<li>authconfig：
这个文件主要在规范使用者的身份认证的机 制，包括是否使用本机的 /etc/passwd, /etc/shadow 等， 以及 /etc/shadow 口令记录使用何种加密演算法，还有是否使用外部口令服务器提供的帐号验证 (NIS, LDAP) 等。 系统默认使用 MD5 加密演算法，并且不使用外部的身份验证机制；</li>
	<li>clock：
此文件在配置 Linux 主机的时区，可以使用格林威治时间(GMT)，也可以使用台湾的本地时间 (local)。基本上，在 clock 文件内的配置项目『 ZONE 』所参考的时区位於 /usr/share/zoneinfo 目录下的相对路径中。而且要修改时区的话，还得将 /usr/share/zoneinfo/Asia/Taipei 这个文件复制成为 /etc/localtime 才行！</li>
	<li>i18n：
i18n 在配置一些语系的使用方面，例如最麻烦的文字介面下的日期显示问题！ 如果你是以中文安装的，那么默认语系会被选择 zh_TW.UTF8 ，所以在纯文字介面之下， 你的文件日期显示可能就会呈现乱码！这个时候就需要更改一下这里啦！更动这个 i18n 的文件，将里面的 LC_TIME 改成 en 即可！</li>
	<li>keyboard &amp; mouse：
keyboard 与 mouse 就是在配置键盘与鼠标的形式；</li>
	<li>network：
network 可以配置是否要启动网络，以及配置主机名称还有通讯闸 (GATEWAY) 这两个重要资讯呢！</li>
	<li>network-scripts/：
至於 network-scripts 里面的文件，则是主要用在配置网络卡～</li>
</ul>
总而言之一句话，这个目录下的文件很重要的啦！启动过程里面常常会读取到的！

</div>
</div>
<h2><strong> </strong></h2>
<h2><strong>Run level 的切换</strong></h2>
<div>

在我们完成上面的所有资讯后，其实整个 Linux 主机就已经在等待我们使用者的登陆啦！ 但是，相信您应该还是会有一点疑问的地方，那就是：『我该如何切换 run level 呢？』会不会很难啊？不会啦！很简单～但是依据运行的时间而有不同的方式啊！

事实上，与 run level 有关的启动其实是在 /etc/rc.d/rc.sysinit 运行完毕之后。也就是说，其实 run level 的不同仅是 /etc/rc[0-6].d 里面启动的服务不同而已。不过，依据启动是否自动进入不同 run level 的配置，我们可以说：
<ol>
	<li>要每次启动都运行某个默认的 run level ，则需要修改 /etc/inittab 内的配置项目， 亦即是『 id:5:initdefault: 』里头的数字啊；</li>
	<li>如果仅只是暂时变更系统的 run level 时，则使用 init [0-6] 来进行 run level 的变更。 但下次重新启动时，依旧会是以 /etc/inittab 的配置为准。</li>
</ol>
假设原本我们是以 run level 5 登陆系统的，但是因为某些因素，想要切换成为 run level 3 时， 该怎么办呢？很简单啊，运行『 init 3 』即可切换。但是 init 3 这个动作到底做了什么呢？ 我们不是说了吗？事实上，不同的 run level 只是加载的服务不同罢了， 亦即是 /etc/rc5.d/ 还有 /etc/rc3.d 内的 Sxxname 与 Kxxname 有差异而已。 所以说，当运行 init 3 时，系统会：
<ul>
	<li>先比对 /etc/rc3.d/ 及 /etc/rc5.d 内的 K 与 S 开头的文件；</li>
	<li>在新的 runlevel 亦即是 /etc/rc3.d/ 内有多的 K 开头文件，则予以关闭；</li>
	<li>在新的 runlevel 亦即是 /etc/rc3.d/ 内有多的 S 开头文件，则予以启动；</li>
</ul>
也就是说，两个 run level 都存在的服务就不会被关闭啦！如此一来，就很容易切换 run level 了， 而且还不需要重新启动呢！真方便。那我怎么知道目前的 run level 是多少呢？ 直接在 bash 当中输入 runlevel 即可啊！

</div>
<div>
<div><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></div>
<pre>[root@www ~]# runlevel
N 5
# 左边代表前一个 runlevel ，右边代表目前的 runlevel。
# 由於之前并没有切换过 runlevel ，因此前一个 runlevel 不存在 (N)

# 将目前的 runlevel 切换成为 3 (注意， tty7 的数据会消失！)
[root@www ~]# init 3
NIT: Sending processes the TERM signal
Applying Intel CPU microcode update:        [  OK  ]
Starting background readahead:              [  OK  ]
Starting irqbalance:                        [  OK  ]
Starting httpd:                             [  OK  ]
Starting anacron:                           [  OK  ]
# 这代表，新的 runlevel 亦即是 runlevel3 比前一个 runlevel 多出了上述 5 个服务

[root@www ~]# runlevel
5 3
# 看吧！前一个是 runlevel 5 ，目前的是 runlevel 3 啦！</pre>
<div><a title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" /></a></div>
</div>
那么你能不能利用 init 来进行关机与重新启动呢？可以的啦！利用『 init 0 』就能够关机， 而『 init 6 』就能够重新启动！为什么？往前翻一下 runlevel 的定义即可了解吧！

&nbsp;

转自 <a href="http://vbird.dic.ksu.edu.tw/linux_basic/0510osloader_1.php#startup_init">http://vbird.dic.ksu.edu.tw/linux_basic/0510osloader_1.php#startup_init</a>

</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>237</wp:post_id>
		<wp:post_date>2013-04-03 11:12:09</wp:post_date>
		<wp:post_date_gmt>2013-04-03 11:12:09</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>centos%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b%e8%bd%ac</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>72</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>网易笔试</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=249</link>
		<pubDate>Thu, 04 Apr 2013 06:18:47 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=249</guid>
		<description></description>
		<content:encoded><![CDATA[应该说网易的这个笔试对我来说很简单~有那么几个点可以写出来

mysql 一些基础的应用

linux操作系统

tcp/ip

tcp/ip的三次握手过程~

vim/gcc/gdb的使用

进程线程端口号

文件的权限使用情况

大概就这么几点~总体难度不大的]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>249</wp:post_id>
		<wp:post_date>2013-04-04 06:18:47</wp:post_date>
		<wp:post_date_gmt>2013-04-04 06:18:47</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%bd%91%e6%98%93%e7%ac%94%e8%af%95</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>59</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>10个工具让你的 shell 脚本更强大  </title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=251</link>
		<pubDate>Thu, 04 Apr 2013 06:21:24 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=251</guid>
		<description></description>
		<content:encoded><![CDATA[<span>很多人误以为shell脚本只能在命令行下使用。其实shell也可以调用一些GUI组件， 例如菜单，警告框，进度条等等。你可以控制最终的输出，光标位置还有各种输出效果。下面我将介绍一些工具，帮助你创建强大的，互动的，用户友好的 Unix/Linux shell脚本。我在FreeBSD和Linux下测试过这些工具，不过其他UNIX系列的操作系统应该都支持的。 </span>

<span><strong>1. notify-send 命令</strong></span>

<span>这个命令可以让你通过通知进程发送一个桌面通知给用户。这可以用来向用户发送提示，或者显示一些信息而不用打断用户工作。你需要安装如下软件包： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>$ sudo apt-get install libnotify-bin</li>
</ol>
</div>
<span>下面这个例子展示了如何从命令行向桌面发送一个简单的消息： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>notify-send "rsnapshot done \"static/image/smiley/default/smile.gif\"" smilieid="\"1\"" alt="\"\"" border="\"0\""&gt;"</li>
</ol>
</div>
<span>输出： </span>

<span>下面是一个复杂一点的例子： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>....</li>
	<li>alert=18000</li>
	<li>live=$(lynx --dump http://money.rediff.com/ | grep 'BSE LIVE' | awk '{ print $5}' | sed 's/,//g;s/\.[0-9]*//g')</li>
	<li>[ $notify_counter -eq 0 ] &amp;&amp; [ $live -ge $alert ] &amp;&amp; { notify-send -t 5000 -u low -i  "BSE Sensex touched 18k";  notify_counter=1; }</li>
	<li>...</li>
</ol>
</div>
<span>输出： </span>

<span>这里的参数解释如下： </span>
<ul>
	<li>-t 5000：指定超时的时间，毫秒</li>
	<li>-u low：设置是否紧急</li>
	<li>-i gtk-dialog-info：通知图标，你可以指定图标 -i /path/to/your-icon.png</li>
</ul>
<span><strong>2. tput 命令</strong></span>

<span>这个命令是用来设置终端特性的： </span>
<ul>
	<li>  移动光标</li>
	<li>  获得终端信息</li>
	<li>  设置前景和背景色</li>
	<li>  设置粗体模式</li>
	<li>  设置反模式等等</li>
</ul>
<span>举例： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>#!/bin/bash</li>
	<li></li>
	<li># clear the screen</li>
	<li>tput clear</li>
	<li></li>
	<li># Move cursor to screen location X,Y (top left is 0,0)</li>
	<li>tput cup 3 15</li>
	<li></li>
	<li># Set a foreground colour using ANSI escape</li>
	<li>tput setaf 3</li>
	<li>echo "XYX Corp LTD."</li>
	<li>tput sgr0</li>
	<li></li>
	<li>tput cup 5 17</li>
	<li># Set reverse video mode</li>
	<li>tput rev</li>
	<li>echo "M A I N - M E N U"</li>
	<li>tput sgr0</li>
	<li></li>
	<li>tput cup 7 15</li>
	<li>echo "1. User Management"</li>
	<li></li>
	<li>tput cup 8 15</li>
	<li>echo "2. Service Management"</li>
	<li></li>
	<li>tput cup 9 15</li>
	<li>echo "3. Process Management"</li>
	<li></li>
	<li>tput cup 10 15</li>
	<li>echo "4. Backup"</li>
	<li></li>
	<li># Set bold mode</li>
	<li>tput bold</li>
	<li>tput cup 12 15</li>
	<li>read -p "Enter your choice [1-4] " choice</li>
	<li></li>
	<li>tput clear</li>
	<li>tput sgr0</li>
	<li>tput rc</li>
</ol>
</div>
<span>输出： </span>

<span><strong>3. setleds 命令</strong></span>

<span>这个命令可以让你控制键盘灯，例如打开数字键盘灯： </span>
<table cellspacing="0">
<tbody>
<tr>
<td></td>
<td>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>setleds -D +num</li>
</ol>
</div></td>
</tr>
</tbody>
</table>
<span>关闭数字键盘灯： </span>
<table cellspacing="0">
<tbody>
<tr>
<td></td>
<td>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>setleds -D -num</li>
</ol>
</div></td>
</tr>
</tbody>
</table>
<ul>
	<li>  -caps: 清除大写灯</li>
	<li>  +caps：打开大写灯</li>
	<li>  -scroll：清除滚动锁</li>
	<li>  +scroll：打开滚动锁</li>
</ul>
<span><strong>4. zenity 命令</strong></span>

<span>这个命令可以显示GTK+的对话框，然后返回用户的输入。你可以用这个命令在脚本中显示信息，并要求用户输入信息。下面这段代码就是域名的whois查询： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>#!/bin/bash</li>
	<li># Get domain name</li>
	<li>_zenity="/usr/bin/zenity"</li>
	<li>_out="/tmp/whois.output.[    DISCUZ_CODE_4    ]quot;</li>
	<li>domain=$(${_zenity} --title  "Enter domain" \</li>
	<li>      --entry --text "Enter the domain you would like to see whois info" )</li>
	<li></li>
	<li>if [ $? -eq 0 ]</li>
	<li>then</li>
	<li>  # Display a progress dialog while searching whois database</li>
	<li>  whois $domain  | tee &gt;(${_zenity} --width=200 --height=100 \</li>
	<li>        --title="whois" --progress \</li>
	<li>        --pulsate --text="Searching domain info..." \</li>
	<li>            --auto-kill --auto-close \</li>
	<li>            --percentage=10) &gt;${_out}</li>
	<li></li>
	<li>  # Display back output</li>
	<li>  ${_zenity} --width=800 --height=600  \</li>
	<li>    --title "Whois info for $domain" \</li>
	<li>    --text-info --filename="${_out}"</li>
	<li>else</li>
	<li>  ${_zenity} --error \</li>
	<li>    --text="No input provided"</li>
	<li>fi</li>
</ol>
</div>
<span>输出： </span>

<span><strong>5. kdialog 命令</strong></span>

<span>这个命令和zenity很想，只不过它是为KDE/QT应用准备的。使用方法如下： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>kdialog --dontagain myscript:nofilemsg --msgbox "File: '~/.backup/config' not found."</li>
</ol>
</div>
<span>输出 </span>

<span><strong>6. Dialog</strong></span>

<span>这个命令可以在shell脚本中显示文本组件。它使用了curses和ncurses类库。示例代码：</span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>&gt;#!/bin/bash</li>
	<li>dialog --title "Delete file" \</li>
	<li>--backtitle "Linux Shell Script Tutorial Example" \</li>
	<li>--yesno "Are you sure you want to permanently delete \"/tmp/foo.txt\"?" 7 60</li>
	<li></li>
	<li># Get exit status</li>
	<li># 0 means user hit [yes] button.</li>
	<li># 1 means user hit [no] button.</li>
	<li># 255 means user hit [Esc] key.</li>
	<li>response=$?</li>
	<li>case $response in</li>
	<li>  0) echo "File deleted.";;</li>
	<li>  1) echo "File not deleted.";;</li>
	<li>  255) echo "[ESC] key pressed.";;</li>
	<li>esac</li>
</ol>
</div>
<span><strong>
7. logger 命令</strong></span>

<span>这个命令可以让你写入系统日志例如 /var/log/messages： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>logger "MySQL database backup failed."</li>
	<li>tail -f /var/log/messages</li>
	<li>logger -t mysqld -p daemon.error "Database Server failed"</li>
	<li>tail -f /var/log/syslog</li>
</ol>
</div>
<span>输出： </span>
<span>Apr 20 00:11:45 vivek-desktop kernel: [38600.515354] CPU0: Temperature/speed normal</span>

<span>Apr 20 00:12:20 vivek-desktop mysqld: Database Server failed</span>

<span><strong>8. setterm 命令</strong></span>

<span>这个命令可以设置中断的属性。下面的例子是强制屏幕全黑15分钟，并且60分钟后把显示器设为待机状态： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>setterm -blank 15 -powersave powerdown -powerdown 60</li>
</ol>
</div>
<span>下面这段命令可以在中断显示加下划线的文字： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>setterm -underline on;</li>
	<li>echo "Add Your Important Message Here"</li>
	<li>setterm -underline off</li>
</ol>
</div>
<span>或者你可以关闭光标： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>setterm -cursor off</li>
</ol>
</div>
<span><strong>
9. smbclient：向 MS-Windows 系统发送消息</strong></span>

<span>smbclient可以和 SMB/CIFS服务器通信。它可以向MS-Windows系统的指定用户发送消息： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>smbclient -M WinXPPro &lt;&lt;EOF</li>
	<li>Message 1</li>
	<li>Message 2</li>
	<li>...</li>
	<li>..</li>
	<li>EOF</li>
</ol>
</div>
<span>或者 </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>echo "${Message}" | smbclient -M salesguy2</li>
</ol>
</div>
<span><strong>
10. Bash Socket 编程</strong></span>

<span>你可以在bash中开启一个socket链接，并且传输数据。Bash有两个特殊的设备文件： </span>
<ul>
	<li>  /dev/tcp/host/port - 如果hostname，和port是合法的话，bash会尝试开启一个TCP连接。</li>
	<li>  /dev/udp/host/port - 如果hostname和port是合法的话，bash会开启一个UDP连接。</li>
</ul>
<span>你可以利用这个技术来测试一台主机的端口是否是开启的，而不需要使用nmap或者port扫描器： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li># find out if TCP port 25 open or not</li>
	<li>(echo &gt;/dev/tcp/localhost/25) &amp;&gt;/dev/null &amp;&amp; echo "TCP port 25 open" || echo "TCP port 25 close"</li>
</ol>
</div>
<span>你可以 </span><span style="color: #3e62a6;"><span><a href="http://www.cyberciti.biz/faq/bash-for-loop/" target="_blank">使用循环来查找开着的端口</a></span></span><span>： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>echo "Scanning TCP ports..."</li>
	<li>for p in {1..1023}</li>
	<li>do</li>
	<li>  (echo &gt;/dev/tcp/localhost/$p) &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo "$p open"</li>
	<li>done</li>
</ol>
</div>
<span>输出： </span>
<span>Scanning TCP ports...</span>

<span>22 open</span>

<span>53 open</span>

<span>80 open</span>

<span>139 open</span>

<span>445 open</span>

<span>631 open</span>

<span>下面的这个例子让你的脚本扮演HTTP客户端： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>#!/bin/bash</li>
	<li>exec 3&lt;&gt; /dev/tcp/${1:-www.cyberciti.biz}/80</li>
	<li></li>
	<li>printf "GET / HTTP/1.0\r\n" &gt;&amp;3</li>
	<li>printf "Accept: text/html, text/plain\r\n" &gt;&amp;3</li>
	<li>printf "Accept-Language: en\r\n" &gt;&amp;3</li>
	<li>printf "User-Agent: nixCraft_BashScript v.%s\r\n" "${BASH_VERSION}"  &gt;&amp;3</li>
	<li>printf "\r\n" &gt;&amp;3</li>
	<li></li>
	<li>while read LINE &lt;&amp;3</li>
	<li>do</li>
	<li>  # do something on $LINE</li>
	<li>  # or send $LINE to grep or awk for grabbing data</li>
	<li>  # or simply display back data with echo command</li>
	<li>  echo $LINE</li>
	<li>done</li>
</ol>
</div>
<span><strong>关于GUITools和Cronjob</strong></span>

<span>如果你使用cronjob来调用你的脚本的话，你要通过“ </span><span>export DISPLAY=[user's machine]:0</span><span>”命令来设置本地的 display/input 服务。例如调用 /home/vivek/scripts/monitor.stock.sh脚本，它使用了 zenity 工具： </span>
<div>
<div>
<div>PHP代码</div>
</div>
<ol start="1">
	<li>@hourly DISPLAY=:0.0 /home/vivek/scripts/monitor.stock.sh</li>
</ol>
</div>
<span>所有的命令你都可以通过“man”来查询详细的使用方式。 </span>

<span>文章转载自：</span><span style="font-family: 微软雅黑,Verdana,sans-serif,宋体;"><span>http://www.oschina.net/question/28_39527</span></span>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>251</wp:post_id>
		<wp:post_date>2013-04-04 06:21:24</wp:post_date>
		<wp:post_date_gmt>2013-04-04 06:21:24</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>10%e4%b8%aa%e5%b7%a5%e5%85%b7%e8%ae%a9%e4%bd%a0%e7%9a%84-shell-%e8%84%9a%e6%9c%ac%e6%9b%b4%e5%bc%ba%e5%a4%a7-httpcloudbbs-orgforum-phpmodviewthreadtid13530</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>8</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>~校赛~</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=255</link>
		<pubDate>Sun, 07 Apr 2013 13:38:33 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=255</guid>
		<description></description>
		<content:encoded><![CDATA[今天校赛~也是OJ升级以来面临正式的比赛的之一~lamp架构的抗压相比lnmp肯定弱些~OJ的优化还有一些工作没做好~后期会越来越好的~长颈鹿前浪已经死在沙滩上后浪还是很给力的~让我们看到12级的好苗子~11级还在猛进步~后生可畏啊~今天比赛过程中天师过来看了一眼~笑眯眯的说是不是题目偏难~后面自个又说练的太少~我大天师啊~

OJ对IE10的兼容性还是挺好的~在线IDE，test，划词翻译都可以正常使用,当然还是首选火狐和谷歌~好了就说这些吧

感谢大晨哥做出解题报告~大晨哥辛苦了~以下引用大晨哥的解题报告~长颈鹿加油~
<p align="center">中国计量学院第十届程序设计竞赛参考解决方案</p>
<strong>综述</strong><strong></strong>

首先，鄙人必须要表达一下对大家参赛的感谢。我们一直想把比赛调到大家都方便的时间，但由于各种事情，比赛还是占用了大家上课的时间。而且有些选手是下了3,4节课直接来参赛，从比赛开始一直饿到比赛结束。这里我必须向大家说一声：这场比赛，辛苦大家了。

本场比赛的题目属于中等偏难。出题时我们的宗旨是：有能轻松A掉的问题，有稍微拿只笔推一推就能A掉的问题，有稍微优化能A掉的问题，不会有用输入输出坑人的问题，以普通算法大幅优化能A掉的问题压轴。

本场比赛涌现出了一批优秀的新人。他们的表现让鄙人瞬间想起一句话：长江后浪推前浪，前浪死在沙滩上。在这里我也想对这些新人说：你们可能觉得比赛取得的成绩没达到自己的期望，没关系，我们在你们身上看到了潜力。你们可能觉得一些细枝末节你们还未接触，没关系，经验总是要一点一点去积累。无论做什么事情，脚踏实地一步一步做，总会有收获的时候。

我看了一部分代码之后感觉，本次参赛选手的代码质量可圈可点。风格注意地很好，思路很清晰。这是值得表扬和发扬的。

比赛中大家广泛使用了纸和笔，还有IDE的调试功能，这是值得肯定和发扬的。

&nbsp;

下面鄙人说一下本场比赛中大家表现出的问题。

1.比赛中，大家对于英文描述普遍表现出畏惧。我没有强迫大家适应英文的意思，也没有任何贬低中文的意思。就ACM这项赛事来说，官方的ACM赛事都是用英文描述问题的。而且不能否认的是在信息技术领域，如果英文没有障碍，交流和学习会变得很方便，而且视野也会变得更广。当然包括鄙人在内的人会不服气。为什么英文会在技术领域有统治地位呢？这就要靠我们转变我们拿来主义的习惯。不能只是用人家的技术，还要创新。创造出比他们更好的新技术，新科学。这样就是别人拿我们的东西做经典了。这就是我们要把ACM的精神应用在生活中的理由（之一）。

2.好多选手轻视输入和输出要求。比如好多人没注意诸如“输入以0结束”之类的字眼，导致自己明明可以通过的方案被卡了好长时间。

3.不得不说的就是大家编程的实战经验真的有些少。像吃回车，数组越界之类的小问题不注意控制，最后调试弄不出所以然，只会越来越急躁。

4.大家的思路要有条理。不要还没想清楚就开始写。写到一个地方觉得不对，在之前应该做一件事，又回去改。之前又做错了一件事，又回去改。这样你脑子里会很混乱。与其这样，不如先想清楚了，在动手敲代码，写文章。

&nbsp;

<strong>参考思路和解决方案</strong><strong></strong>

声明：本届比赛所有问题的解决方案都不唯一。一定有比鄙人在这里提供的更好的方案。当然，对这里提供的方案，我们欢迎各种讨论。

<strong>A:</strong> <strong>又见</strong><strong>Digital Roots</strong>

大意就是给一个正整数，把数的每个数位上的数加起来，结果要是大于10，就继续操作，直到结果是个位数为止。本题在比赛中属于中偏难。如果选手使用原始的模拟方式，就把运算过程用程序语言写一遍，时间空间都会远远超标。而且我有说过这个正整数有多大了吗？

解决方案就是拿出纸和笔。我没说这个数有多大，但是不管数有多大，都可以表示成如下形式：

&nbsp;

那么x的digital root ，和的digital root一定相等（废话）。那有没有一种方法能快速地把x变成？观察形式，有没有一种通用的方法能让所有的变成？减掉。再说清楚些，对9取余，但还要防止本身就是9的倍数的情况。这就有好多方法了。

第二个问题，有没有必要开一块空间把整个x存下来？显然没必要。因为x的每个数位上的数只在算的时候用了一次。

这里提供一种很拉风的解决方案：

#include &lt;stdio.h&gt;

int main()

{

int a;

char c;

while(scanf("%1d", &amp;a) , a &gt; 0)

{

while (((c = getchar()) - 48) &gt;= 0)

a += c - 48;   //48是0的ASCII码

printf("%d\n",--a % 9 + 1);

}

return 0;

}

&nbsp;

/**************************************************************

Problem: 1238

Result: Accepted

Time:752 ms

Memory:872 kb

****************************************************************/

&nbsp;

<strong>B</strong><strong>：打字员</strong><strong></strong>

中文题大意便不赘述（下同）。有很多选手在shift处迷惑。但是问题描述已经告诉了大家按住shift时怎么计算敲击键盘的次数。如果大家没注意到也可以看第一组样例：第一组样例为什么结果是6（用锁定）而不是5（按住shift，w，w，w，w，松开shift）？就是在提醒大家要注意按住shift时怎么计算敲击键盘的次数。

这个问题如何思考？如果串长为n，最少敲击键盘次数是，试问和有没有关系？有一部分关系。因为求是要求如果输入完毕后锁定开着，要关闭。如果去掉这个烦人的规定，设表示“数到最后大写锁定必须开着”的情况下最少敲击键盘次数。那试问，和，有什么关系？没错。这就是下面的解决方案（比赛中已经产生了更好的方案，欢迎讨论）：

#include &lt;stdio.h&gt;

#include &lt;string.h&gt;

&nbsp;

#define min(a,b) ( ((a) &gt; (b)) ? (b) : (a) )

#define MAX 10005

long on[MAX], off[MAX];

char s[MAX];

&nbsp;

int main()

{

int i, t;

&nbsp;

while(~scanf("%d", &amp;t))

{

getchar();              //吃掉多余的回车

while (t--)

{

memset(on, 0, sizeof(on));

memset(off, 0, sizeof(off));

scanf("%s",s);

i = 1;

if (s[0] &gt;= 'A' &amp;&amp; s[0] &lt;= 'Z')

{

on[0] = off[0] = 2;

}

else

{

on[0] = 2;

off[0] = 1;

}

while (s[i])

{

if (s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z')

{

on[i] = min(on[i - 1] + 2, off[i - 1] + 2);

off[i] = min(on[i - 1] + 2, off[i - 1] + 1);

}

else

{

on[i] = min(on[i - 1] + 1, off[i - 1] + 2);

off[i] = min(on[i - 1] + 2, off[i - 1] + 2);

}

i++;

}

on[i - 1]++;

printf("%ld\n", min(on[i - 1], off[i - 1]));

}

}

return 0;

}

&nbsp;

/**************************************************************

Problem: 1241

Result: Accepted

Time:12 ms

Memory:1052 kb

****************************************************************/

&nbsp;

<strong>C</strong><strong>：雾都中的调研</strong><strong></strong>

本题是压轴题之一。但说穿了解决方案还是很普通。主要考验大家对一些细节的优化才能。对一些大一的新选手来说，图论的问题都会有些障碍。因为大家没有系统的了解过相关的知识。对于解决本问题的最短路径算法自然更是甚为陌生。但是大家如果不认真阅读问题的描述，会错失掉好多致命的细节。本问题最致命的细节是这里：其他所有数据和所有最终结果均为int，且为正。求的是最小伤害，最小的伤害int能装得下，请问中间的结果有没有可能超过int？还有一个不得不注意的细节，就是问题中有没有说两个点之间的路径是唯一的？

用最普通的Dijkstra（我能说这个单词我还是现查的吗）方法就能解决。参考方案如下。需要注意的地方

#include &lt;iostream&gt;

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;

#include &lt;string.h&gt;

using namespace std;

&nbsp;

#define INT_MAX 0x7fffffff

#define MAX 1002

typedef struct

{

int dis;

int val;

}node;

node map[MAX][MAX];

int start, end;

&nbsp;

node tmp[MAX];

int visited[MAX];

int n, m;

&nbsp;

void dj()

{

int i, j, k;

int min;

for (i = 1; i &lt;= n ;i++)

{

tmp[i].dis = map[start][i].dis;

tmp[i].val = map[start][i].val;

}

visited[start] = 1;

for(i = 1; i &lt;= n ; i++)

{

min = INT_MAX;

for (j = 1; j &lt;= n; j++)

{

if (!visited[j] &amp;&amp; tmp[j].dis &lt; min)

{

min = tmp[j].dis;

k = j;

}

}

if (INT_MAX == min)

break;

visited[k] = 1;

&nbsp;

for (j = 1; j &lt;= n; j++)

{

if (!visited[j])

{

<strong>                if (tmp[k].dis &lt; tmp[j].dis - map[k][j].dis)             //</strong><strong>想想为什么用加法不行</strong>

{

tmp[j].val = tmp[k].val + map[k][j].val;

tmp[j].dis = tmp[k].dis + map[k][j].dis;

}

else if (tmp[k].dis == tmp[j].dis - map[k][j].dis)

{

if (tmp[k].val &lt; tmp[j].val - map[k][j].val)

tmp[j].val = tmp[k].val + map[k][j].val;

}

&nbsp;

}

}//end for (j = 1; j &lt;= n; j++)

}//end for(i = 1; i &lt;= n ; i++)

}

&nbsp;

int main()

{

int s, t, d, v;

while (~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; (m || n))

{

for(s = 0; s &lt;= n; s++)

for (t = 1; t &lt;= n; t++)

map[s][t].dis = map[s][t].val = INT_MAX;

for(s = 0; s &lt;= n; s++)

map[s][s].dis = map[s][s].val = 0;

&nbsp;

memset(visited, 0, sizeof(visited));

&nbsp;

while (m--)

{

scanf("%d%d%d%d", &amp;s, &amp;t, &amp;d, &amp;v);

if (map[s][t].dis &gt; d)

{

map[s][t].dis = map[t][s].dis = d;

map[s][t].val = map[t][s].val= v;

}

}

scanf("%d %d", &amp;start, &amp;end);

dj();

printf("%d %d\n", tmp[end].dis, tmp[end].val);

}

return 0;

}

/**************************************************************

Problem: 1251

Result: Accepted

Time:304 ms

Memory:9336 kb

****************************************************************/

<strong>D:</strong> <strong>星际争霸</strong><strong>2 </strong><strong>虫群之心</strong><strong></strong>

本题可以算是压轴题。对于ACM陌生的选手应该都不会听说过DP，遑论树形DP。本题就是一个典型的入门级树形DP问题。DP（Dynamic Programming）的思想已经在理学工学人类社会科学等等好多科学研究中起到了不可替代的作用。广义的DP思想就是空间换时间：把解决过的问题的答案存起来，以后用的时候直接读取答案，不用再次计算。

对于本问题，若定义表示以p为根节点，士兵总数为j时，能获得的晶矿最大值。那试问，会不会有

&nbsp;

其实这个就是本问题的状态转移方程。

那怎么到达叶子节点开始递推呢？没错，就是递归。参考方案如下：

#include &lt;iostream&gt;

#include &lt;vector&gt;

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;

#include &lt;string.h&gt;

using namespace std;

&nbsp;

#define MAX 102

&nbsp;

vector&lt;int&gt; vertex[MAX];    //模仿邻接表存储图的方式，可以实现更严苛的空间控制

int dp[MAX][MAX];

int troops, n;

int bugs[MAX], brains[MAX];

bool visited[MAX];

&nbsp;

void init()

{

int i;

memset(bugs, 0, sizeof(bugs));

memset(brains,0,sizeof(brains));

memset(visited, 0 ,sizeof(visited));

memset(dp, 0, sizeof(dp));

&nbsp;

for (i = 0; i &lt; MAX; i++)

{

vertex[i].clear();

}

}

&nbsp;

void dfs(const int &amp;index)

{

int i, j, k, des, num = (bugs[index] + 19) / 20;

visited[index] = 1;

for (i = num; i &lt;= troops; i++)

dp[index][i] = brains[index];

for (i = 0; i &lt; vertex[index].size(); i++)

{

des = vertex[index][i];

if(!visited[des])

{

dfs(des);

for (j = troops; j &gt; num; j--)

for (k = 1; j - k &gt;= num; k++)

if (dp[des][k] &gt; dp[index][j] - dp[index][j - k])

dp[index][j] = dp[des][k] + dp[index][j - k];

}

}

}

&nbsp;

int main()

{

&nbsp;

int i, a, b;

while (~scanf("%d%d", &amp;n, &amp;troops))

{

&nbsp;

if ( (-1 == n) &amp;&amp; (-1 == troops) )

break;

init();

for (i = 1; i &lt;= n; i++)

{

scanf("%d%d", &amp;bugs[i], &amp;brains[i]);

}

for (i = 1; i &lt; n; i++)

{

scanf("%d%d", &amp;a, &amp;b);

vertex[a].push_back(b);

vertex[b].push_back(a);

}

if (0 == troops)

printf("0\n");

else

{

dfs(1);

printf("%d\n", dp[1][troops]);

}

}

return 0;

}

/**************************************************************

Problem: 1258

Result: Accepted

Time:172 ms

Memory:1524 kb

****************************************************************/

<strong>E</strong><strong>：长江后浪推前浪</strong><strong></strong>

本问题在本次比赛中也可算作偏难的问题。既然要分成两组，组内数的和差距最小，不妨设全部数的和是sum，那显然一定有一组的和。求的就是这组数据。那鄙人能不能换句话描述一下这个问题：n个数中选出几个，使选出的数的和尽量接近但不超过？眼熟吗？没错，这是一个经典的入门级的01背包问题。

这样就完了？不。本问题尚有一陷阱。注意本题时空限制。怎样用尽量少的空间把解决方案存下来？时间换空间？我还没有那么残忍。注意这句话：第一行为一个整数n（0 &lt; n &lt;= 30）。你想到了什么？没错。就是你想的那样。

参考方案如下。

#include &lt;stdio.h&gt;

#include &lt;string.h&gt;

&nbsp;

#define MAX 32

#define VALUE_MAX 1600

&nbsp;

typedef struct

{

int value;

int solution;

}node;

&nbsp;

int a[MAX];

node dp[VALUE_MAX];

&nbsp;

int n, sum;

int tmp;

&nbsp;

void init()

{

memset(a, 0, sizeof(a));

memset(dp, 0, sizeof(dp));

}

&nbsp;

int main()

{

int i, j;

while (~scanf("%d", &amp;n))

{

init();

sum = 0;

for (i = 0; i &lt; n; i++)

{

scanf("%d", &amp;a[i]);

sum += a[i];

}

sum /= 2;

//填包，每个数价值为a[i]

for (i = 0; i &lt; n; i++)

for (j = sum; j &gt;= a[i]; j--)

if (dp[j].value &lt;= dp[j - a[i]].value + a[i])

{

dp[j].value = dp[j - a[i]].value + a[i];

dp[j].solution = dp[j - a[i]].solution + (1 &lt;&lt; i);

}

tmp = dp[sum].solution;

printf("%d\n", dp[sum].value);

i = 0;

while (tmp)

{

if (tmp &amp; 1)

printf("%d ", a[i]);

i++;

tmp &gt;&gt;= 1;

}

printf("\n");

}

return 0;

}

/**************************************************************

Problem: 1259

Result: Accepted

Time:2284 ms

Memory:976 kb

****************************************************************/

<strong>F</strong><strong>：数动物</strong><strong></strong>

如果听说过STL，或听说过JAVA有集成哈希表，这个问题就实在太垃圾了。退一步，听说过红黑树，哈希表等与一切与查找或者映射相关的算法，这个问题充其量是一个麻烦的问题。按strcmp排序再数个数的方法我没试，是否满足本问题的时空限制我不知道。鄙人在此只贴出用STL中的map解决的方案，由于STL集成了太多东西，效率一定不是最好的：

#include &lt;iostream&gt;

#include &lt;stdio.h&gt;

#include &lt;map&gt;

#include &lt;string&gt;

using namespace std;

&nbsp;

int main()

{

&nbsp;

int n, max;

string temp, location;

map&lt;string, int&gt; table;

while (scanf("%d",&amp;n) &amp;&amp; n)

{

table.clear();

for (int i = 1; i &lt;= n; i++)

{

cin&gt;&gt;temp;

table[temp]++;

}

map&lt;string , int&gt;::iterator it;

max = 0;

for (it = table.begin(); it != table.end(); it++)

if (it -&gt;second &gt; max )

{

max = it -&gt; second;

location = it -&gt; first;

}

cout&lt;&lt;location&lt;&lt; " "&lt;&lt; max&lt;&lt;endl;

}

return 0;

}

&nbsp;

/**************************************************************

Problem: 1260

Result: Accepted

Time:1028 ms

Memory:1484 kb

****************************************************************/

<strong>G</strong><strong>：涂气球</strong><strong></strong>

脑筋急转弯问题。请问，有必要每读入一次涂颜色的过程，就把数组中对应区域中所有点的计数加一吗？用得着写线段树吗？用得着两重的循环吗？我告诉大家都不用。只贴出方案，至于为什么是脑筋急转弯问题，看了便知。

#include &lt;iostream&gt;

#include &lt;stdio.h&gt;

#include &lt;string.h&gt;

using namespace std;

&nbsp;

#define MAX 100005

int f[MAX];

&nbsp;

int main()

{

int n, m;

int i, sum;

&nbsp;

while ( scanf("%d", &amp;n) , n )

{

scanf("%d", &amp;m);

memset(f,0,sizeof(f));

for ( i = 0 ; i &lt; m ; i++ )

{

int a,b;

scanf("%d%d", &amp;a, &amp;b);

++f[a];

--f[b + 1];

}

sum = 0;

for (  i = 1 ; i &lt; n ; i++ )

{

sum += f[i];

printf("%d ",sum);

}

sum += f[i];

printf("%d\n",sum);

}

return 0;

}

&nbsp;

/**************************************************************

Problem: 1261

Result: Accepted

Time:420 ms

Memory:1872 kb

****************************************************************/

&nbsp;

以上问题的解决方案————————————————written by Ghuo

以下问题的解决方案————————————————written by Mdk

&nbsp;

<strong>H</strong><strong>：</strong><strong>Greedy Snake</strong>

GreedySnake这题呢~感觉大家是不是被英文题被英文唬住了.

思路:从-1开始到-2结束,贪吃蛇尽可能吃到苹果~dfs暴力(无需剪枝)可以过掉

给出参考代码

/*

======================================================================

*

*       Filename:  dfs.cpp

*         Description: dfs

*       Version:  1.0

*       Created:  2013/4/7 20:10:13

*       Revision:  none

*       Compiler:  gcc

*       Author:  mengdaikun@gmail.com

*       Company:  cjluacm-vim-mdk

======================================================================

*/

#include&lt;iostream&gt;

#include&lt;cstdio&gt;

#include&lt;string&gt;

#include&lt;string.h&gt;

#include&lt;cstdlib&gt;

#include&lt;queue&gt;

#include&lt;list&gt;

#include&lt;vector&gt;

#include&lt;stack&gt;

#include&lt;algorithm&gt;

using namespace std;

&nbsp;

int map[7][7];

bool visit[7][7];

int n,m,sum,Max;

int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};

int sx,sy;

bool flag;

&nbsp;

void dfs(int x,int y)

{

for(int i=0;i&lt;4;i++)

{

int nx = x + dir[i][0];

int ny = y + dir[i][1];

if(nx &gt;=0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp; map[nx][ny] &gt; 0 &amp;&amp; visit[nx][ny] == false)

{

visit[nx][ny] = true;

sum += map[nx][ny];

dfs(nx,ny);

visit[nx][ny] = false;

sum -= map[nx][ny];

}

else if(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp; map[nx][ny] == -2 &amp;&amp; visit[nx][ny] == false)

{

flag = true;

if(sum &gt; Max)

Max = sum;

continue;

}

}

}

&nbsp;

int main()

{

int test;

scanf("%d",&amp;test);

while(test--)

{

memset(map,0,sizeof(map));

memset(visit,false,sizeof(visit));

scanf("%d %d",&amp;n,&amp;m);

for(int i=0;i&lt;n;i++){

for(int j=0;j&lt;m;j++)

{

scanf("%d",&amp;map[i][j]);

if(map[i][j] == -1)

{

sx = i;

sy = j;

}

}

}

Max = 0;

sum = 0;

flag = false;

visit[sx][sy] = true;

dfs(sx,sy);

if(flag == false)

printf("-1\n");

else

printf("%d\n",Max);

}

return 0;

}

<strong>I</strong><strong>：</strong><strong>enidecs</strong><strong>坐电梯</strong><strong></strong>

enidecs坐电梯算是这次比赛的签到题吧~题目说有多组数据输入要while(~scanf())。

思路：所有的人在1层进入电梯,开关门一次（可算在out里）,然后统计要出电梯的次数out(相同楼层算一次),求出最高的楼层max即可

以下代码仅供参考

/*

======================================================================

*

*      Filename:  47.cpp

*        Description: 水题不解释

*      Version:  1.0

*      Created:  2013/4/7 20:47:20

*      Revision:  none

*      Compiler:  gcc

*      Author:  mengdaikun@gmail.com

*      Company:  cjluacm-vim-mdk

======================================================================

*/

#include&lt;iostream&gt;

#include&lt;cstdio&gt;

#include&lt;string&gt;

#include&lt;queue&gt;

#include&lt;vector&gt;

#include&lt;list&gt;

#include&lt;map&gt;

#include&lt;stack&gt;

#include&lt;string.h&gt;

#include&lt;algorithm&gt;

using namespace std;

int main()

{

int c,n,i,out;

int ai[101],max;

int visit[101];

while(~scanf("%d",&amp;c))

{

while(c--)

{

for(i=0;i&lt;101;i++)

visit[i]=0;

out =1; //1层的开关

scanf("%d",&amp;n);

max = 0;

for(i=0;i&lt;n;i++)

{

scanf("%d",&amp;ai[i]);

if (ai[i]&gt;max)max =ai[i];

if(!visit[ai[i]]) out++;

visit[ai[i]]=1;

}

printf("%d\n",( max - 1 ) * (5 + 4) + out * (2 + 3)  + n );

}

}

}]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>255</wp:post_id>
		<wp:post_date>2013-04-07 13:38:33</wp:post_date>
		<wp:post_date_gmt>2013-04-07 13:38:33</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%a0%a1%e8%b5%9b</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>61</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>linux常用命令100个用法</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=260</link>
		<pubDate>Tue, 09 Apr 2013 09:03:55 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=260</guid>
		<description></description>
		<content:encoded><![CDATA[<span>平时用linux时，我有一个习惯就是把遇到的，比较有用，并且容易忘的命令，放到一个文本文件中，没事的时候可以拿出来看看，这样可以加深印象，时间长了这些命令的用法基本上都能掌握了。以下是100个用法,有什么不对，还请大家指正。</span>

<span>
1，echo "aa" &gt; test.txt 和 echo "bb" &gt;&gt; test.txt //&gt;将原文件清空，并且内容写入到文件中，&gt;&gt;将内容放到文件的尾部
2，chmod go+w -R  /home/zhangy  //给组用户和其他用户添加写的权限
3，tar -tzvf test.tar.gz        //列出归档内容
4，du -ah  //查看文件列表大小
5，du -sh  //查看所有文件的大小总和
6，echo '1+2'|bc -l //数学运算
7，uname -a    //查看linux内核等的一些信息
8，badblocks -s /dev/sda     //坏道扫描时显示进度
9，time command     //查看命令的运行时间
10,ls -lrt //按时间的倒序排序
11,rsync -P  //同步时显示进度
12.history -c //清楚历史命令
13，cd - //返回上次目录
14，tree     //显示目录树
15，umount -n /mnt/hda2  //强制卸载
16，echo ~/     //显示用户的home目录
17，echo $[5*5]  //算术运算
18，echo $((5*5)) //算术运算
19，eval ls;ps aux|grep httpd //这二个命令都能执行
20，free -m //有MB为单位显示内存
21，uptime //显示系统已经运行了多长时间，它依次显示下列信息：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载
22，加法运算
[root@krlcgcms01 mytest]# let a=34+3;
[root@krlcgcms01 mytest]# echo $a;
23，export  //查看所有环境变量
24，echo $PATH //查看单个变量
25，cmp file1 file2   //文件内容比对
26，clear   //清屏
27，echo 23423 |awk --re-interval  '/[0-9]{3,}/'  //如果不加re-interval的话，不显示
28，cal  //得到一个整齐的日历格式
29，wc -l //统计行数，wc -w 统计单词
30，echo  "AaDCbd23" |tr "[A-Z]" "[a-z]" 大写变小写，echo  "AaDCbdc23" |tr -c b-d = 将b-d之外的字符串替换成=
31，echo "ADSF" | iconv -f UTF8 -t GBK //把字符由utf8转成gbk -f是from和简写，-t好像terminal的简写
32，cat -n file //内容的前面会显示行号
33，chattr +i file  //只读，root用户也没法对其进行修改
34，lsattr file //查看文件属性
35，cat /etc/passwd |awk -F: '{print $1}'  //查看系统中所有用户
36，cat /etc/group //查看系统中所有的组
37，groups //查前当前用户所在的，所有组
38，usermod -g 组名 用户   //这种方式是覆盖的方式，用的时候要小心，如果用户A性于mysql usermod -g php mysql这样的话只
属于php了，
39，usermod -G 组名 用户 //这种方式是增加的方式，如果用户A性于mysql usermod -g php mysql这样的话，mysql就属于2个组了
40，bc  //进入数学计算中去
41，umask 003 u权限是7,g权限是7，其他用户是4，也就是774，777-003=774
42，mkfs -t vfat /dev/hda6 //将移动硬盘里面的一个分区格式化成vfat格式
43，mount /dev/cdrom /media/cdrom  //挂载cdrom
44，getent group 532 //通过组ID,来查找组信息
45，last //登录成功用户记录
46,lastb //登录不成功用户记录
47，dump -S /dev/sda2 //查看一下要备份/dev/sda2所要的容量
48，dump -0j -f /dev/hda2/sda2_bak.dump.bz2 /dev/sda2  //将sda2进行备份并压缩
49，restore -t -f /dev/hda2/sda2_bak.dump  //查看备份信息
50，restore -r -f /dev/hda2/sda2_bak.dump  //还原备份
51，fc-list //查看系统中安装的字体
52，find ./ -type f   -exec grep -q  "root" {} \;  -exec echo {} \;  //查找目录下文件所包涵的字符串
53，vmstat 5 //每5显示一下次系统信息，cpu,memory,i/o等
54，top 后 在shift + P 所占进程的排序显示
55，top 后 在shift + M 所占内存的排序显示
56，iptraf -g  //查看各个接口的流量
57，ostat -d -x /dev/sda2 2  //用iostat查看磁盘/dev/sda2的磁盘i/o情况，每两秒刷新一次
58, paste -sd '|||\n' test //文件的每4行转换成1行，并用|隔开。
59，lsof -i :22 //知道22端口现在运行什么程序
60，lsof -c abc //显示abc进程现在打开的文件
61，lsof -p 12  //看进程号为12的进程打开了哪些文件
63，route //查看路由信息
64，ifup //开启网卡
65，ifdown //关闭网卡
66，route del -net 172.168.0.0 netmask 255.255.0.0 dev eth0 //删除 172.168这个网段
67，route add -net 172.168.10.0 netmask 255.255.255.0 dev eth0 //增加一个路由
68，netstat -tunl //列出监听的网络服务端口
69，netstat -tun //列出已连接的网络服务端口
70，nmap -sP 172.30.4.0/24  //在这个网段内有多少用户在我的主机上操作，一个不错的安全检查工具
71，vgdisplay   //查看系统中的可用空间
72，lvextend -L+20G /dev/tank/part1 //向part1这个分区增加20G的空间
73，lvresize -L-10G /dev/tank/part2 //向part2这个分区减少10G的空间
74，pvdisplay //查看磁盘信息
75,mplayer -loop 10 /mnt/song/music/花儿开了.mp3  //循环播放10遍
76,pacman -S firefox -nd  //nd去掉依赖
77,wget -c //断点下载
78,chroot  /mnt/ubuntu     //改变根目录到/mnt/ubuntu
79,ctrl+a  //命令行下，光标称动到开头
80,ctrl+e  //命令行下，光标移动结尾
81,cut -d: -f 1-4 test  //用：分割文件，取分割后的1－4列
82,file  /home/zhangy/test.php  //用于查看文件的一些基本信息
83,touch test.txt //创建一个空文件 text.txt
84,htpasswd -cbd /usr/local/nginx/conf/authfile  //创建访问控制文件
85,df  //查看磁盘空间，和当前的磁盘数
86,fdisk -l  //查看所有磁盘数
87,alsamixer  //进入后，m键可以实现静音
88,killall httpd  //把所有httpd进程杀掉
89,killall -9 mysqld_safe  //有些进程超级用户也停止不了，-9是强制删除
90,mirror /mysql //下载mysql目录
91,mirror -R /mysql     //上传mysql目录
92,rmmod pcspkr  //关掉tab提示音
93,modprobe pcspkr  //开启tab提示音
94,gpasswd -a zhangy wheel //将zhangy这个用户添加到wheel这个组
95,dd if=/dev/zero of=/virtual/ubuntu.virt.img bs=1M count=4096  //创建一个4G的IMG镜像
96，lspic //显示pci设备
97，lsusb //显示usb设备
98，history | less //less根more有点像，感觉less用着更舒服点
99，ln -s //如果忘了-s就变成硬链接了
100，tar zxvf test.tar.gz -C /home/zhangy //将内容解压到指定目录</span>
<strong>作者:海底苍鹰
文章来源:<a href="http://blog.51yip.com/linux/1213.html" target="_blank">http://blog.51yip.com/linux/1213.html</a></strong>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>260</wp:post_id>
		<wp:post_date>2013-04-09 09:03:55</wp:post_date>
		<wp:post_date_gmt>2013-04-09 09:03:55</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>linux%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4100%e4%b8%aa%e7%94%a8%e6%b3%95</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>34</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
		<title>2013企鹅实习生笔试</title>
		<link>http://10.131.10.73/mdk-vimer/?page_id=263</link>
		<pubDate>Sat, 13 Apr 2013 07:06:55 +0000</pubDate>
		<dc:creator>root</dc:creator>
		<guid isPermaLink="false">http://10.131.10.73/mdk-vimer/?page_id=263</guid>
		<description></description>
		<content:encoded><![CDATA[笔试的范围面算是比较广吧～涉及操作系统～数据结构和算法～网络～c/c++~软件工程~唉～还是太弱了～抱着打酱油的心去带回一大瓶酱油～还是得总结总结打有准备的仗~考到线程的并发~插入排序～tcp/ip~操作系统内存分配~~加油了～要有准备要努力啊]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>263</wp:post_id>
		<wp:post_date>2013-04-13 07:06:55</wp:post_date>
		<wp:post_date_gmt>2013-04-13 07:06:55</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>2013%e4%bc%81%e9%b9%85%e5%ae%9e%e4%b9%a0%e7%94%9f%e7%ac%94%e8%af%95</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>59</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_page_template</wp:meta_key>
			<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
