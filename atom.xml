<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[mdk Blog home]]></title>
  <link href="http://mdkvimer.github.io/atom.xml" rel="self"/>
  <link href="http://mdkvimer.github.io/"/>
  <updated>2013-05-19T14:06:28+08:00</updated>
  <id>http://mdkvimer.github.io/</id>
  <author>
    <name><![CDATA[mdkvimer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[linux内核启动流程]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/linuxnei-he-qi-dong-liu-cheng/"/>
    <updated>2013-05-19T11:09:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/linuxnei-he-qi-dong-liu-cheng</id>
    <content type="html"><![CDATA[<p>启动流程一览</p>

<p>既然启动是很严肃的一件事，那我们就来了解一下整个启动的过程吧！ 好让大家比较容易发现启动过程里面可能会发生问题的地方，以及出现问题后的解决之道！ 不过，由於启动的过程中，那个启动管理程序 (Boot Loader) 使用的软件可能不一样，例如目前各大 Linux distributions 的主流为 grub，但早期 Linux 默认是使用 LILO 。 但无论如何，我们总是得要了解整个 boot loader 的工作情况，才能了解为何进行多重启动的配置时， 老是听人家讲要先安装 Windows 再安装 Linux 的原因～</p>

<p>假设以个人计算机架设的 Linux 主机为例 ， 当你按下电源按键后计算机硬件会主动的读取 BIOS 来加载硬件资讯及进行硬件系统的自我测试， 之后系统会主动的去读取第一个可启动的装置 (由 BIOS 配置的) ，此时就可以读入启动管理程序了。</p>

<p>启动管理程序可以指定使用哪个核心文件来启动，并实际加载核心到内存当中解压缩与运行， 此时核心就能够开始在内存内活动，并侦测所有硬件资讯与加载适当的驱动程序来使整部主机开始运行， 等到核心侦测硬件与加载驱动程序完毕后，一个最阳春的操作系统就开始在你的 PC 上面跑了。</p>

<p>主机系统开始运行后，此时 Linux 才会呼叫外部程序开始准备软件运行的环境， 并且实际的加载所有系统运行所需要的软件程序哩！最后系统就会开始等待你的登陆与操作啦！ 简单来说，系统启动的经过可以汇整成底下的流程的：</p>

<pre><code>加载 BIOS 的硬件资讯与进行自我测试，并依据配置取得第一个可启动的装置；
读取并运行第一个启动装置内 MBR 的 boot Loader (亦即是 grub, spfdisk 等程序)；
依据 boot loader 的配置加载 Kernel ，Kernel 会开始侦测硬件与加载驱动程序；
</code></pre>

<p>BIOS, 启动自我测试与 MBR</p>

<p>在个人计算机架构下，你想要启动整部系统首先就得要让系统去加载 BIOS (Basic Input Output System)，并透过 BIOS 程序去加载 CMOS 的资讯，并且藉由 CMOS 内的配置值取得主机的各项硬件配置， 例如 CPU 与周边设备的沟通时脉啊、启动装置的搜寻顺序啊、硬盘的大小与类型啊、 系统时间啊、各周边汇流排的是否启动 Plug and Play (PnP, 随插即用装置) 啊、 各周边设备的 I/O 位址啊、以及与 CPU 沟通的 IRQ 岔断等等的资讯。</p>

<p>在取得这些资讯后，BIOS 还会进行启动自我测试 (Power-on Self Test, POST) 。 然后开始运行硬件侦测的初始化，并配置 PnP 装置，之后再定义出可启动的装置顺序， 接下来就会开始进行启动装置的数据读取了 (MBR 相关的任务开始)。</p>

<p>由於我们的系统软件大多放置到硬盘中嘛！所以 BIOS 会指定启动的装置好让我们可以读取磁碟中的操作系统核心文件。 但由於不同的操作系统他的文件系统格式不相同，因此我们必须要以一个启动管理程序来处理核心文件加载 (load) 的问题， 因此这个启动管理程序就被称为 Boot Loader 了。那这个 Boot Loader 程序安装在哪里呢？就在启动装置的第一个磁区 (sector) 内，也就是我们一直谈到的 MBR (Master Boot Record, 主要启动记录区)。</p>

<p>那你会不会觉得很奇怪啊？既然核心文件需要 loader 来读取，那每个操作系统的 loader 都不相同， 这样的话 BIOS 又是如何读取 MBR 内的 loader 呢？很有趣的问题吧！其实 BIOS 是透过硬件的 INT 13 中断功能来读取 MBR 的，也就是说，只要 BIOS 能够侦测的到你的磁碟 (不论该磁碟是 SATA 还是 IDE 介面)，那他就有办法透过 INT 13 这条通道来读取该磁碟的第一个磁区内的 MBR 啦！这样 boot loader 也就能够被运行罗！</p>

<p>我们知道每颗硬盘的第一个磁区内含有 446 bytes的 MBR 区域，那么如果我的主机上面有两颗硬盘的话， 系统会去哪颗硬盘的 MBR 读取 boot loader 呢？这个就得要看 BIOS 的配置了。 基本上，我们常常讲的『系统的 MBR』其实指的是 第一个启动装置的 MBR 才对！ 所以，改天如果你要将启动管理程序安装到某颗硬盘的 MBR 时， 要特别注意当时系统的『第一个启动装置』是哪个，否则会安装到错误的硬盘上面的 MBR 喔！
Boot Loader</p>

<p>刚刚说到 Loader 的最主要功能是要认识操作系统的文件格式并据以加载核心到主内存中去运行。 由於不同操作系统的文件格式不一致，因此每种操作系统都有自己的 boot loader 啦！用自己的 loader 才有办法加载核心文件嘛！那问题就来啦，你应该有听说过多重操作系统吧？也就是在一部主机上面安装多种不同的操作系统。 既然你 (1)必须要使用自己的 loader 才能够加载属於自己的操作系统核心，而 (2)系统的 MBR 只有一个，那你怎么会有办法同时在一部主机上面安装 Windows 与 Linux 呢？</p>

<p>其实每个文件系统 (filesystem, 或者是 partition) 都会保留一块启动磁区 (boot sector) 提供操作系统安装 boot loader ， 而通常操作系统默认都会安装一份 loader 到他根目录所在的文件系统的 boot sector 上。如果我们在一部主机上面安装 Windows 与 Linux 后，该 boot sector, boot loader 与 MBR 的相关性会有点像下图：</p>

<p>图 1.2.1、 boot loader 安装在 MBR, boot sector 与操作系统的关系
如上图所示，每个操作系统默认是会安装一套 boot loader 到他自己的文件系统中 (就是每个 filesystem 左下角的方框)，而在 Linux 系统安装时，你可以选择将 boot loader 安装到 MBR 去，也可以选择不安装。 如果选择安装到 MBR 的话，那理论上你在 MBR 与 boot sector 都会保有一份 boot loader 程序的。 至於 Windows 安装时，他默认会主动的将 MBR 与 boot sector 都装上一份 boot loader！所以啦， 你会发现安装多重操作系统时，你的 MBR 常常会被不同的操作系统的 boot loader 所覆盖啦！ ^^</p>

<p>我们刚刚提到的两个问题还是没有解决啊！虽然各个操作系统都可以安装一份 boot loader 到他们的 boot sector 中， 这样操作系统可以透过自己的 boot loader 来加载核心了。问题是系统的 MBR 只有一个哩！ 你要怎么运行 boot sector 里面的 loader 啊？</p>

<p>boot loader 主要的功能如下</p>

<pre><code>提供菜单：使用者可以选择不同的启动项目，这也是多重启动的重要功能！
加载核心文件：直接指向可启动的程序区段来开始操作系统；
转交其他 loader：将启动管理功能转交给其他 loader 负责。
</code></pre>

<p>由於具有菜单功能，因此我们可以选择不同的核心来启动。而由於具有控制权转交的功能，因此我们可以加载其他 boot sector 内的 loader 啦！不过 Windows 的 loader 默认不具有控制权转交的功能，因此你不能使用 Windows 的 loader 来加载 Linux 的 loader 喔！这也是为啥第三章谈到 MBR 与多重启动时，会特别强调先装 Windows 再装 Linux 的缘故。 我们将上述的三个功能以底下的图示来解释你就看的懂了！(与第三章的图示也非常类似啦！)</p>

<p>图 1.2.2、 启动管理程序的菜单功能与控制权转交功能示意图
如上图所示，我的 MBR 使用 Linux 的 grub 这个启动管理程序，并且里面假设已经有了三个菜单， 第一个菜单可以直接指向 Linux 的核心文件并且直接加载核心来启动；第二个菜单可以将启动管理程序控制权交给 Windows 来管理，此时 Windows 的 loader 会接管启动流程，这个时候他就能够启动 windows 了。第三个菜单则是使用 Linux 在 boot sector 内的启动管理程序，此时就会跳出另一个 grub 的菜单啦！了解了吗？</p>

<p>而最终 boot loader 的功能就是『加载 kernel 文件』啦！</p>

<p>加载核心侦测硬件与 initrd</p>

<p>当我们藉由 boot loader 的管理而开始读取核心文件后，接下来， Linux 就会将核心解压缩到主内存当中， 并且利用核心的功能，开始测试与驱动各个周边装置，包括储存装置、CPU、网络卡、声卡等等。 此时 Linux 核心会以自己的功能重新侦测一次硬件，而不一定会使用 BIOS 侦测到的硬件资讯喔！也就是说，核心此时才开始接管 BIOS 后的工作了。 那么核心文件在哪里啊？一般来说，他会被放置到 /boot 里面，并且取名为 /boot/vmlinuz 才对！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@www ~]# ls --format=single-column -F /boot
</span><span class='line'>config-2.6.18-92.el5      &lt;==此版本核心被编译时选择的功能与模块配置档
</span><span class='line'>grub/                     &lt;==就是启动管理程序 grub 相关数据目录
</span><span class='line'>initrd-2.6.18-92.el5.img  &lt;==虚拟文件系统档！
</span><span class='line'>System.map-2.6.18-92.el5  &lt;==核心功能放置到内存位址的对应表
</span><span class='line'>vmlinuz-2.6.18-92.el5     &lt;==就是核心文件啦！最重要者！</span></code></pre></td></tr></table></div></figure>


<p>从上表我们也可以知道此版本的 Linux 核心为 2.6.18-92.el5 这个版本！为了硬件开发商与其他核心功能开发者的便利， 因此 Linux 核心是可以透过动态加载核心模块的 (就请想成驱动程序即可)，这些核心模块就放置在 /lib/modules/ 目录内。 由于模块放置到磁盘根目录内 (要记得 /lib 不可以与 / 分别放在不同的 partition ！)， 因此在启动的过程中核心必须要挂载根目录，这样才能够读取核心模块提供加载驱动程序的功能。 而且为了担心影响到磁碟内的文件系统，因此启动过程中根目录是以唯读的方式来挂载的喔。</p>

<p>一般来说，非必要的功能且可以编译成为模块的核心功能，目前的 Linux distributions 都会将他编译成为模块。 因此 U盘, SATA, SCSI… 等磁碟装置的驱动程序通常都是以模块的方式来存在的。 现在来思考一种情况，假设你的 linux 是安装在 SATA 磁碟上面的，你可以透过 BIOS 的 INT 13 取得 boot loader 与 kernel 文件来启动，然后 kernel 会开始接管系统并且侦测硬件及尝试挂载根目录来取得额外的驱动程序。</p>

<p>问题是，核心根本不认识 SATA 磁碟，所以需要加载 SATA 磁碟的驱动程序， 否则根本就无法挂载根目录。但是 SATA 的驱动程序在 /lib/modules 内，你根本无法挂载根目录又怎么读取到 /lib/modules/ 内的驱动程序？是吧！非常的两难吧！在这个情况之下，你的 Linux 是无法顺利启动的！ 那怎办？没关系，我们可以透过虚拟文件系统来处理这个问题。</p>

<p>虚拟文件系统 (Initial RAM Disk) 一般使用的档名为 /boot/initrd ，这个文件的特色是，他也能够透过 boot loader 来加载到内存中， 然后这个文件会被解压缩并且在内存当中模拟成一个根目录， 且此模拟在内存当中的文件系统能够提供一支可运行的程序，透过该程序来加载启动过程中所最需要的核心模块， 通常这些模块就是 U盘, RAID, LVM, SCSI 等文件系统与磁碟介面的驱动程序啦！等加载完成后， 会帮助核心重新呼叫 /sbin/init 来开始后续的正常启动流程。</p>

<p>如上图所示，boot loader 可以加载 kernel 与 initrd ，然后在内存中让 initrd 解压缩成为根目录， kernel 就能够藉此加载适当的驱动程序，最终释放虚拟文件系统，并挂载实际的根目录文件系统， 就能够开始后续的正常启动流程。更详细的 initrd 说明，你可以自行使用 man initrd 去查阅看看。 底下让我们来了解一下 CentOS 5.x 的 initrd 文件内容有什么吧！</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@www ~]# mkdir /tmp/initrd
</span><span class='line'>[root@www ~]# cp /boot/initrd-2.6.18-92.el5.img /tmp/initrd/
</span><span class='line'>[root@www ~]# cd /tmp/initrd
</span><span class='line'>[root@www initrd]# file initrd-2.6.18-92.el5.img
</span><span class='line'>initrd-2.6.18-92.el5.img: gzip compressed data, ...</span></code></pre></td></tr></table></div></figure>


<p></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@www initrd]# mv initrd-2.6.18-92.el5.img initrd-2.6.18-92.el5.gz
</span><span class='line'>[root@www initrd]# gzip -d initrd-2.6.18-92.el5.gz
</span><span class='line'>[root@www initrd]# file initrd-2.6.18-92.el5
</span><span class='line'>initrd-2.6.18-92.el5: ASCII cpio archive (SVR4 with no CRC)</span></code></pre></td></tr></table></div></figure>


<p></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@www initrd]# cpio -ivcdu &lt; initrd-2.6.18-92.el5
</span><span class='line'>[root@www initrd]# ll
</span><span class='line'>drwx------ 2 root root    4096 Apr 10 02:05 bin
</span><span class='line'>drwx------ 3 root root    4096 Apr 10 02:05 dev
</span><span class='line'>drwx------ 2 root root    4096 Apr 10 02:05 etc
</span><span class='line'>-rwx------ 1 root root    1888 Apr 10 02:05 init
</span><span class='line'>-rw------- 1 root root 5408768 Apr 10 02:00 initrd-2.6.18-92.el5
</span><span class='line'>drwx------ 3 root root    4096 Apr 10 02:05 lib
</span><span class='line'>drwx------ 2 root root    4096 Apr 10 02:05 proc
</span><span class='line'>lrwxrwxrwx 1 root root       3 Apr 10 02:05 sbin -&gt; bin
</span><span class='line'>drwx------ 2 root root    4096 Apr 10 02:05 sys
</span><span class='line'>drwx------ 2 root root    4096 Apr 10 02:05 sysroot</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@www initrd]# cat init</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/nash             
</span><span class='line'>mount -t proc /proc /proc    挂载内存的虚拟文件系统
</span><span class='line'>....(中间省略)....
</span><span class='line'>echo Creating initial device nodes
</span><span class='line'>mknod /dev/null c 1 3        创建系统所需要的各项装置！
</span><span class='line'>....(中间省略)....
</span><span class='line'>echo "Loading ehci-hcd.ko module"
</span><span class='line'>insmod /lib/ehci-hcd.ko      加载各项核心模块，就是驱动程序！
</span><span class='line'>....(中间省略)....
</span><span class='line'>echo Creating root device.
</span><span class='line'>mkrootdev -t ext3 -o defaults,ro hdc2 尝试挂载根目录啦！
</span><span class='line'>....(底下省略)....</span></code></pre></td></tr></table></div></figure>


<p>透过上述运行档的内容，我们可以知道 initrd 有加载模块并且尝试挂载了虚拟文件系统。 接下来就能够顺利的运行啦！那么是否一定需要 initrd 呢？</p>

<p>是否没有 initrd 就无法顺利启动？
答：
不见得的！需要 initrd 最重要的原因是，当启动时无法挂载根目录的情况下， 此时就一定需要 initrd ，例如你的根目录在特殊的磁碟介面 (U盘, SATA, SCSI) ， 或者是你的文件系统较为特殊 (LVM, RAID) 等等，才会需要 initrd。</p>

<p>如果你的 Linux 是安装在 IDE 介面的磁碟上，并且使用默认的 ext2/ext3 文件系统， 那么不需要 initrd 也能够顺利的启动进入 Linux 的！</p>

<p>在核心完整的加载后，您的主机应该就开始正确的运行了</p>

<p>转自 <a href="http://vbird.dic.ksu.edu.tw/linux_basic/0510osloader_1.php">http://vbird.dic.ksu.edu.tw/linux_basic/0510osloader_1.php</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux系统调用列表]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/linuxxi-tong-diao-yong-lie-biao/"/>
    <updated>2013-05-19T11:08:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/linuxxi-tong-diao-yong-lie-biao</id>
    <content type="html"><![CDATA[<p>以下是Linux系统调用的一个列表，包含了大部分常用系统调用和由系统调用派生出的的函数。这可能是你在互联网上所能看到的唯一一篇中文注释的Linux系统调用列表，即使是简单的字母序英文列表，能做到这么完全也是很罕见的。</p>

<p>按照惯例，这个列表以man pages第2节，即系统调用节为蓝本。按照笔者的理解，对其作了大致的分类，同时也作了一些小小的修改，删去了几个仅供内核使用，不允许用户调用的系统调用，对个别本人稍觉不妥的地方作了一些小的修改，并对所有列出的系统调用附上简要注释。</p>

<p>其中有一些函数的作用完全相同，只是参数不同。（可能很多熟悉C++朋友马上就能联想起函数重载，但是别忘了Linux核心是用C语言写的，所以只 能取成不同的函数名）。还有一些函数已经过时，被新的更好的函数所代替了（gcc在链接这些函数时会发出警告），但因为兼容的原因还保留着，这些函数我会 在前面标上星号以示区别。
一、进程控制：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fork     创建一个新进程
</span><span class='line'>clone     按指定条件创建子进程
</span><span class='line'>execve    运行可执行文件
</span><span class='line'>exit  中止进程
</span><span class='line'>_exit     立即中止当前进程
</span><span class='line'>getdtablesize     进程所能打开的最大文件数
</span><span class='line'>getpgid   获取指定进程组标识号
</span><span class='line'>setpgid   设置指定进程组标志号
</span><span class='line'>getpgrp   获取当前进程组标识号
</span><span class='line'>setpgrp   设置当前进程组标志号
</span><span class='line'>getpid    获取进程标识号
</span><span class='line'>getppid   获取父进程标识号
</span><span class='line'>getpriority   获取调度优先级
</span><span class='line'>setpriority   设置调度优先级
</span><span class='line'>modify_ldt    读写进程的本地描述表
</span><span class='line'>nanosleep     使进程睡眠指定的时间
</span><span class='line'>nice  改变分时进程的优先级
</span><span class='line'>pause     挂起进程，等待信号
</span><span class='line'>personality   设置进程运行域
</span><span class='line'>prctl     对进程进行特定操作
</span><span class='line'>ptrace    进程跟踪
</span><span class='line'>sched_get_priority_max    取得静态优先级的上限
</span><span class='line'>sched_get_priority_min    取得静态优先级的下限
</span><span class='line'>sched_getparam    取得进程的调度参数
</span><span class='line'>sched_getscheduler    取得指定进程的调度策略
</span><span class='line'>sched_rr_get_interval     取得按RR算法调度的实时进程的时间片长度
</span><span class='line'>sched_setparam    设置进程的调度参数
</span><span class='line'>sched_setscheduler    设置指定进程的调度策略和参数
</span><span class='line'>sched_yield   进程主动让出处理器,并将自己等候调度队列队尾
</span><span class='line'>vfork     创建一个子进程，以供执行新程序，常与execve等同时使用
</span><span class='line'>wait  等待子进程终止
</span><span class='line'>wait3     参见wait
</span><span class='line'>waitpid   等待指定子进程终止
</span><span class='line'>wait4     参见waitpid
</span><span class='line'>capget    获取进程权限
</span><span class='line'>capset    设置进程权限
</span><span class='line'>getsid    获取会晤标识号
</span><span class='line'>setsid    设置会晤标识号</span></code></pre></td></tr></table></div></figure>


<p>二、文件系统控制</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1、文件读写操作
</span><span class='line'>fcntl     文件控制
</span><span class='line'>open  打开文件
</span><span class='line'>creat     创建新文件
</span><span class='line'>close     关闭文件描述字
</span><span class='line'>read  读文件
</span><span class='line'>write     写文件
</span><span class='line'>readv     从文件读入数据到缓冲数组中
</span><span class='line'>writev    将缓冲数组里的数据写入文件
</span><span class='line'>pread     对文件随机读
</span><span class='line'>pwrite    对文件随机写
</span><span class='line'>lseek     移动文件指针
</span><span class='line'>_llseek   在64位地址空间里移动文件指针
</span><span class='line'>dup   复制已打开的文件描述字
</span><span class='line'>dup2  按指定条件复制文件描述字
</span><span class='line'>flock     文件加/解锁
</span><span class='line'>poll  I/O多路转换
</span><span class='line'>truncate  截断文件
</span><span class='line'>ftruncate     参见truncate
</span><span class='line'>umask     设置文件权限掩码
</span><span class='line'>fsync     把文件在内存中的部分写回磁盘</span></code></pre></td></tr></table></div></figure>


<p>2、文件系统操作</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>access   确定文件的可存取性
</span><span class='line'>chdir     改变当前工作目录
</span><span class='line'>fchdir    参见chdir
</span><span class='line'>chmod     改变文件方式
</span><span class='line'>fchmod    参见chmod
</span><span class='line'>chown     改变文件的属主或用户组
</span><span class='line'>fchown    参见chown
</span><span class='line'>lchown    参见chown
</span><span class='line'>chroot    改变根目录
</span><span class='line'>stat  取文件状态信息
</span><span class='line'>lstat     参见stat
</span><span class='line'>fstat     参见stat
</span><span class='line'>statfs    取文件系统信息
</span><span class='line'>fstatfs   参见statfs
</span><span class='line'>readdir   读取目录项
</span><span class='line'>getdents  读取目录项
</span><span class='line'>mkdir     创建目录
</span><span class='line'>mknod     创建索引节点
</span><span class='line'>rmdir     删除目录
</span><span class='line'>rename    文件改名
</span><span class='line'>link  创建链接
</span><span class='line'>symlink   创建符号链接
</span><span class='line'>unlink    删除链接
</span><span class='line'>readlink  读符号链接的值
</span><span class='line'>mount     安装文件系统
</span><span class='line'>umount    卸下文件系统
</span><span class='line'>ustat     取文件系统信息
</span><span class='line'>utime     改变文件的访问修改时间
</span><span class='line'>utimes    参见utime
</span><span class='line'>quotactl  控制磁盘配额
</span><span class='line'> ```
</span><span class='line'>三、系统控制</span></code></pre></td></tr></table></div></figure>


<p>ioctl   I/O总控制函数
_sysctl     读/写系统参数
acct    启用或禁止进程记账
getrlimit   获取系统资源上限
setrlimit   设置系统资源上限
getrusage   获取系统资源使用情况
uselib  选择要使用的二进制函数库
ioperm  设置端口I/O权限
iopl    改变进程I/O权限级别
outb    低级端口操作
reboot  重新启动
swapon  打开交换文件和设备
swapoff     关闭交换文件和设备
bdflush     控制bdflush守护进程
sysfs   取核心支持的文件系统类型
sysinfo     取得系统信息
adjtimex    调整系统时钟
alarm   设置进程的闹钟
getitimer   获取计时器值
setitimer   设置计时器值
gettimeofday    取时间和时区
settimeofday    设置时间和时区
stime   设置系统日期和时间
time    取得系统时间
times   取进程运行时间
uname   获取当前UNIX系统的名称、版本和主机等信息
vhangup     挂起当前终端
nfsservctl  对NFS守护进程进行控制
vm86    进入模拟8086模式
create_module   创建可装载的模块项
delete_module   删除可装载的模块项
init_module     初始化模块
query_module    查询模块信息
*get_kernel_syms    取得核心符号,已被query_module代替
 &#8220;`
四、内存管理</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brk  改变数据段空间的分配
</span><span class='line'>sbrk  参见brk
</span><span class='line'>mlock     内存页面加锁
</span><span class='line'>munlock   内存页面解锁
</span><span class='line'>mlockall  调用进程所有内存页面加锁
</span><span class='line'>munlockall    调用进程所有内存页面解锁
</span><span class='line'>mmap  映射虚拟内存页
</span><span class='line'>munmap    去除内存页映射
</span><span class='line'>mremap    重新映射虚拟内存地址
</span><span class='line'>msync     将映射内存中的数据写回磁盘
</span><span class='line'>mprotect  设置内存映像保护
</span><span class='line'>getpagesize   获取页面大小
</span><span class='line'>sync  将内存缓冲区数据写回硬盘
</span><span class='line'>cacheflush    将指定缓冲区中的内容写回磁盘
</span><span class='line'> ```
</span><span class='line'>五、网络管理</span></code></pre></td></tr></table></div></figure>


<p>getdomainname   取域名
setdomainname   设置域名
gethostid   获取主机标识号
sethostid   设置主机标识号
gethostname     获取本主机名称
sethostname     设置主机名称
 &#8220;`
六、socket控制</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>socketcall   socket系统调用
</span><span class='line'>socket    建立socket
</span><span class='line'>bind  绑定socket到端口
</span><span class='line'>connect   连接远程主机
</span><span class='line'>accept    响应socket连接请求
</span><span class='line'>send  通过socket发送信息
</span><span class='line'>sendto    发送UDP信息
</span><span class='line'>sendmsg   参见send
</span><span class='line'>recv  通过socket接收信息
</span><span class='line'>recvfrom  接收UDP信息
</span><span class='line'>recvmsg   参见recv
</span><span class='line'>listen    监听socket端口
</span><span class='line'>select    对多路同步I/O进行轮询
</span><span class='line'>shutdown  关闭socket上的连接
</span><span class='line'>getsockname   取得本地socket名字
</span><span class='line'>getpeername   获取通信对方的socket名字
</span><span class='line'>getsockopt    取端口设置
</span><span class='line'>setsockopt    设置端口参数
</span><span class='line'>sendfile  在文件或端口间传输数据
</span><span class='line'>socketpair    创建一对已联接的无名socket</span></code></pre></td></tr></table></div></figure>


<p>七、用户管理</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>getuid   获取用户标识号
</span><span class='line'>setuid    设置用户标志号
</span><span class='line'>getgid    获取组标识号
</span><span class='line'>setgid    设置组标志号
</span><span class='line'>getegid   获取有效组标识号
</span><span class='line'>setegid   设置有效组标识号
</span><span class='line'>geteuid   获取有效用户标识号
</span><span class='line'>seteuid   设置有效用户标识号
</span><span class='line'>setregid  分别设置真实和有效的的组标识号
</span><span class='line'>setreuid  分别设置真实和有效的用户标识号
</span><span class='line'>getresgid     分别获取真实的,有效的和保存过的组标识号
</span><span class='line'>setresgid     分别设置真实的,有效的和保存过的组标识号
</span><span class='line'>getresuid     分别获取真实的,有效的和保存过的用户标识号
</span><span class='line'>setresuid     分别设置真实的,有效的和保存过的用户标识号
</span><span class='line'>setfsgid  设置文件系统检查时使用的组标识号
</span><span class='line'>setfsuid  设置文件系统检查时使用的用户标识号
</span><span class='line'>getgroups     获取后补组标志清单
</span><span class='line'>setgroups     设置后补组标志清单
</span><span class='line'> ```
</span><span class='line'>八、进程间通信</span></code></pre></td></tr></table></div></figure>


<p>ipc     进程间通信总控制调用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1、信号</span></code></pre></td></tr></table></div></figure>


<p>sigaction   设置对指定信号的处理方法
sigprocmask     根据参数对信号集中的信号执行阻塞/解除阻塞等操作
sigpending  为指定的被阻塞信号设置队列
sigsuspend  挂起进程等待特定信号
signal  参见signal
kill    向进程或进程组发信号
<em>sigblock   向被阻塞信号掩码中添加信号,已被sigprocmask代替
</em>siggetmask     取得现有阻塞信号掩码,已被sigprocmask代替
<em>sigsetmask     用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替
</em>sigmask    将给定的信号转化为掩码,已被sigprocmask代替
*sigpause   作用同sigsuspend,已被sigsuspend代替
sigvec  为兼容BSD而设的信号处理函数,作用类似sigaction
ssetmask    ANSI C的信号处理函数,作用类似sigaction</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2、消息</span></code></pre></td></tr></table></div></figure>


<p>msgctl  消息控制操作
msgget  获取消息队列
msgsnd  发消息
msgrcv  取消息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3、管道</span></code></pre></td></tr></table></div></figure>


<p>pipe    创建管道</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>4、信号量</span></code></pre></td></tr></table></div></figure>


<p>semctl  信号量控制
semget  获取一组信号量
semop   信号量操作</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>5、共享内存</span></code></pre></td></tr></table></div></figure>


<p>shmctl  控制共享内存
shmget  获取共享内存
shmat   连接共享内存
shmdt   拆卸共享内存
 &#8220;`</p>

<p>转自:<a href="http://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html">http://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[linux内存动态分区管理]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/linuxnei-cun-dong-tai-fen-qu-guan-li/"/>
    <updated>2013-05-19T11:04:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/linuxnei-cun-dong-tai-fen-qu-guan-li</id>
    <content type="html"><![CDATA[<p>1.分别使用首次适应算法,最佳适应算法分配内存空间</p>

<p>2.实现对内存空间的释放</p>

<p>3.显示内存分配情况</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include&lt;stdio.h&gt;
</span><span class='line'>#include&lt;unistd.h&gt;
</span><span class='line'>#include&lt;stdlib.h&gt;
</span><span class='line'>#include&lt;string.h&gt;
</span><span class='line'>#include&lt;sys/wait.h&gt;
</span><span class='line'>#include&lt;sys/types.h&gt;
</span><span class='line'>#define MEMSIZE 100   
</span><span class='line'>#define MINSIZE 2    
</span><span class='line'>typedef struct MemoryInformation{
</span><span class='line'>int start;  
</span><span class='line'>int size;  
</span><span class='line'>char info;  
</span><span class='line'>}MEMINFO;
</span><span class='line'>MEMINFO MemList[MEMSIZE];
</span><span class='line'>void Display();
</span><span class='line'>void InitAll()
</span><span class='line'>{
</span><span class='line'>int i;
</span><span class='line'>MEMINFO temp={0,0,’e'};
</span><span class='line'>for(i=0;i&lt;MEMSIZE;i++)
</span><span class='line'>MemList[i]=temp;
</span><span class='line'>MemList[0].start = 0;
</span><span class='line'>MemList[0].size = MEMSIZE;
</span><span class='line'>MemList[0].info = ‘f’;
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>void FirstFit_new()
</span><span class='line'>{
</span><span class='line'>int i,j,size;
</span><span class='line'>char temp[10];
</span><span class='line'>printf(“How MAny MEMORY do you require?”);
</span><span class='line'>scanf(“%d”,&size);
</span><span class='line'>for(i=0;i &lt; MEMSIZE -1 && MemList[i].info!=’e';i++){
</span><span class='line'>if(MemList[i].size &gt;= size && MemList[i].info==’f'){
</span><span class='line'>if(MemList[i].size – size &lt;= MINSIZE)
</span><span class='line'>MemList[i].info=’u';
</span><span class='line'>else{
</span><span class='line'>for(j=MEMSIZE – 2;j &gt; i;j–){
</span><span class='line'>MemList[j+1] = MemList[j];
</span><span class='line'>}
</span><span class='line'>MemList[i+1].start = MemList[i].start + size;
</span><span class='line'>MemList[i+1].size = MemList[i].size – size;
</span><span class='line'>MemList[i+1].info = ‘f’;
</span><span class='line'>MemList[i].size = size;
</span><span class='line'>MemList[i].info = ‘u’;
</span><span class='line'>}
</span><span class='line'>break;
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>if(i == MEMSIZE – 1 || MemList[i].info == ‘e’){
</span><span class='line'>printf(“NOT Enough Memory!\n”);
</span><span class='line'>getchar();
</span><span class='line'>}
</span><span class='line'>Display();
</span><span class='line'>}
</span><span class='line'>void BestFit_new()
</span><span class='line'>{
</span><span class='line'>int i,j,k,flag,size;
</span><span class='line'>char temp[10];
</span><span class='line'>printf(“How Many MEMORY require?”);
</span><span class='line'>scanf(“%d”,&size);
</span><span class='line'>j = 0;
</span><span class='line'>flag = 0;
</span><span class='line'>k = MEMSIZE;
</span><span class='line'>for(i=0;i&lt;MEMSIZE – 1 && MemList[i].info!=’e';i++){
</span><span class='line'>if(MemList[i].size &gt;= size && MemList[i].info == ‘f’){
</span><span class='line'>flag = 1;
</span><span class='line'>if(MemList[i].size &lt; k){
</span><span class='line'>k = MemList[i].size;
</span><span class='line'>j = i;
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>i=j;
</span><span class='line'>if(flag == 0)
</span><span class='line'>{
</span><span class='line'>printf(“NOT ENOUGH Memory!\n”);
</span><span class='line'>getchar();
</span><span class='line'>}
</span><span class='line'>else if(MemList[i].size – size &lt;= MINSIZE)
</span><span class='line'>MemList[i].info = ‘u’;
</span><span class='line'>else{
</span><span class='line'>for(j=MEMSIZE-2;j &gt; i;j–){
</span><span class='line'>MemList[j+1]=MemList[j];
</span><span class='line'>}
</span><span class='line'>MemList[i].start = MemList[i].start + size;
</span><span class='line'>MemList[i].size = MemList[i].size – size;
</span><span class='line'>MemList[i].info = ‘f’;
</span><span class='line'>MemList[i].size = size;
</span><span class='line'>MemList[i].info = ‘u’;
</span><span class='line'>}
</span><span class='line'>Display();
</span><span class='line'>}
</span><span class='line'>void del()
</span><span class='line'>{
</span><span class='line'>int i,number;
</span><span class='line'>printf(“please input the NUMBER you want to delete:”);
</span><span class='line'>scanf(“%d”,&number);
</span><span class='line'>if(MemList[number].info == ‘u’){
</span><span class='line'>MemList[number].info = ‘f’;
</span><span class='line'>if(MemList[number+1].info==’f'){
</span><span class='line'>MemList[number].size += MemList[number+1].size;
</span><span class='line'>for(i=number+1;i&lt;MEMSIZE – 1 && MemList[i].info!=’e';i++)
</span><span class='line'>MemList[i]=MemList[i+1];
</span><span class='line'>}
</span><span class='line'>if(MemList[number - 1].info != ‘f’){
</span><span class='line'>MemList[number -1].size += MemList[number].size;
</span><span class='line'>for(i=number;i&lt;MEMSIZE – 1 && MemList[i].info!=’e';i++)
</span><span class='line'>MemList[i]=MemList[i+1];
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>else{
</span><span class='line'>printf(“This number is NOT exits or is NOT sued!\n”);
</span><span class='line'>getchar();
</span><span class='line'>}
</span><span class='line'>Display();
</span><span class='line'>}
</span><span class='line'>void Display()
</span><span class='line'>{
</span><span class='line'>int i,used = 0;
</span><span class='line'>printf(“\n——————————————\n”);
</span><span class='line'>printf(“%5s %15s %15s”,”Number”,”Start”,”Size”,”info”);
</span><span class='line'>printf(“\n——————————————\n”);
</span><span class='line'>for(i=0;i&lt;MEMSIZE && MemList[i].info != ‘e’;i++){
</span><span class='line'>if(MemList[i].info == ‘u’)
</span><span class='line'>used+= MemList[i].size;
</span><span class='line'>printf(“%5d %15d %15d %15s\n”,i,MemList[i].start,MemList[i].size,MemList[i].info == ‘u’?”USED”:”FREE”);
</span><span class='line'>}
</span><span class='line'>printf(“\n——————————————\n”);
</span><span class='line'>printf(“TotalSize : %-10d Used: %-10d Free:%-10d\n”,MEMSIZE,used,MEMSIZE – used);
</span><span class='line'>printf(“\n\nPress Any Key to Return\n”);
</span><span class='line'>getchar();
</span><span class='line'>}
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>char ch;
</span><span class='line'>InitAll();
</span><span class='line'>while(1)
</span><span class='line'>{
</span><span class='line'>printf(“   Memory manager  \n”);
</span><span class='line'>printf(“================================================\n”);
</span><span class='line'>printf(“1. Get a block use the FIRSTFIT method\n”);
</span><span class='line'>printf(“2. Get a block use the BESTFFIT method\n”);
</span><span class='line'>printf(“3. Free or delete a block\n”);
</span><span class='line'>printf(“4. Display Mem information\n”);
</span><span class='line'>printf(“5. Exit\n”);
</span><span class='line'>printf(“================================================\n”);
</span><span class='line'>ch = getchar();
</span><span class='line'>switch(ch){
</span><span class='line'>case ’1′:
</span><span class='line'>FirstFit_new();
</span><span class='line'>break;
</span><span class='line'>case ’2′:
</span><span class='line'>BestFit_new();
</span><span class='line'>break;
</span><span class='line'>case ’3′:
</span><span class='line'>del();
</span><span class='line'>break;
</span><span class='line'>case ’4′:
</span><span class='line'>Display();
</span><span class='line'>break;
</span><span class='line'>case ’5′:
</span><span class='line'>exit(0);
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tcp疑难全景解析]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/tcpyi-nan-quan-jing-jie-xi/"/>
    <updated>2013-05-19T11:01:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/tcpyi-nan-quan-jing-jie-xi</id>
    <content type="html"><![CDATA[<p> 转自<a href="http://blog.csdn.net/dog250/article/details/6612496#comments">http://blog.csdn.net/dog250/article/details/6612496#comments</a></p>

<p>说明：</p>

<p>1).本文以TCP的发展历程解析容易引起混淆，误会的方方面面
2).本文不会贴大量的源码，大多数是以文字形式描述，我相信文字看起来是要比代码更轻松的
3).针对对象：对TCP已经有了全面了解的人。因为本文不会解析TCP头里面的每一个字段或者3次握手的细节，也不会解释慢启动和快速重传的定义
4).除了《TCP/IP详解》(卷一，卷二)以及《Unix网络编程》以及Linux源代码之外，学习网络更好的资源是RFC</p>

<p>5).本文给出一个提纲，如果想了解细节，请直接查阅RFC</p>

<p>6).翻来覆去，终于找到了这篇备忘，本文基于这篇备忘文档修改。</p>

<p>1.网络协议设计</p>

<p>ISO提出了OSI分层网络模型，这种分层模型是理论上的，TCP/IP最终实现了一个分层的协议模型，每一个层次对应一组网络协议完成一组特定的功能，该组网络协议被其下的层次复用和解复用。这就是分层模型的本质，最终所有的逻辑被编码到线缆或者电磁波。
分层模型是很好理解的，然而对于每一层的协议设计却不是那么容易。TCP/IP的漂亮之处在于：协议越往上层越复杂。我们把网络定义为互相连接在一起的设备，网络的本质作用还是“端到端”的通信，然而希望互相通信的设备并不一定要“直接”连接在一起，因此必然需要一些中间的设备负责转发数据，因此就把连接这些中间设备的线缆上跑的协议定义为链路层协议，实际上所谓链路其实就是始发与一个设备，通过一根线，终止于另一个设备。我们把一条链路称为“一跳”。因此一个端到端的网络包含了“很多跳”。
2.TCP和IP协议</p>

<p>终止于IP协议，我们已经可以完成一个端到端的通信，为何还需要TCP协议？这是一个问题，理解了这个问题，我们就能理解TCP协议为何成了现在这个样子，为何如此“复杂”，为何又如此简单。
正如其名字所展示的那样，TCP的作用是传输控制，也就是控制端到端的传输，那为何这种控制不在IP协议中实现的。答案很简单，那就是这会增加IP协议的复杂性，而IP协议需要的就是简单。这是什么原因造成的呢？
首先我们认识一下为何IP协议是沙漏的细腰部分。它的下层是繁多的链路层协议，这些链路提供了相互截然不同且相差很远的语义，为了互联这些异构的网络，我们需要一个网络层协议起码要提供一些适配的功能，另外它必然不能提供太多的“保证性服务”，因为上层的保证性依赖下层的约束性更强的保证性，你永远无法在一个100M吞吐量的链路之上实现的IP协议保证1000M的吞吐量…
IP协议设计为分组转发协议，每一跳都要经过一个中间节点，路由的设计是TCP/IP网络的另一大创举，这样，IP协议就无需方向性，路由信息和协议本身不再强关联，它们仅仅通过IP地址来关联，因此，IP协议更加简单。路由器作为中间节点也不能太复杂，这涉及到成本问题，因此路由器只负责选路以及转发数据包。
因此传输控制协议必然需要在端点实现。在我们详谈TCP协议之前，首先要看一下它不能做什么，由于IP协议不提供保证，TCP也不能提供依赖于IP下层链路的这种保证，比如带宽，比如时延，这些都是链路层决定的，既然IP协议无法修补，TCP也不能，然而它却能修正始于IP层的一些“不可保证性质”，这些性质包括IP层的不可靠，IP层的不按顺序，IP层的无方向/无连接。
将该小节总结一下，TCP/IP模型从下往上，功能增加，需要实现的设备减少，然而设备的复杂性却在增加，这样保证了成本的最小化，至于性能或者因素，靠软件来调节吧，TCP协议就是这样的软件，实际上最开始的时候，TCP并不考虑性能，效率，公平性，正是考虑了这些，TCP协议才复杂了起来。
3.TCP协议</p>

<p>这是一个纯软件协议，为何将其设计上两个端点，参见上一小节，本节详述TCP协议，中间也穿插一些简短的论述。
3.1.TCP协议</p>

<p>确切的说，TCP协议有两重身份，作为网络协议，它弥补了IP协议尽力而为服务的不足，实现了有连接，可靠传输，报文按序到达。作为一个主机软件，它和UDP以及左右的传输层协议隔离了主机服务和网络，它们可以被看做是一个多路复用/解复用器，将诸多的主机进程数据复用/解复用到IP层。可以看出，不管从哪个角度，TCP都作为一个接口存在，作为网络协议，它和对端的TCP接口，实现TCP的控制逻辑，作为多路复用/解复用器，它和下层IP协议接口，实现协议栈的功能，而这正是分层网络协议模型的基本定义(两类接口，一类和下层接口，另一类和对等层接口)。
我们习惯于将TCP作为协议栈的最顶端，而不把应用层协议当成协议栈的一部分，这部分是因为应用层被TCP/UDP解复用了之后，呈现出了一种太复杂的局面，应用层协议用一种不同截然不同的方式被解释，应用层协议习惯于用类似ASN.1标准来封装，这正体现了TCP协议作为多路复用/解复用器的重要性，由于直接和应用接口，它可以很容易直接被应用控制，实现不同的传输控制策略，这也是TCP被设计到离应用不太远的地方的原因之一。
总之，TCP要点有四，一曰有连接，二曰可靠传输，三曰数据按照到达，四曰端到端流量控制。注意，TCP被设计时只保证这四点，此时它虽然也有些问题，然而很简单，然而更大的问题很快呈现出来，使之不得不考虑和IP网络相关的东西，比如公平性，效率，因此增加了拥塞控制，这样TCP就成了现在这个样子。
3.2.有连接，可靠传输，数据按序到达的TCP</p>

<p>IP协议是没有方向的，数据报传输能到达对端全靠路由，因此它是一跳一跳地到达对端的，只要有一跳没有到达对端的路由，那么数据传输将失败，其实路由也是互联网的核心之一，实际上IP层提供的核心基本功能有两点，第一点是地址管理，第二点就是路由选路。TCP利用了IP路由这个简单的功能，因此TCP不必考虑选路，这又一个它被设计成端到端协议的原因。
既然IP已经能尽力让单独的数据报到达对端，那么TCP就可以在这种尽力而为的网络上实现其它的更加严格的控制功能。TCP给无连接的IP网络通信增加了连接性，确认了已经发送出去的数据的状态，并且保证了数据的顺序。
3.2.1.有连接</p>

<p>这是TCP的基本，因为后续的传输的可靠性以及数据顺序性都依赖于一条连接，这是最简单的实现方式，因此TCP被设计成一种基于流的协议，既然TCP需要事先建立连接，之后传输多少数据就无所谓了，只要是同一连接的数据能识别出来即可。
疑难杂症1：3次握手和4次挥手
TCP使用3次握手建立一条连接，该握手初始化了传输可靠性以及数据顺序性必要的信息，这些信息包括两个方向的初始序列号，确认号由初始序列号生成，使用3次握手是因为3次握手已经准备好了传输可靠性以及数据顺序性所必要的信息，该握手的第3次实际上并不是需要单独传输的，完全可以和数据一起传输。
TCP使用4次挥手拆除一条连接，为何需要4次呢？因为TCP是一个全双工协议，必须单独拆除每一条信道。注意，4次挥手和3次握手的意义是不同的，很多人都会问为何建立连接是3次握手，而拆除连接是4次挥手。3次握手的目的很简单，就是分配资源，初始化序列号，这时还不涉及数据传输，3次就足够做到这个了，而4次挥手的目的是终止数据传输，并回收资源，此时两个端点两个方向的序列号已经没有了任何关系，必须等待两方向都没有数据传输时才能拆除虚链路，不像初始化时那么简单，发现SYN标志就初始化一个序列号并确认SYN的序列号。因此必须单独分别在一个方向上终止该方向的数据传输。
疑难杂症2：TIME_WAIT状态
为何要有这个状态，原因很简单，那就是每次建立连接的时候序列号都是随机产生的，并且这个序列号是32位的，会回绕。现在我来解释这和TIME_WAIT有什么关系。
任何的TCP分段都要在尽力而为的IP网络上传输，中间的路由器可能会随意的缓存任何的IP数据报，它并不管这个IP数据报上被承载的是什么数据，然而根据经验和互联网的大小，一个IP数据报最多存活MSL(这是根据地球表面积，电磁波在各种介质中的传输速率以及IP协议的TTL等综合推算出来的，如果在火星上，这个MSL会大得多…)。
现在我们考虑终止连接时的被动方发送了一个FIN，然后主动方回复了一个ACK，然而这个ACK可能会丢失，这会造成被动方重发FIN，这个FIN可能会在互联网上存活MSL。
如果没有TIME_WAIT的话，假设连接1已经断开，然而其被动方最后重发的那个FIN(或者FIN之前发送的任何TCP分段)还在网络上，然而连接2重用了连接1的所有的5元素(源IP，目的IP，TCP，源端口，目的端口)，刚刚将建立好连接，连接1迟到的FIN到达了，这个FIN将以比较低但是确实可能的概率终止掉连接2.
为何说是概率比较低呢？这涉及到一个匹配问题，迟到的FIN分段的序列号必须落在连接2的一方的期望序列号范围之内。虽然这种巧合很少发生，但确实会发生，毕竟初始序列号是随机产生了。因此终止连接的主动方必须在接受了被动方且回复了ACK之后等待2*MSL时间才能进入CLOSE状态，之所以乘以2是因为这是保守的算法，最坏情况下，针对被动方的ACK在以最长路线(经历一个MSL)经过互联网马上到达被动方时丢失。
为了应对这个问题，RFC793对初始序列号的生成有个建议，那就是设定一个基准，在这个基准之上搞随机，这个基准就是时间，我们知道时间是单调递增的。然而这仍然有问题，那就是回绕问题，如果发生回绕，那么新的序列号将会落到一个很低的值。因此最好的办法就是避开“重叠”，其含义就是基准之上的随机要设定一个范围。
要知道，很多人很不喜欢看到服务器上出现大量的TIME_WAIT状态的连接，因此他们将TIME_WAIT的值设置的很低，这虽然在大多数情况下可行，然而确实也是一种冒险行为。最好的方式就是，不要重用一个连接。
疑难杂症3：重用一个连接和重用一个套接字
这是根本不同的，单独重用一个套接字一般不会有任何问题，因为TCP是基于连接的。比如在服务器端出现了一个TIME_WAIT连接，那么该连接标识了一个五元素，只要客户端不使用相同的源端口，连接服务器是没有问题的，因为迟到的FIN永远不会到达这个连接。记住，一个五元素标识了一个连接，而不是一个套接字(当然，对于BSD套接字而言，服务端的accept套接字确实标识了一个连接)。
3.2.2.传输可靠性</p>

<p>基本上传输可靠性是靠确认号实现的，也就是说，每发送一个分段，接下来接收端必然要发送一个确认，发送端收到确认后才可以发送下一个字节。这个原则最简单不过了，教科书上的“停止-等待”协议就是这个原则的字节版本，只是TCP使用了滑动窗口机制使得每次不一定发送一个字节，但是这是后话，本节仅仅谈一下确认的超时机制。
怎么知道数据到达对端呢？那就是对端发送一个确认，但是如果一直收不到对端的确认，发送端等多久呢？如果一直等下去，那么将无法发现数据的丢失，协议将不可用，如果等待时间过短，可能确认还在路上，因此等待时间是个问题，另外如何去管理这个超时时间也是一个问题。
疑难杂症4：超时时间的计算
绝对不能随意去揣测超时的时间，而应该给出一个精确的算法去计算。毫无疑问，一个TCP分段的回复到达的时间就是一个数据报往返的时间，因此标准定义了一个新的名词RTT，代表一个TCP分段的往返时间。然而我们知道，IP网络是尽力而为的，并且路由是动态的，且路由器会毫无先兆的缓存或者丢弃任何的数据报，因此这个RTT是需要动态测量的，也就是说起码每隔一段时间就要测量一次，如果每次都一样，万事大吉，然而世界并非如你所愿，因此我们需要找到的恰恰的一个“平均值”，而不是一个准确值。
这个平均值如果仅仅直接通过计算多次测量值取算术平均，那是不恰当的，因为对于数据传输延时，我们必须考虑的路径延迟的瞬间抖动，否则如果两次测量值分别为2和98，那么超时值将是50，这个值对于2而言，太大了，结果造成了数据的延迟过大(本该重传的等待了好久才重传)，然而对于98而言，太小了，结果造成了过度重传(路途遥远，本该很慢，结果大量重传已经正确确认但是迟到的TCP分段)。
因此，除了考虑每两次测量值的偏差之外，其变化率也应该考虑在内，如果变化率过大，则通过以变化率为自变量的函数为主计算RTT(如果陡然增大，则取值为比较大的正数，如果陡然减小，则取值为比较小的负数，然后和平均值加权求和)，反之如果变化率很小，则取测量平均值。这是不言而喻的，这个算法至今仍然工作的很好。
疑难杂症5：超时计时器的管理-每连接单一计时器
很显然，对每一个TCP分段都生成一个计时器是最直接的方式，每个计时器在RTT时间后到期，如果没有收到确认，则重传。然而这只是理论上的合理，对于大多数操作系统而言，这将带来巨大的内存开销和调度开销，因此采取每一个TCP连接单一计时器的设计则成了一个默认的选择。可是单一的计时器怎么管理如此多的发出去的TCP分段呢？又该如何来设计单一的计时器呢。
设计单一计时器有两个原则：1.每一个报文在长期收不到确认都必须可以超时；2.这个长期收不到中长期不能和测量的RTT相隔太远。因此RFC2988定义一套很简单的原则：
a.发送TCP分段时，如果还没有重传定时器开启，那么开启它。
b.发送TCP分段时，如果已经有重传定时器开启，不再开启它。
c.收到一个非冗余ACK时，如果有数据在传输中，重新开启重传定时器。
d.收到一个非冗余ACK时，如果没有数据在传输中，则关闭重传定时器。
我们看看这4条规则是如何做到以上两点的，根据a和c(在c中，注意到ACK是非冗余的)，任何TCP分段只要不被确认，超时定时器总会超时的。然而为何需要c呢？只有规则a存在的话，也可以做到原则1。实际上确实是这样的，但是为了不会出现过早重传，才添加了规则c，如果没有规则c，那么万一在重传定时器到期前，发送了一些数据，这样在定时器到期后，除了很早发送的数据能收到ACK外，其它稍晚些发送的数据的ACK都将不会到来，因此这些数据都将被重传。有了规则c之后，只要有分段ACK到来，则重置重传定时器，这很合理，因此大多数正常情况下，从数据的发出到ACK的到来这段时间以及计算得到的RTT以及重传定时器超时的时间这三者相差并不大，一个ACK到来后重置定时器可以保护后发的数据不被过早重传。
这里面还有一些细节需要说明。一个ACK到来了，说明后续的ACK很可能会依次到来，也就是说丢失的可能性并不大，另外，即使真的有后发的TCP分段丢失现象发生，也会在最多2倍定时器超时时间的范围内被重传(假设该报文是第一个报文发出启动定时器之后马上发出的，丢失了，第一个报文的ACK到来后又重启了定时器，又经过了一个超时时间才会被重传)。虽然这里还没有涉及拥塞控制，但是可见网络拥塞会引起丢包，丢包会引起重传，过度重传反过来加重网络拥塞，设置规则c的结果可以缓解过多的重传，毕竟将启动定时器之后发送的数据的重传超时时间拉长了最多一倍左右。最多一倍左右的超时偏差做到了原则2，即“这个长期收不到中长期不能和测量的RTT相隔太远”。
还有一点，如果是一个发送序列的最后一个分段丢失了，后面就不会收到冗余ACK，这样就只能等到超时了，并且超时时间几乎是肯定会比定时器超时时间更长。如果这个分段是在发送序列的靠后的时间发送的且和前面的发送时间相隔时间较远，则其超时时间不会很大，反之就会比较大。
疑难杂症6：何时测量RTT
目前很多TCP实现了时间戳，这样就方便多了，发送端再也不需要保存发送分段的时间了，只需要将其放入协议头的时间戳字段，然后接收端将其回显在ACK即可，然后发送端收到ACK后，取出时间戳，和当前时间做算术差，即可完成一次RTT的测量。
3.2.3.数据顺序性</p>

<p>基本上传输可靠性是靠序列号实现的。
疑难杂症7：确认号和超时重传
确认号是一个很诡异的东西，因为TCP的发送端对于发送出去的一个数据序列，它只要收到一个确认号就认为确认号前面的数据都被收到了，即使前面的某个确认号丢失了，也就是说，发送端只认最后一个确认号。这是合理的，因为确认号是接收端发出的，接收端只确认按序到达的最后一个TCP分段。
另外，发送端重发了一个TCP报文并且接收到该TCP分段的确认号，并不能说明这个重发的报文被接收了，也可能是数据早就被接收了，只是由于其ACK丢失或者其ACK延迟到达导致了超时。值得说明的是，接收端会丢弃任何重复的数据，即使丢弃了重复的数据，其ACK还是会照发不误的。
标准的早期TCP实现为，只要一个TCP分段丢失，即使后面的TCP分段都被完整收到，发送端还是会重传从丢失分段开始的所有报文，这就会导致一个问题，那就是重传风暴，一个分段丢失，引起大量的重传。这种风暴实则不必要的，因为大多数的TCP实现中，接收端已经缓存了乱序的分段，这些被重传的丢失分段之后的分段到达接收端之后，很大的可能性是被丢弃。关于这一点在拥塞控制被引入之后还会提及(问题先述为快：本来报文丢失导致超时就说明网络很可能已然拥塞，重传风暴只能加重其拥塞程度)。
疑难杂症8：乱序数据缓存以及选择确认
TCP是保证数据顺序的，但是并不意味着它总是会丢弃乱序的TCP分段，具体会不会丢弃是和具体实现相关的，RFC建议如果内存允许，还是要缓存这些乱序到来的分段，然后实现一种机制等到可以拼接成一个按序序列的时候将缓存的分段拼接，这就类似于IP协议中的分片一样，但是由于IP数据报是不确认的，因此IP协议的实现必须缓存收到的任何分片而不能将其丢弃，因为丢弃了一个IP分片，它就再也不会到来了。
现在，TCP实现了一种称为选择确认的方式，接收端会显式告诉发送端需要重传哪些分段而不需要重传哪些分段。这无疑避免了重传风暴。
疑难杂症9：TCP序列号的回绕的问题
TCP的序列号回绕会引起很多的问题，比如序列号为s的分段发出之后，m秒后，序列号比s小的序列号为j的分段发出，只不过此时的j比上一个s多了一圈，这就是回绕问题，那么如果这后一个分段到达接收端，这就会引发彻底乱序-本来j该在s后面，结果反而到达前面了，这种乱序是TCP协议检查不出来的。我们仔细想一下，这种情况确实会发生，数据分段并不是一个字节一个字节发送出去的，如果存在一个速率为1Gbps的网络，TCP发送端1秒会发送125MB的数据，32位的序列号空间能传输2的32次方个字节，也就是说32秒左右就会发生回绕，我们知道这个值远小于MSL值，因此会发生的。
有个细节可能会引起误会，那就是TCP的窗口大小空间是序列号空间的一半，这样恰好在满载情况下，数据能填满发送窗口和接收窗口，序列号空间正好够用。然而事实上，TCP的初始序列号并不是从0开始的，而是随机产生的(当然要辅助一些更精妙的算法)，因此如果初始序列号比较接近2的32次方，那么很快就会回绕。
当然，如今可以用时间戳选项来辅助作为序列号的一个识别的部分，接收端遇到回绕的情况，需要比较时间戳，我们知道，时间戳是单调递增的，虽然也会回绕，然而回绕时间却要长很多。这只是一种策略，在此不详谈。还有一个很现实的问题，理论上序列号会回绕，但是实际上，有多少TCP的端点主机直接架设在1G的网络线缆两端并且接收方和发送方的窗口还能恰好被同时填满。另外，就算发生了回绕，也不是一件特别的事情，回绕在计算机里面太常见了，只需要能识别出来即可解决，对于TCP的序列号而言，在高速网络(点对点网络或者以太网)的两端，数据发生乱序的可能性很小，因此当收到一个序列号突然变为0或者终止序列号小于起始序列号的情况后，很容易辨别出来，只需要和前一个确认的分段比较即可，如果在一个经过路由器的网络两端，会引发IP数据报的顺序重排，对于TCP而言，虽然还会发生回绕，也会慢得多，且考虑到拥塞窗口(目前还没有引入)一般不会太大，窗口也很难被填满到65536。
3.2.4.端到端的流量控制</p>

<p>端到端的流量控制使用滑动窗口来实现。滑动窗口的原理非常简单，基本就是一个生产者/消费者模型
疑难杂症10：流量控制的真实意义
很多人以为流量控制会很有效的协调两端的流量匹配，确实是这样，但是如果你考虑到网络的利用率问题，TCP的流量控制机制就不那么完美了，造成这种局面的原因在于，滑动窗口只是限制了最大发送的数据，却没有限制最小发送的数据，结果导致一些很小的数据被封装成TCP分段，报文协议头所占的比例过于大，造成网络利用率下降，这就引出了接下来的内容，那就是端到端意义的TCP协议效率。
<del>
承上启下
终于到了阐述问题的时候了，以上的TCP协议实现的非常简单，这也是TCP的标准实现，然而很快我们就会发现各种各样的问题。这些问题导致了标准化协会对TCP协议进行了大量的修补，这些修补杂糅在一起让人们有些云里雾里，不知所措。本文档就旨在分离这些杂乱的情况，实际上，根据RFC，这些杂乱的情况都是可以找到其单独的发展轨迹的。
</del></p>

<p>4.端到端意义上的TCP协议效率</p>

<p>4.1.三个问题以及解决</p>

<p>问题1描述：接收端处理慢，导致接收窗口被填满
这明显是速率不匹配引发的问题，然而即使速率不匹配，只要滑动窗口能协调好它们的速率就好，要快都快，要慢都慢，事实上滑动窗口在这一点上做的很好。但是如果我们不得不从效率上来考虑问题的话，事实就不那么乐观了。考虑此时接收窗口已然被填满，慢速的应用程序慢腾腾的读取了一个字节，空出一个位置，然后通告给TCP的发送端，发送端得知空出一个位置，马上发出一个字节，又将接收端填满，然后接收应用程序又一次慢腾腾…这就是糊涂窗口综合症，一个大多数人都很熟悉的词。这个问题极大的浪费了网络带宽，降低了网络利用率。好比从大同拉100吨煤到北京需要一辆车，拉1Kg煤到北京也需要一辆车(超级夸张的一个例子，请不要相信)，但是一辆车开到北京的开销是一定的…
问题1解决：窗口通告
对于问题1，很显然问题出在接收端，我们没有办法限制发送端不发送小分段，但是却可以限制接收端通告小窗口，这是合理的，这并不影响应用程序，此时经典的延迟/吞吐量反比律将不再适用，因为接收窗口是满的，其空出一半空间表示还有一半空间有数据没有被应用读取，和其空出一个字节的空间的效果是一样的，因此可以限制接收端当窗口为0时，直接通告给发送端以阻止其继续发送数据，只有当其接收窗口再次达到MSS的一半大小的时候才通告一个不为0的窗口，此前对于所有的发送端的窗口probe分段(用于探测接收端窗口大小的probe分段，由TCP标准规定)，全部通告窗口为0，这样发送端在收到窗口不为0的通告，那么肯定是一个比较大的窗口，因此发送端可以一次性发出一个很大的TCP分段，包含大量数据，也即拉了好几十吨的煤到北京，而不是只拉了几公斤。
即，限制窗口通告时机，解决糊涂窗口综合症
问题2描述：发送端持续发送小包，导致窗口闲置
这明显是发送端引起的问题，此时接收端的窗口开得很大，然而发送端却不积累数据，还是一味的发送小块数据分段。只要发送了任和的分段，接收端都要无条件接收并且确认，这完全符合TCP规范，因此必然要限制发送端不发送这样的小分段。
问题2解决：Nagle算法
Nagel算法很简单，标准的Nagle算法为：
IF 数据的大小和窗口的大小都超过了MSS
Then 发送数据分段
ELSE
IF 还有发出的TCP分段的确认没有到来
Then 积累数据到发送队列的末尾的TCP分段
ELSE
发送数据分段
EndIF
EndIF
可是后来，这个算法变了，变得更加灵活了，其中的：
IF 还有发出的TCP分段的确认没有到来
变成了
IF 还有发出的不足MSS大小的TCP分段的确认没有到来
这样如果发出了一个MSS大小的分段还没有被确认，后面也是可以随时发送一个小分段的，这个改进降低了算法对延迟时间的影响。这个算法体现了一种自适应的策略，越是确认的快，越是发送的快，虽然Nagle算法看起来在积累数据增加吞吐量的同时也加大的时延，可事实上，如果对于类似交互式的应用，时延并不会增加，因为这类应用回复数据也是很快的，比如Telnet之类的服务必然需要回显字符，因此能和对端进行自适应协调。
注意，Nagle算法是默认开启的，但是却可以关闭。如果在开启的情况下，那么它就严格按照上述的算法来执行。
问题3.确认号(ACK)本身就是不含数据的分段，因此大量的确认号消耗了大量的带宽
这是TCP为了确保可靠性传输的规范，然而大多数情况下，ACK还是可以和数据一起捎带传输的。如果没有捎带传输，那么就只能单独回来一个ACK，如果这样的分段太多，网络的利用率就会下降。从大同用火车拉到北京100吨煤，为了确认煤已收到，北京需要派一辆同样的火车空载开到大同去复命，因为没有别的交通工具，只有火车。如果这位复命者刚开着一列火车走，又从大同来了一车煤，这拉煤的哥们儿又要开一列空车去复命了。
问题3的解决：
RFC建议了一种延迟的ACK，也就是说，ACK在收到数据后并不马上回复，而是延迟一段可以接受的时间，延迟一段时间的目的是看能不能和接收方要发给发送方的数据一起回去，因为TCP协议头中总是包含确认号的，如果能的话，就将ACK一起捎带回去，这样网络利用率就提高了。往大同复命的确认者不必开一辆空载火车回大同了，此时北京正好有一批货物要送往大同，这位复命者搭着这批货的火车返回大同。
如果等了一段可以接受的时间，还是没有数据要发往发送端，此时就需要单独发送一个ACK了，然而即使如此，这个延迟的ACK虽然没有等到可以被捎带的数据分段，也可能等到了后续到来的TCP分段，这样它们就可以取最大者一起返回了，要知道，TCP的确认号是收到的按序报文的最后一个字节的后一个字节。最后，RFC建议，延迟的ACK最多等待两个分段的积累确认。
4.2.分析三个问题之间的关联</p>

<p>三个问题导致的结果是相同的，但是要知道它们的原因本质上是不同的，问题1几乎总是出现在接收端窗口满的情况下，而问题2几乎总是发生在窗口闲置的情况下，问题3看起来是最无聊的，然而由于TCP的要求，必须要有确认号，而且一个确认号就需要一个TCP分段，这个分段不含数据，无疑是很小的。
三个问题都导致了网络利用率的降低。虽然两个问题导致了同样的结果，但是必须认识到它们是不同的问题，很自然的将这些问题的解决方案汇总在一起，形成一个全局的解决方案，这就是如今的操作系统中的解决方案。
4.3.问题的杂糅情况</p>

<p>疑难杂症11：糊涂窗口解决方案和Nagle算法
糊涂窗口综合症患者希望发送端积累TCP分段，而Nagle算法确实保证了一定的TCP分段在发送端的积累，另外在延迟ACK的延迟的那一会时间，发送端会利用这段时间积累数据。然而这却是三个不同的问题。Nagle算法可以缓解糊涂窗口综合症，却不是治本的良药。
疑难杂症12：Nagle算法和延迟ACK
延迟ACK会延长ACK到达发送端的时间，由于标准Nagle算法只允许一个未被确认的TCP分段，那无疑在接收端，这个延迟的ACK是毫无希望等待后续数据到来最终进行积累确认的，如果没有数据可以捎带这个ACK，那么这个ACK只有在延迟确认定时器超时的时候才会发出，这样在等待这个ACK的过程中，发送端又积累了一些数据，因此延迟ACK实际上是在增加延迟的代价下加强了Nagle算法。在延迟ACK加Nagle算法的情况下，接收端只有不断有数据要发回，才能同时既保证了发送端的分段积累，又保证了延迟不增加，同时还没有或者很少有空载的ACK。
要知道，延迟ACK和Nagle是两个问题的解决方案。
疑难杂症13：到底何时可以发送数据
到底何时才能发送数据呢？如果单从Nagle算法上看，很简单，然而事实证明，情况还要更复杂些。如果发送端已经排列了3个TCP分段，分段1，分段2，分段3依次被排入，三个分段都是小分段(不符合Nagle算法中立即发送的标准)，此时已经有一个分段被发出了，且其确认还没有到来，请问此时能发送分段1和2吗？如果按照Nagle算法，是不能发送的，但实际上它们是可以发送的，因为这两个分段已经没有任何机会再积累新的数据了，新的数据肯定都积累在分段3上了。问题在于，分段还没有积累到一定大小时，怎么还可以产生新的分段？这是可能的，但这是另一个问题，在此不谈。
Linux的TCP实现在这个问题上表现的更加灵活，它是这么判断能否发送的(在开启了Nagle的情况下)：
IF (没有超过拥塞窗口大小的数据分段未确认 || 数据分段中包含FIN ) &amp;&amp;
数据分段没有超越窗口边界
Then
IF 分段在中间(上述例子中的分段1和2) ||
分段是紧急模式 ||
通过上述的Nagle算法(改进后的Nagle算法)
Then 发送分段
EndIF
EndIF
曾经我也改过Nagle算法，确切的说不是修改Nagle算法，而是修改了“到底何时能发送数据”的策略，以往都是发送端判断能否发送数据的，可是如果此时有延迟ACK在等待被捎带，而待发送的数据又由于积累不够或者其它原因不能发送，因此两边都在等，这其实在某些情况下不是很好。我所做的改进中对待何时能发送数据又增加了一种情况，这就是“ACK拉”的情况，一旦有延迟ACK等待发送，判断一下有没有数据也在等待发送，如果有的话，看看数据是否大到了一定程度，在此，我选择的是MSS的一半：
IF (没有超过拥塞窗口大小的数据分段未确认 || 数据分段中包含FIN ) &amp;&amp;
数据分段没有超越窗口边界
Then
IF 分段在中间(上述例子中的分段1和2) ||
分段是紧急模式 ||
通过上述的Nagle算法(改进后的Nagle算法)
Then 发送分段
EndIF
ELSE IF 有延迟ACK等待传输 &amp;&amp;
发送队列中有待发送的TCP分段 &amp;&amp;
发送队列的头分段大小大于MSS的一半
Then 发送队列头分段且捎带延迟ACK
EndIF
另外，发送队列头分段的大小是可以在统计意义上动态计算的，也不一定非要是MSS大小的一半。我们发现，这种算法对于交互式网路应用是自适应的，你打字越快，特定时间内积累的分段就越长，对端回复的越快(可以捎带ACK)，本端发送的也就越快(以Echo举例会更好理解)。
疑难杂症14：《TCP/IP详解(卷一)》中Nagle算法的例子解读
这个问题在网上搜了很多的答案，有的说RFC的建议，有的说别的。可是实际上这就是一个典型的“竞态问题”：
首先服务器发了两个分段：
数据段12：ack 14
数据段13：ack 14，54:56
然后客户端发了两个分段：
数据段14：ack 54，14:17
数据段15：ack 56，17:18
可以看到数据段14本来应该确认56的，但是确认的却是54。也就是说，数据段已经移出队列将要发送但还未发送的时候，数据段13才到来，软中断处理程序抢占了数据段14的发送进程，要知道此时只是把数据段14移出了队列，还没有更新任何的状态信息，比如“发出但未被确认的分段数量”，此时软中断处理程序顺利接收了分段13，然后更新窗口信息，并且检查看有没有数据要发送，由于分段14已经移出队列，下一个接受发送检查的就是分段15了，由于状态信息还没有更新，因此分段15顺利通过发送检测，发送完成。
可以看Linux的源代码了解相关信息，tcp_write_xmit这个函数在两个地方会被调用，一个是TCP的发送进程中，另一个就是软中断的接收处理中，两者在调用中的竞态就会引起《详解》中的那种情况。注意，这种不加锁的发送方式是合理的，也是最高效的，因此TCP的处理语义会做出判断，丢弃一切不该接收或者重复接收的分段的。
<del>
承上启下
又到了该承上启下，到此为止，我们叙述的TCP还都是简单的TCP，就算是简单的TCP，也存在上述的诸多问题，就更别提继续增加TCP的复杂性了。到此为止，我们的TCP都是端到端意义上的，然而实际上TCP要跑在IP网络之上的，而IP网络的问题是很多的，是一个很拥堵网络。不幸的是，TCP的有些关于确认和可靠性的机制还会加重IP网络的拥堵。
</del></p>

<p>5.IP网络之上的TCP</p>

<p>5.1.端到端的TCP协议和IP协议之间的矛盾</p>

<p>端到端的TCP只能看到两个节点，那就是自己和对方，它们是看不到任何中间的路径的。可是IP网络却是一跳一跳的，它们的矛盾之处在于TCP的端到端流量控制必然会导致网络拥堵。因为每条TCP连接的一端只知道它对端还有多少空间用于接收数据，它们并不管到达对端的路径上是否还有这么大的容量，事实上所有连接的这些空间加在一起将瞬间超过IP网络的容量，因此TCP也不可能按照滑动窗口流量控制机制很理想的运行。
势必需要一种拥塞控制机制，反应路径的拥塞情况。
疑难杂症15：拥塞控制的本质
由于TCP是端到端协议，因此两端之间的控制范畴属于流量控制，IP网络的拥塞会导致TCP分段的丢失，由于TCP看不到中间的路由器，因此这种丢失只会发生中间路由器，当然两个端点的网卡或者IP层丢掉数据分段也是TCP看不到的。因此拥塞控制必然作用于IP链路。事实上我们可以得知，只有在以下情况下拥塞控制才会起作用：
a.两个或两个以上的连接(其中一个一定要是TCP，另一个可以是任意连接)经过同一个路由器或者同一个链路时；
b.只有一个TCP连接，然而它经过了一个路由器时。
其它情况下是不会拥塞的。因为一个TCP总是希望独享整条网络通路，而这对于多个连接而言是不可能的，必须保证TCP的公平性，这样这种拥塞控制机制才合理。本质上，拥塞的原因就是大家都想独享全部带宽资源，结果导致拥塞，这也是合理的，毕竟TCP看不到网络的状态，同时这也决定了TCP的拥塞控制必须采用试探性的方式，最终到达一个足以引起其“反应”的“刺激点”。
拥塞控制需要完成以下两个任务：1.公平性；2.拥塞之后退出拥塞状态。
疑难杂症16：影响拥塞的因素
我们必须认识到拥塞控制是一个整体的机制，它不偏向于任何TCP连接，因此这个机制内在的就包含了公平性。那么影响拥塞的因素都有什么呢？具有讽刺意味的是，起初TCP并没有拥塞控制机制，正是TCP的超时重传风暴(一个分段丢失造成后续的已经发送的分段均被重传，而这些重传大多数是不必要的)加重了网络的拥塞。因此重传必然不能过频，必须把重传定时器的超时时间设置的稍微长一些，而这一点在单一重传定时器的设计中得到了加强。除此TCP自身的因素之外，其它所有的拥塞都可以靠拥塞控制机制来自动完成。
另外，不要把路由器想成一种线速转发设备，再好的路由器只要接入网络，总是会拉低网络的总带宽，因此即使只有一个TCP连接，由于TCP的发送方总是以发送链路的带宽发送分段，这些分段在经过路由器的时候排队和处理总是会有时延，因此最终肯定会丢包的。
最后，丢包的延后性也会加重拥塞。假设一个TCP连接经过了N个路由器，前N-1个路由器都能顺利转发TCP分段，但是最后一个路由器丢失了一个分段，这就导致了这些丢失的分段浪费了前面路由器的大量带宽。
5.2.拥塞控制的策略</p>

<p>在介绍拥塞控制之前，首先介绍一下拥塞窗口，它实际上表示的也是“可以发送多少数据”，然而这个和接收端通告的接收窗口意义是不一样的，后者是流量控制用的窗口，而前者是拥塞控制用的窗口，体现了网络拥塞程度。
拥塞控制整体上分为两类，一类是试探性的拥塞探测，另一类则是拥塞避免(注意，不是常规意义上的拥塞避免)。
5.2.1.试探性的拥塞探测分为两类，之一是慢启动，之二是拥塞窗口加性扩大(也就是熟知的拥塞避免，然而这种方式是避免不了拥塞的)。</p>

<p>5.2.2.拥塞避免方式拥塞控制旨在还没有发生拥塞的时候就先提醒发送端，网络拥塞了，这样发送端就要么可以进入快速重传/快速恢复或者显式的减小拥塞窗口，这样就避免网络拥塞的一沓糊涂之后出现超时，从而进入慢启动阶段。</p>

<p>5.2.3.快速重传和快速恢复。所谓快速重传/快速恢复是针对慢启动的，我们知道慢启动要从1个MSS开始增加拥塞窗口，而快速重传/快速恢复则是一旦收到3个冗余ACK，不必进入慢启动，而是将拥塞窗口缩小为当前阀值的一半加上3，然后如果继续收到冗余ACK，则将拥塞窗口加1个MSS，直到收到一个新的数据ACK，将窗口设置成正常的阀值，开始加性增加的阶段。</p>

<p>当进入快速重传时，为何要将拥塞窗口缩小为当前阀值的一半加上3呢？加上3是基于数据包守恒来说的，既然已经收到了3个冗余ACK，说明有三个数据分段已经到达了接收端，既然三个分段已经离开了网络，那么就是说可以在发送3个分段了，只要再收到一个冗余ACK，这也说明1个分段已经离开了网络，因此就将拥塞窗口加1个MSS。直到收到新的ACK，说明直到收到第三个冗余ACK时期发送的TCP分段都已经到达对端了，此时进入正常阶段开始加性增加拥塞窗口。
疑难杂症17：超时重传和收到3个冗余ACK后重传
这两种重传的意义是不同的，超时重传一般是因为网络出现了严重拥塞(没有一个分段到达，如果有的话，肯定会有ACK的，若是正常ACK，则重置重传定时器，若是冗余ACK，则可能是个别报文丢失或者被重排序，若连续3个冗余ACK，则很有可能是个别分段丢失)，此时需要更加严厉的缩小拥塞窗口，因此此时进入慢启动阶段。而收到3个冗余ACK后说明确实有中间的分段丢失，然而后面的分段确实到达了接收端，这因为这样才会发送冗余ACK，这一般是路由器故障或者轻度拥塞或者其它不太严重的原因引起的，因此此时拥塞窗口缩小的幅度就不能太大，此时进入快速重传/快速恢复阶段。
疑难杂症18：为何收到3个冗余ACK后才重传
这是一种权衡的结构，收到两个或者一个冗余ACK也可以重传，但是这样的话可能或造成不必要的重传，因为两个数据分段发生乱序的可能性不大，超过三个分段发生乱序的可能性才大，换句话说，如果仅仅收到一个乱序的分段，那很可能被中间路由器重排了，那么另一个分段很可能马上就到，然而如果连续收到了3个分段都没能弥补那个缺漏，那很可能是它丢失了，需要重传。因此3个冗余ACK是一种权衡，在减少不必要重传和确实能检测出单个分段丢失之间所作的权衡。
注意，冗余ACK是不能捎带的。
疑难杂症19：乘性减和加性增的深层含义
为什么是乘性减而加性增呢？拥塞窗口的增加受惠的只是自己，而拥塞窗口减少受益的大家，可是自己却受到了伤害。哪一点更重要呢？我们知道TCP的拥塞控制中内置了公平性，恰恰就是这种乘性减实现了公平性。拥塞窗口的1个MSS的改变影响一个TCP发送者，为了使得自己拥塞窗口的减少影响更多的TCP发送者-让更多的发送者受益，那么采取了乘性减的策略。
当然，BIC算法提高了加性增的效率，不再一个一个MSS的加，而是一次加比较多的MSS，采取二分查找的方式逐步找到不丢包的点，然后加性增。
疑难杂症20：TCP连接的传输稳定状态是什么
首先，先说一下发送端的发送窗口怎么确定，它取的是拥塞窗口和接收端通告窗口的最小值。然后，我们提出三种发送窗口的稳定状态：
a.IP互联网络上接收端拥有大窗口的经典锯齿状
b.IP互联网络上接收端拥有小窗口的直线状态
c.直连网络端点间的满载状态下的直线状态
其中a是大多数的状态，因为一般而言，TCP连接都是建立在互联网上的，而且是大量的，比如Web浏览，电子邮件，网络游戏，Ftp下载等等。TCP发送端用慢启动或者拥塞避免方式不断增加其拥塞窗口，直到丢包的发生，然后进入慢启动或者拥塞避免阶段(要看是由于超时丢包还是由于冗余ACK丢包)，此时发送窗口将下降到1或者下降一半，这种情况下，一般接收端的接收窗口是比较大的，毕竟IP网络并不是什么很快速的网络，一般的机器处理速度都很快。
但是如果接收端特别破，处理速度很慢，就会导致其通告一个很小的窗口，这样的话，即使拥塞窗口再大，发送端也还是以通告的接收窗口为发送窗口，这样就不会发生拥塞。最后，如果唯一的TCP连接运行在一个直连的两台主机上，那么它将独享网络带宽，这样该TCP的数据流在最好的情况下将填满网络管道(我们把网络管道定义为带宽和延时的乘积)，其实在这种情况下是不存在拥塞的，就像你一个人独自徘徊在飘雨黄昏的街头一样…
5.2.4.主动的拥塞避免</p>

<p>前面我们描述的拥塞控制方式都是试探性的检测，然后拥塞窗口被动的进行乘性减，这样在接收端窗口很大的情况下(一般都是这样，网络拥堵，分段就不会轻易到达接收端，导致接收端的窗口大量空置)就可能出现锯齿形状的“时间-窗口”图，类似在一个拥堵的北京X环上开车，发送机发动，车开动，停止，等待，发动机发动，车开动…听声音也能听出来。
虽然TCP看不到下面的IP网络，然而它还是可以通过检测RTT的变化以及拥塞窗口的变化推算出IP网络的拥堵情况的。就比方说北京东四环一家快递公司要持续送快递到西四环，当发件人发现货到时间越来越慢的时候，他会意识到“下班高峰期快到了”…
可以通过持续观测RTT的方式来主动调整拥塞窗口的大小而不是一味的加性增。然而还有更猛的算法，那就是计算两个差值的乘积：
(当前拥塞窗口-上一次拥塞窗口)x(当前的RTT-上一次的RTT)
如果结果是正数，则拥塞窗口减少1/8，若结果是负数或者0，则窗口增加一个MSS。注意，这回不再是乘性减了，可以看出，减的幅度比乘性减幅度小，这是因为这种拥塞控制是主动的，而不是之前的那种被动的试探方式。在试探方式中，乘性减以一种惩罚的方式实现了公平性，而在这里的主动方式中，当意识到要拥塞的时候，TCP发送者主动的减少了拥塞窗口，为了对这种自首行为进行鼓励，采用了小幅减少拥塞窗口的方式。需要注意的是，在拥塞窗口减小的过程中，乘积的前一个差值是负数，如果后一个差值也是负数，那么结果就是继续缩减窗口，直到拥塞缓解或者窗口减少到了一定程度，使得后一个差值成了正数或者0，这种情况下，其实后一个差值只能变为0。
疑难杂症21：路由器和TCP的互动
虽然有了5.2.4节介绍的主动的拥塞检测，那么路由器能不能做点什么帮助检测拥塞呢？这种对路由器的扩展是必要的，要知道，每天有无数的TCP要通过路由器，虽然路由器不管TCP协议的任何事(当然排除连接跟踪之类的，这里所说的是标准的IP路由器)，但是它却能以一种很简单的方式告诉TCP的两端IP网络发生了拥堵，这种方式就是当路由器检测到自己发生轻微拥堵的时候随机的丢包，随机丢包而不是连续丢包对于TCP而言是有重大意义的，随机丢包会使TCP发现丢弃了个别的分段而后续的分段仍然会到达接收端，这样TCP发送端就会接收到3个冗余ACK，然后进入快速重传/快速恢复而不是慢启动。
这就是路由器能帮TCP做的事。
6.其它</p>

<p>疑难杂症22：如何学习TCP
很多人发帖问TCP相关的内容，接下来稀里哗啦的就是让看《TCP/IP详解》和《Unix网络编程》里面的特定章节，我觉得这种回答很不负责任。因为我并不认为这两本书有多大的帮助，写得确实很不错，然而可以看出Richard Stevens是一个实用主义者，他喜欢用实例来解释一切，《详解》通篇都是用tcpdump的输出来讲述的，这种方式只是适合于已经对TCP很理解的人，然而大多数的人是看不明白的。
如果想从设计的角度来说，这两本书都很烂。我觉得应该先看点入门的，比如Wiki之类的，然后看RFC文档,793，896，1122等)，这样你就明白TCP为何这么设计了，而这些你永远都不能在Richard Stevens的书中得到。最后，如果你想，那么就看一点Richard Stevens的书，最重要的还是写点代码或者敲点命令，然后抓包自己去分析。
疑难杂症23：Linux，Windows和网络编程
我觉得在Linux上写点TCP的代码是很不错的，如果有BSD那就更好了。不推荐用Winsock学习TCP。虽然微软声称自己的API都是为了让事情更简单，但实际上事情却更复杂了，如果你用Winsock学习，你就要花大量的时候去掌握一些和网络编程无关但是windows平台上却少不了的东西
6.1.总结</p>

<p>TCP协议是一个端到端的协议，虽然话说它是一个带流量控制，拥塞控制的协议，然而正是因为这些所谓的控制才导致了TCP变得复杂。同时这些特性是互相杂糅的，流量控制带来了很多问题，解决这些问题的方案最终又带来了新的问题，这些问题在解决的时候都只考虑了端到端的意义，但实际上TCP需要尽力而为的IP提供的网络，因此拥塞成了最终的结症，拥塞控制算法的改进也成了一个单独的领域。
在学习TCP的过程中，切忌一锅粥一盘棋的方式，一定要分清楚每一个算法到底是解决什么问题的，每一个问题和其他问题到底有什么关联，这些问题的解决方案之间有什么关联，另外TCP的发展历史也最好了解一下，这些都搞明白了，TCP协议就彻底被你掌控了。接下来你就可以学习Socket API了，然后高效的TCP程序出自你手！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[svn]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/svn/"/>
    <updated>2013-05-19T11:00:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/svn</id>
    <content type="html"><![CDATA[<p>用开源OJ后<del>由于开源~内核也开源</del>给了我们很大的改造空间<del>~由此搭建起subversion版本控制</del>subversion的安装略（可yum 或apt-get 安装或者源码安装）~安装成功后使用命令 svn –version 即可显示安装版本信息</p>

<p>本人使用是svnserve 建立版本库~基于apaches的有空再弄~</p>

<ol>
<li>建立版本目录:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>svnadmin create –fs-type fsfs /usr/local/OJ</span></code></pre></td></tr></table></div></figure>


<p>执行后在/usr/local/OJ/目录下生成一堆配置文件~主要文件还是conf/下的svnserve.conf文件，里面有关配置用户和匿名用户对版本库的使用权限设置 anon-access 和autho-access ,write对应的用户读写都可~read只可读</p>

<p>2.刚建立的版本库没有项目需引入项目(在本地引入用file://)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>svn import hustoj2mdk file:///usr/local/OJ/project-oj -m “Initial import”</span></code></pre></td></tr></table></div></figure>


<p>即可将hustoj2mdk目录的内容引入到版本库的project-oj目录</p>

<p>3.开启svnserve</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>svnserve -d -r /usr/local/OJ
</span><span class='line'>
</span><span class='line'>-d 以独立进程的方式开启 -r 便于svn 访问省略/usr/local/OJ  只用project-oj即可</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ps aux|grep svn 即可查看到svnserve</span></code></pre></td></tr></table></div></figure>


<p>到此一个的版本库的项目引入以完成~即可用 svn list/checkout等命令 svn://URL 取出版本库的相关项目(后期补上基于apche的svn)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用的命令2]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/chang-yong-de-ming-ling-2/"/>
    <updated>2013-05-19T10:58:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/chang-yong-de-ming-ling-2</id>
    <content type="html"><![CDATA[<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># uname -a               # 查看内核/操作系统/CPU信息   # head -n 1 /etc/issue   # 查看操作系统版本
</span><span class='line'>
</span><span class='line'># cat /proc/cpuinfo      # 查看CPU信息
</span><span class='line'>
</span><span class='line'># hostname               # 查看计算机名
</span><span class='line'>
</span><span class='line'># lspci -tv              # 列出所有PCI设备
</span><span class='line'>
</span><span class='line'># lsusb -tv              # 列出所有USB设备
</span><span class='line'>
</span><span class='line'># lsmod                  # 列出加载的内核模块
</span><span class='line'>
</span><span class='line'># env                    # 查看环境变量</span></code></pre></td></tr></table></div></figure>


<p>资源</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># free -m                # 查看内存使用量和交换区使用量   # df -h                  # 查看各分区使用情况
</span><span class='line'>
</span><span class='line'># du -sh &lt;目录名&gt;        # 查看指定目录的大小
</span><span class='line'>
</span><span class='line'># grep MemTotal /proc/meminfo   # 查看内存总量
</span><span class='line'>
</span><span class='line'># grep MemFree /proc/meminfo    # 查看空闲内存量
</span><span class='line'>
</span><span class='line'># uptime                 # 查看系统运行时间、用户数、负载
</span><span class='line'>
</span><span class='line'># cat /proc/loadavg      # 查看系统负载</span></code></pre></td></tr></table></div></figure>


<p>磁盘和分区
 &#8220;`</p>

<h1>mount | column -t      # 查看挂接的分区状态   # fdisk -l               # 查看所有分区</h1>

<h1>swapon -s              # 查看所有交换分区</h1>

<h1>hdparm -i /dev/hda     # 查看磁盘参数(仅适用于IDE设备)</h1>

<h1>dmesg | grep IDE       # 查看启动时IDE设备检测状况</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 网络
</span><span class='line'> ```  
</span><span class='line'># ifconfig               # 查看所有网络接口的属性   # iptables -L            # 查看防火墙设置
</span><span class='line'>
</span><span class='line'># route -n               # 查看路由表</span></code></pre></td></tr></table></div></figure>


<h1>netstat -lntp          # 查看所有监听端口</h1>

<h1>netstat -antp          # 查看所有已经建立的连接</h1>

<h1>netstat -s             # 查看网络统计信息</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>进程</span></code></pre></td></tr></table></div></figure>


<p></p>

<h1>ps -ef                 # 查看所有进程   # top                    # 实时显示进程状态</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>用户</span></code></pre></td></tr></table></div></figure>


<p></p>

<h1>w                      # 查看活动用户   # id &lt;用户名&gt;            # 查看指定用户信息</h1>

<h1>last                   # 查看用户登录日志</h1>

<h1>cut -d: -f1 /etc/passwd   # 查看系统所有用户</h1>

<h1>cut -d: -f1 /etc/group    # 查看系统所有组</h1>

<h1>crontab -l             # 查看当前用户的计划任务</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>服务
</span><span class='line'> ```
</span><span class='line'># chkconfig –list       # 列出所有系统服务   # chkconfig –list | grep on    # 列出所有启动的系统服务</span></code></pre></td></tr></table></div></figure>


<p>程序
 &#8220;`</p>

<h1>rpm -qa                # 查看所有安装的软件包</h1>

<p> &#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用的命令]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/chang-yong-de-ming-ling/"/>
    <updated>2013-05-19T10:57:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/chang-yong-de-ming-ling</id>
    <content type="html"><![CDATA[<p>平时用linux时，我有一个习惯就是把遇到的，比较有用，并且容易忘的命令，放到一个文本文件中，没事的时候可以拿出来看看，这样可以加深印象，时间长了这些命令的用法基本上都能掌握了。以下是100个用法,有什么不对，还请大家指正。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1，echo “aa” &gt; test.txt 和 echo “bb” &gt;&gt; test.txt //&gt;将原文件清空，并且内容写入到文件中，&gt;&gt;将内容放到文件的尾部
</span><span class='line'>2，chmod go+w -R  /home/zhangy  //给组用户和其他用户添加写的权限
</span><span class='line'>3，tar -tzvf test.tar.gz        //列出归档内容
</span><span class='line'>4，du -ah  //查看文件列表大小
</span><span class='line'>5，du -sh  //查看所有文件的大小总和
</span><span class='line'>6，echo ’1+2′|bc -l //数学运算
</span><span class='line'>7，uname -a    //查看linux内核等的一些信息
</span><span class='line'>8，badblocks -s /dev/sda     //坏道扫描时显示进度
</span><span class='line'>9，time command     //查看命令的运行时间
</span><span class='line'>10,ls -lrt //按时间的倒序排序
</span><span class='line'>11,rsync -P  //同步时显示进度
</span><span class='line'>12.history -c //清楚历史命令
</span><span class='line'>13，cd – //返回上次目录
</span><span class='line'>14，tree     //显示目录树
</span><span class='line'>15，umount -n /mnt/hda2  //强制卸载
</span><span class='line'>16，echo ~/     //显示用户的home目录
</span><span class='line'>17，echo $[5*5]  //算术运算
</span><span class='line'>18，echo $((5*5)) //算术运算
</span><span class='line'>19，eval ls;ps aux|grep httpd //这二个命令都能执行
</span><span class='line'>20，free -m //有MB为单位显示内存
</span><span class='line'>21，uptime //显示系统已经运行了多长时间，它依次显示下列信息：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载
</span><span class='line'>22，加法运算
</span><span class='line'>[root@krlcgcms01 mytest]# let a=34+3;
</span><span class='line'>[root@krlcgcms01 mytest]# echo $a;
</span><span class='line'>23，export  //查看所有环境变量
</span><span class='line'>24，echo $PATH //查看单个变量
</span><span class='line'>25，cmp file1 file2   //文件内容比对
</span><span class='line'>26，clear   //清屏
</span><span class='line'>27，echo 23423 |awk –re-interval  ’/[0-9]{3,}/’  //如果不加re-interval的话，不显示
</span><span class='line'>28，cal  //得到一个整齐的日历格式
</span><span class='line'>29，wc -l //统计行数，wc -w 统计单词
</span><span class='line'>30，echo  ”AaDCbd23″ |tr “[A-Z]” “[a-z]” 大写变小写，echo  ”AaDCbdc23″ |tr -c b-d = 将b-d之外的字符串替换成=
</span><span class='line'>31，echo “ADSF” | iconv -f UTF8 -t GBK //把字符由utf8转成gbk -f是from和简写，-t好像terminal的简写
</span><span class='line'>32，cat -n file //内容的前面会显示行号
</span><span class='line'>33，chattr +i file  //只读，root用户也没法对其进行修改
</span><span class='line'>34，lsattr file //查看文件属性
</span><span class='line'>35，cat /etc/passwd |awk -F: ‘{print $1}’  //查看系统中所有用户
</span><span class='line'>36，cat /etc/group //查看系统中所有的组
</span><span class='line'>37，groups //查前当前用户所在的，所有组
</span><span class='line'>38，usermod -g 组名 用户   //这种方式是覆盖的方式，用的时候要小心，如果用户A性于mysql usermod -g php mysql这样的话只
</span><span class='line'>属于php了，
</span><span class='line'>39，usermod -G 组名 用户 //这种方式是增加的方式，如果用户A性于mysql usermod -g php mysql这样的话，mysql就属于2个组了
</span><span class='line'>40，bc  //进入数学计算中去
</span><span class='line'>41，umask 003 u权限是7,g权限是7，其他用户是4，也就是774，777-003=774
</span><span class='line'>42，mkfs -t vfat /dev/hda6 //将移动硬盘里面的一个分区格式化成vfat格式
</span><span class='line'>43，mount /dev/cdrom /media/cdrom  //挂载cdrom
</span><span class='line'>44，getent group 532 //通过组ID,来查找组信息
</span><span class='line'>45，last //登录成功用户记录
</span><span class='line'>46,lastb //登录不成功用户记录
</span><span class='line'>47，dump -S /dev/sda2 //查看一下要备份/dev/sda2所要的容量
</span><span class='line'>48，dump -0j -f /dev/hda2/sda2_bak.dump.bz2 /dev/sda2  //将sda2进行备份并压缩
</span><span class='line'>49，restore -t -f /dev/hda2/sda2_bak.dump  //查看备份信息
</span><span class='line'>50，restore -r -f /dev/hda2/sda2_bak.dump  //还原备份
</span><span class='line'>51，fc-list //查看系统中安装的字体
</span><span class='line'>52，find ./ -type f   -exec grep -q  ”root” {} \;  -exec echo {} \;  //查找目录下文件所包涵的字符串
</span><span class='line'>53，vmstat 5 //每5显示一下次系统信息，cpu,memory,i/o等
</span><span class='line'>54，top 后 在shift + P 所占进程的排序显示
</span><span class='line'>55，top 后 在shift + M 所占内存的排序显示
</span><span class='line'>56，iptraf -g  //查看各个接口的流量
</span><span class='line'>57，ostat -d -x /dev/sda2 2  //用iostat查看磁盘/dev/sda2的磁盘i/o情况，每两秒刷新一次
</span><span class='line'>58, paste -sd ‘|||\n’ test //文件的每4行转换成1行，并用|隔开。
</span><span class='line'>59，lsof -i :22 //知道22端口现在运行什么程序
</span><span class='line'>60，lsof -c abc //显示abc进程现在打开的文件
</span><span class='line'>61，lsof -p 12  //看进程号为12的进程打开了哪些文件
</span><span class='line'>63，route //查看路由信息
</span><span class='line'>64，ifup //开启网卡
</span><span class='line'>65，ifdown //关闭网卡
</span><span class='line'>66，route del -net 172.168.0.0 netmask 255.255.0.0 dev eth0 //删除 172.168这个网段
</span><span class='line'>67，route add -net 172.168.10.0 netmask 255.255.255.0 dev eth0 //增加一个路由
</span><span class='line'>68，netstat -tunl //列出监听的网络服务端口
</span><span class='line'>69，netstat -tun //列出已连接的网络服务端口
</span><span class='line'>70，nmap -sP 172.30.4.0/24  //在这个网段内有多少用户在我的主机上操作，一个不错的安全检查工具
</span><span class='line'>71，vgdisplay   //查看系统中的可用空间
</span><span class='line'>72，lvextend -L+20G /dev/tank/part1 //向part1这个分区增加20G的空间
</span><span class='line'>73，lvresize -L-10G /dev/tank/part2 //向part2这个分区减少10G的空间
</span><span class='line'>74，pvdisplay //查看磁盘信息
</span><span class='line'>75,mplayer -loop 10 /mnt/song/music/花儿开了.mp3  //循环播放10遍
</span><span class='line'>76,pacman -S firefox -nd  //nd去掉依赖
</span><span class='line'>77,wget -c //断点下载
</span><span class='line'>78,chroot  /mnt/ubuntu     //改变根目录到/mnt/ubuntu
</span><span class='line'>79,ctrl+a  //命令行下，光标称动到开头
</span><span class='line'>80,ctrl+e  //命令行下，光标移动结尾
</span><span class='line'>81,cut -d: -f 1-4 test  //用：分割文件，取分割后的1－4列
</span><span class='line'>82,file  /home/zhangy/test.php  //用于查看文件的一些基本信息
</span><span class='line'>83,touch test.txt //创建一个空文件 text.txt
</span><span class='line'>84,htpasswd -cbd /usr/local/nginx/conf/authfile  //创建访问控制文件
</span><span class='line'>85,df  //查看磁盘空间，和当前的磁盘数
</span><span class='line'>86,fdisk -l  //查看所有磁盘数
</span><span class='line'>87,alsamixer  //进入后，m键可以实现静音
</span><span class='line'>88,killall httpd  //把所有httpd进程杀掉
</span><span class='line'>89,killall -9 mysqld_safe  //有些进程超级用户也停止不了，-9是强制删除
</span><span class='line'>90,mirror /mysql //下载mysql目录
</span><span class='line'>91,mirror -R /mysql     //上传mysql目录
</span><span class='line'>92,rmmod pcspkr  //关掉tab提示音
</span><span class='line'>93,modprobe pcspkr  //开启tab提示音
</span><span class='line'>94,gpasswd -a zhangy wheel //将zhangy这个用户添加到wheel这个组
</span><span class='line'>95,dd if=/dev/zero of=/virtual/ubuntu.virt.img bs=1M count=4096  //创建一个4G的IMG镜像
</span><span class='line'>96，lspic //显示pci设备
</span><span class='line'>97，lsusb //显示usb设备
</span><span class='line'>98，history | less //less根more有点像，感觉less用着更舒服点
</span><span class='line'>99，ln -s //如果忘了-s就变成硬链接了
</span><span class='line'>100，tar zxvf test.tar.gz -C /home/zhangy //将内容解压到指定目录</span></code></pre></td></tr></table></div></figure>


<p>作者:海底苍鹰
文章来源:<a href="http://blog.51yip.com/linux/1213.html">http://blog.51yip.com/linux/1213.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tcpdump]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/tcpdump/"/>
    <updated>2013-05-19T10:55:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/tcpdump</id>
    <content type="html"><![CDATA[<p>如下一些实例:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcpdump -i eth0</span></code></pre></td></tr></table></div></figure>


<p>其中，eth0为参数值，表示需要抓包的网口，这是个必需参数哦。</p>

<p>tcpdump支持很多的关键字，下面先看几个例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（例1）tcpdump -i eth0 host 192.168.0.250 —–在网口eth0上抓取主机地址为192.168.0.250的所有数据包。
</span><span class='line'>
</span><span class='line'>（例2）tcpdump -i eth0 net 192.168.0.0/24 —— 在网口eth0上抓取网络地址为192.168.0.0/24的所有数据包
</span><span class='line'>
</span><span class='line'>（例3）tcpdump -i eth0 port 80 —— 在网口eth0上抓取端口为80的所有数据包(注意，这里不区分是源端口还是目的端口)</span></code></pre></td></tr></table></div></figure>


<p>当然，我们也可以指定源端口或目的端口</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>（例4）tcpdump -i eth0 src port 80 and dst port6100 — 在网口eth0上抓取源端口为80且目的端口为6100的数据包，这里用到了and逻辑运算符，后面再介绍
</span><span class='line'>
</span><span class='line'>（例5）tcpdump -i eth0 icmp — 在网口eth0上抓取所有icmp协议的数据包</span></code></pre></td></tr></table></div></figure>


<p>以上几个例子，可以大致体现出tcpdump的基本用法。</p>

<p>实际上，tcpdump主要包括三种类型的关键字，第一种是关于类型的关键字，主要包括host，net，port，如上面的例（1）（2）（3），第二种</p>

<p>是确定传输方向的关键字，主要包括src，dst，src or dst，src and dst，这些关键字指明了传输的方向，如上面的例（4）。第三种是协议关键字，包括fddi，ip，arp，</p>

<p>rarp，tcp，udp，imcp等，如上面的例（5）。</p>

<p>除了这三种类型的关键字外，还有其他重要的关键字，如：gateway，broadcast，less，greater，还有三种逻辑运算，取非运算是’not’、’!&lsquo;，与运算符是’and’、’&amp;&amp;’、</p>

<p>或运算符是’or’、’||’，这些关键字可以组合起来构成强大的组合条件来满足我们的需求。</p>

<p>先看看tcpdump的具体参数及意义：</p>

<p>-i：指定tcpdump监听的网络接口</p>

<p>-s：指定要监听数据包的长度</p>

<p>-c：指定要监听的数据包数量，达到指定数量后自动停止抓包</p>

<p>-w：指定将监听到的数据包写入文件中保存</p>

<p>-A：指定将每个监听到的数据包以ACSII可见字符打印</p>

<p>-n：指定将每个监听到数据包中的域名转换成IP地址后显示</p>

<p>-nn：指定将每个监听到的数据包中的域名转换成IP、端口从应用名称转换成端口号后显示</p>

<p>-e：指定将监听到的数据包链路层的信息打印出来，包括源mac和目的mac，以及网络层的协议</p>

<p>-p：将网卡设置为非混杂模式，不能与host或broadcast一起使用</p>

<p>-r：指定从某个文件中读取数据包</p>

<p>-S：指定打印每个监听到的数据包的TCP绝对序列号而非相对序列号</p>

<p>OK，参数介绍先到这里，下面看几个具体例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcpdump -i eth0 -s 1400 -nn host 192.168.0.250 and ! 192.168.0.74 and icmp -e</span></code></pre></td></tr></table></div></figure>


<p>抓取网口eth0上192.168.0.250与除192.168.0.74外的其他主机之间的icmp报文</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcpdump -i eth0 -s 1400 -nn tcp and \(host 192.168.0.250 and ! 192.168.0.74\)</span></code></pre></td></tr></table></div></figure>


<p>抓取网口eth0上192.168.0.250与除192.168.0.74外的所有tcp数据包，这里用到了括号，注意，在tcpdump中使用括号时必须用转义。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tcpdump -i eth0 ether src or dst 00:21:85:6C:D9:A3</span></code></pre></td></tr></table></div></figure>


<p>抓取网口eth0上源mac地址或目的mac地址为00:21:85:6C:D9:A3的所有数据包，注意，这里的mac地址格式必须以’:&lsquo;分隔。</p>

<p>=============================================================================================================</p>

<p>下面是参考的一篇文章的原文<a href="http://linux.chinaitlab.com/administer/840012.html%EF%BC%9A">http://linux.chinaitlab.com/administer/840012.html%EF%BC%9A</a></p>

<p>　　TCPDUMP简介</p>

<p>　　在传统的网络分析和测试技术中，嗅探器(sniffer)是最常见，也是最重要的技术之一。sniffer工具首先是为网络管理员和网络程序员进行网络分析而设计的。对于网络管理人员来说，使用嗅探器可以随时掌握网络的实际情况，在网络性能急剧下降的时候，可以通过sniffer工具来分析原因，找出造成网络阻塞的来源。对于网络程序员来说,通过sniffer工具来调试程序。</p>

<p>　　用过windows平台上的sniffer工具(例如，netxray和sniffer pro软件)的朋友可能都知道，在共享式的局域网中，采用sniffer工具简直可以对网络中的所有流量一览无余！Sniffer工具实际上就是一个网络上的抓包工具，同时还可以对抓到的包进行分析。由于在共享式的网络中，信息包是会广播到网络中所有主机的网络接口，只不过在没有使用sniffer工具之前，主机的网络设备会判断该信息包是否应该接收，这样它就会抛弃不应该接收的信息包，sniffer工具却使主机的网络设备接收所有到达的信息包，这样就达到了网络监听的效果。</p>

<p>　　Linux作为网络服务器，特别是作为路由器和网关时，数据的采集和分析是必不可少的。所以，今天我们就来看看Linux中强大的网络数据采集分析工具——TcpDump。</p>

<p>　　用简单的话来定义tcpdump，就是：dump the traffice on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。</p>

<p>　　作为互联网上经典的的系统管理员必备工具，tcpdump以其强大的功能，灵活的截取策略，成为每个高级的系统管理员分析网络，排查问题等所必备的东东之一。</p>

<p>　　顾名思义，TcpDump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>

<p>　　tcpdump提供了源代码，公开了接口，因此具备很强的可扩展性，对于网络维护和入侵者都是非常有用的工具。tcpdump存在于基本的FreeBSD系统中，由于它需要将网络界面设置为混杂模式，普通用户不能正常执行，但具备root权限的用户可以直接执行它来获取网络上的信息。因此系统中存在网络分析工具主要不是对本机安全的威胁，而是对网络上的其他计算机的安全存在威胁。</p>

<p>　　普通情况下，直接启动tcpdump将监视第一个网络界面上所有流过的数据包。</p>

<p>　　－－－－－－－－－－－－－－－－－－－－－－－</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　bash-2.02# tcpdump
</span><span class='line'>
</span><span class='line'>　　tcpdump: listening on eth0
</span><span class='line'>
</span><span class='line'>　　11:58:47.873028 202.102.245.40.netbios-ns &gt; 202.102.245.127.netbios-ns: udp 50
</span><span class='line'>
</span><span class='line'>　　11:58:47.974331 0:10:7b:8:3a:56 &gt; 1:80:c2:0:0:0 802.1d ui/C len=43
</span><span class='line'>
</span><span class='line'>　　0000 0000 0080 0000 1007 cf08 0900 0000
</span><span class='line'>
</span><span class='line'>　　0e80 0000 902b 4695 0980 8701 0014 0002
</span><span class='line'>
</span><span class='line'>　　000f 0000 902b 4695 0008 00
</span><span class='line'>
</span><span class='line'>　　11:58:48.373134 0:0:e8:5b:6d:85 &gt; Broadcast sap e0 ui/C len=97
</span><span class='line'>
</span><span class='line'>　　ffff 0060 0004 ffff ffff ffff ffff ffff
</span><span class='line'>
</span><span class='line'>　　0452 ffff ffff 0000 e85b 6d85 4008 0002
</span><span class='line'>
</span><span class='line'>　　0640 4d41 5354 4552 5f57 4542 0000 0000
</span><span class='line'>
</span><span class='line'>　　0000 00
</span><span class='line'>
</span><span class='line'>　　^C</span></code></pre></td></tr></table></div></figure>


<p>　　－－－－－－－－－－－－－－－－－－－－－－－－</p>

<p>　　首先我们注意一下，从上面的输出结果上可以看出来，基本上tcpdump总的的输出格式为：系统时间 来源主机.端口 > 目标主机.端口 数据包参数</p>

<p>　　TcpDump的参数化支持</p>

<p>　　tcpdump支持相当多的不同参数，如使用-i参数指定tcpdump监听的网络界面，这在计算机具有多个网络界面时非常有用，使用-c参数指定要监听的数据包数量，使用-w参数指定将监听到的数据包写入文件中保存，等等。</p>

<p>　　然而更复杂的tcpdump参数是用于过滤目的，这是因为网络中流量很大，如果不加分辨将所有的数据包都截留下来，数据量太大，反而不容易发现需要的数据包。使用这些参数定义的过滤规则可以截留特定的数据包，以缩小目标，才能更好的分析网络中存在的问题。tcpdump使用参数指定要监视数据包的类型、地址、端口等，根据具体的网络问题，充分利用这些过滤规则就能达到迅速定位故障的目的。请使用man tcpdump查看这些过滤规则的具体用法。</p>

<p>　　显然为了安全起见，不用作网络管理用途的计算机上不应该运行这一类的网络分析软件，为了屏蔽它们，可以屏蔽内核中的bpfilter伪设备。一般情况下网络硬件和TCP/IP堆栈不支持接收或发送与本计算机无关的数据包，为了接收这些数据包，就必须使用网卡的混杂模式，并绕过标准的TCP/IP堆栈才行。在FreeBSD下，这就需要内核支持伪设备bpfilter。因此，在内核中取消bpfilter支持，就能屏蔽tcpdump之类的网络分析工具。</p>

<p>　　并且当网卡被设置为混杂模式时，系统会在控制台和日志文件中留下记录，提醒管理员留意这台系统是否被用作攻击同网络的其他计算机的跳板。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　May 15 16:27:20 host1 /kernel: fxp0: promiscuous mode enabled</span></code></pre></td></tr></table></div></figure>


<p>　　虽然网络分析工具能将网络中传送的数据记录下来，但是网络中的数据流量相当大，如何对这些数据进行分析、分类统计、发现并报告错误却是更关键的问题。网络中的数据包属于不同的协议，而不同协议数据包的格式也不同。因此对捕获的数据进行解码，将包中的信息尽可能的展示出来，对于协议分析工具来讲更为重要。昂贵的商业分析工具的优势就在于它们能支持很多种类的应用层协议，而不仅仅只支持tcp、udp等低层协议。</p>

<p>　　从上面tcpdump的输出可以看出，tcpdump对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用十六进制的形式直接打印输出的。显然这不利于分析网络故障，通常的解决办法是先使用带-w参数的tcpdump 截获数据并保存到文件中，然后再使用其他程序进行解码分析。当然也应该定义过滤规则，以避免捕获的数据包填满整个硬盘。</p>

<p>　　TCP功能</p>

<p>　　数据过滤</p>

<p>　　不带任何参数的TcpDump将搜索系统中所有的网络接口，并显示它截获的所有数据，这些数据对我们不一定全都需要，而且数据太多不利于分析。所以，我们应当先想好需要哪些数据，TcpDump提供以下参数供我们选择数据：</p>

<p>　　-b 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　例如：tcpdump -b arp 将只显示网络中的arp即地址转换协议信息。</span></code></pre></td></tr></table></div></figure>


<p>　　-i 选择过滤的网络接口，如果是作为路由器至少有两个网络接口，通过这个选项，就可以只过滤指定的接口上通过的数据。例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　tcpdump -i eth0 只显示通过eth0接口上的所有报头。</span></code></pre></td></tr></table></div></figure>


<p>　　src、dst、port、host、net、ether、gateway这几个选项又分别包含src、dst 、port、host、net、ehost等附加选项。他们用来分辨数据包的来源和去向，src host 192.168.0.1指定源主机IP地址是192.168.0.1，dst net 192.168.0.0/24指定目标是网络192.168.0.0。以此类推，host是与其指定主机相关无论它是源还是目的，net是与其指定网络相关的，ether后面跟的不是IP地址而是物理地址，而gateway则用于网关主机。可能有点复杂，看下面例子就知道了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　tcpdump src host 192.168.0.1 and dst net 192.168.0.0/24</span></code></pre></td></tr></table></div></figure>


<p>　　过滤的是源主机为192.168.0.1与目的网络为192.168.0.0的报头。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　tcpdump ether src 00:50:04:BA:9B and dst……</span></code></pre></td></tr></table></div></figure>


<p>　　过滤源主机物理地址为XXX的报头（为什么ether src后面没有host或者net？物理地址当然不可能有网络喽）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　Tcpdump src host 192.168.0.1 and dst port not telnet</span></code></pre></td></tr></table></div></figure>


<p>　　过滤源主机192.168.0.1和目的端口不是telnet的报头。</p>

<p>　　ip icmp arp rarp 和 tcp、udp、icmp这些选项等都要放到第一个参数的位置，用来过滤数据报的类型。</p>

<p>　　例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　tcpdump ip src……</span></code></pre></td></tr></table></div></figure>


<p>　　只过滤数据-链路层上的IP报头。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　tcpdump udp and src host 192.168.0.1</span></code></pre></td></tr></table></div></figure>


<p>　　只过滤源主机192.168.0.1的所有udp报头。</p>

<p>　　数据显示/输入输出</p>

<p>　　TcpDump提供了足够的参数来让我们选择如何处理得到的数据，如下所示：</p>

<p>　　-l 可以将数据重定向。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　如tcpdump -l ＞tcpcap.txt将得到的数据存入tcpcap.txt文件中。
</span><span class='line'>
</span><span class='line'>　　-n 不进行IP地址到主机名的转换。
</span><span class='line'>
</span><span class='line'>　　如果不使用这一项，当系统中存在某一主机的主机名时，TcpDump会把IP地址转换为主机名显示，就像这样：eth0 ＜ ntc9.1165＞ router.domain.net.telnet，使用-n后变成了：eth0 ＜ 192.168.0.9.1165 ＞ 192.168.0.1.telnet。
</span><span class='line'>
</span><span class='line'>　　-nn 不进行端口名称的转换。
</span><span class='line'>
</span><span class='line'>　　上面这条信息使用-nn后就变成了：eth0 ＜ ntc9.1165 ＞ router.domain.net.23。
</span><span class='line'>
</span><span class='line'>　　-N 不打印出默认的域名。
</span><span class='line'>
</span><span class='line'>　　还是这条信息-N 后就是：eth0 ＜ ntc9.1165 ＞ router.telnet。
</span><span class='line'>
</span><span class='line'>　　-O 不进行匹配代码的优化。
</span><span class='line'>
</span><span class='line'>　　-t 不打印UNIX时间戳，也就是不显示时间。
</span><span class='line'>
</span><span class='line'>　　-tt 打印原始的、未格式化过的时间。
</span><span class='line'>
</span><span class='line'>　　-v 详细的输出，也就比普通的多了个TTL和服务类型。</span></code></pre></td></tr></table></div></figure>


<p>　　［expression]的用法：</p>

<p>　　expression是tcpdump最为有用的高级用法，可以利用它来匹配一些特殊的包。下面介绍一下expression的用法，主要是如何写出符合要求最为严格expression。如果tcpdump中没有expression,那么tcpdump会把网卡上的所有数据包输出，否则会将被expression匹配的包输出。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　expression 由一个或多个[primitives]组成，而[primitives]由一个或多个[qualitifer]加一个id(name)或数字组成，它们的结构如用正则表达式则可表示为：
</span><span class='line'>
</span><span class='line'>　　expression = ([qualitifer］+(id|number))+</span></code></pre></td></tr></table></div></figure>


<p>　　依次看来，expression是一个复杂的条件表达式，其中[qualitifer］+(id|number)就是一个比较基本条件，qualitifer就表达一些的名称（项，变量），id或number则表示一个值（或常量）。</p>

<p>　　qualitifer共有三种，分别是：</p>

<p>　　type 表示id name或number涉及到的类型，这些词有host, nest, port ,portrange等等。</p>

<p>　　例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　host foo 此为一个简单的primitive，host为qualitifer, foo为id name
</span><span class='line'>
</span><span class='line'>　　net 128.3 net为qualitifer, 128.3为number
</span><span class='line'>
</span><span class='line'>　　port 20</span></code></pre></td></tr></table></div></figure>


<p>　　等等</p>

<p>　　每个privimtive必须有一个type词，如果表达式中没有，则默认是host.</p>

<p>　　dir 指定数据传输的方向，这些词有src, dst, src or dst, src and dst</p>

<p>　　例子：</p>

<p>　　dst net 128.3 ;此为一个相对复杂的primitive,结构为dir type number,表示目标网络为128.3的条件。</p>

<p>　　src or dst port ftp-data 此为比上一个相对简的结构，src or dst表示源或目标，ftp-data为id，表示ftp协议中数据传输端口，故整体表示源或目标端口ftp-data的数据包即匹配。</p>

<p>　　如果在一个primitive中没有dir词，此默认为src or dst. 如 host foo则表示源或目标主机为foo的数据包都匹配。</p>

<p>　　proto 此种词是用来匹配某种特定协议的，这些词包括：ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet,tcp和udp。其实这些词经常用来匹配某种协议，是使用率最高的一组词了。</p>

<p>　　上面三种qualitifer和id name或number组成一个primitive通常是下面这种方式的：</p>

<p>　　proto dir type id(number) ，即primitive=proto dir type (id | number)</p>

<p>　　如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　tcp src port 80
</span><span class='line'>
</span><span class='line'>　　ip dst host 192.168.1.1</span></code></pre></td></tr></table></div></figure>


<p>　　如果出现type的话，一定会出现id或num</p>

<p>　　如果出现dir，那么也会出现type,如果不出现，默认为host</p>

<p>　　而proto可单独出现，如 tcpdump &lsquo;tcp&rsquo;</p>

<p>　　通过上面介绍的三种qualitifer，我们很快就可以写出一个primitive，下面我就只用一个primitive作为expression匹配数据包。</p>

<p>　　(1)匹配ether包</p>

<p>　　匹配特定mac地址的数据包。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　tcpdump 'ether src 00:19:21:1D:75:E6'</span></code></pre></td></tr></table></div></figure>


<p>　　匹配源mac为00:19:21:1D:75:E6的数据包其中src可改为dst, src or dst来匹改变条件</p>

<p>　　匹配ether广播包。ether广播包的特征是mac全1.故如下即可匹配：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　tcpdump 'ether dst ff:ff:ff:ff:ff:ff'
</span><span class='line'>
</span><span class='line'>　　ylin@ylin:~$ sudo tcpdump -c 1 'ether dst ff:ff:ff:ff:ff:ff'
</span><span class='line'>
</span><span class='line'>　　tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
</span><span class='line'>
</span><span class='line'>　　listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
</span><span class='line'>
</span><span class='line'>　　10:47:57.784099 arp who-has 192.168.240.77 tell 192.168.240.189</span></code></pre></td></tr></table></div></figure>


<p>　　在此，只匹配1个包就退出了。第一个是arp请求包，arp请求包的是采用广播的方式发送的，被匹配那是当之无愧的。</p>

<p>　　匹配ether组播包，ether的组播包的特征是mac的最高位为1，其它位用来表示组播组编号，如果你想匹配其的多播组，知道它的组MAC地址即可。如</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　tcpdump 'ether dst &lt;Mac_Adrress&gt;' Mac_Address表示地址，填上适当的即可。如果想匹配所有的ether多播数据包，那么暂时请放下，下面会继续为你讲解更高级的应用。</span></code></pre></td></tr></table></div></figure>


<p>　　(2)匹配arp包</p>

<p>　　arp包用于IP到Mac址转换的一种协议，包括arp请求和arp答应两种报文，arp请求报文是ether广播方式发送出去的，也即 arp请求报文的mac地址是全1，因此用ether dst FF;FF;FF;FF;FF;FF可以匹配arp请求报文，但不能匹配答应报文。因此要匹配arp的通信过程，则只有使用arp来指定协议。</p>

<p>　　tcpdump &lsquo;arp&rsquo; 即可匹配网络上arp报文。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　ylin@ylin:~$ arping -c 4 192.168.240.1&gt;/dev/null& sudo tcpdump -p 'arp'
</span><span class='line'>
</span><span class='line'>　　[1] 9293
</span><span class='line'>
</span><span class='line'>　　WARNING: interface is ignored: Operation not permitted
</span><span class='line'>
</span><span class='line'>　　tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
</span><span class='line'>
</span><span class='line'>　　listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
</span><span class='line'>
</span><span class='line'>　　11:09:25.042479 arp who-has 192.168.240.1 (00:03:d2:20:04:28 (oui Unknown)) tell ylin.local
</span><span class='line'>
</span><span class='line'>　　11:09:25.042702 arp reply 192.168.240.1 is-at 00:03:d2:20:04:28 (oui Unknown)
</span><span class='line'>
</span><span class='line'>　　11:09:26.050452 arp who-has 192.168.240.1 (00:03:d2:20:04:28 (oui Unknown)) tell ylin.local
</span><span class='line'>
</span><span class='line'>　　11:09:26.050765 arp reply 192.168.240.1 is-at 00:03:d2:20:04:28 (oui Unknown)
</span><span class='line'>
</span><span class='line'>　　11:09:27.058459 arp who-has 192.168.240.1 (00:03:d2:20:04:28 (oui Unknown)) tell ylin.local
</span><span class='line'>
</span><span class='line'>　　11:09:27.058701 arp reply 192.168.240.1 is-at 00:03:d2:20:04:28 (oui Unknown)
</span><span class='line'>
</span><span class='line'>　　11:09:33.646514 arp who-has ylin.local tell 192.168.240.1
</span><span class='line'>
</span><span class='line'>　　11:09:33.646532 arp reply ylin.local is-at 00:19:21:1d:75:e6 (oui Unknown)</span></code></pre></td></tr></table></div></figure>


<p>　　本例中使用arping -c 4 192.168.240.1产生arp请求和接收答应报文，而tcpdump -p ‘arp’匹配出来了。此处-p选项是使网络工作于正常模式（非混杂模式），这样是方便查看匹配结果。</p>

<p>　　(3)匹配IP包</p>

<p>　　众所周知，IP协议是TCP/IP协议中最重要的协议之一，正是因为它才能把Internet互联起来，它可谓功不可没，下面分析匹配IP包的表达式。</p>

<p>　　对IP进行匹配</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　tcpdump ‘ip src 192.168.240.69′
</span><span class='line'>
</span><span class='line'>　　ylin@ylin:~$ sudo tcpdump -c 3 ‘ip src 192.168.240.69′
</span><span class='line'>
</span><span class='line'>　　tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
</span><span class='line'>
</span><span class='line'>　　listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
</span><span class='line'>
</span><span class='line'>　　11:20:00.973605 IP ylin.local.51486 &gt; walnut.crossbeamsys.com.ssh: S 2706301341:2706301341(0) win 5840 &lt;mss 1460,sackOK,timestamp 1687608 0,nop,wscale 5&gt;
</span><span class='line'>
</span><span class='line'>　　11:20:00.974328 IP ylin.local.32849 &gt; 192.168.200.150.domain: 5858+ PTR? 20.200.168.192.in-addr.arpa. (45)
</span><span class='line'>
</span><span class='line'>　　11:20:01.243490 IP ylin.local.51486 &gt; walnut.crossbeamsys.com.ssh: . ack 2762262674 win 183 &lt;nop,nop,timestamp 1687676 4155416897&gt;</span></code></pre></td></tr></table></div></figure>


<p>　　IP广播组播数据包匹配：只需指明广播或组播地址即可</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　tcpdump ‘ip dst 240.168.240.255′
</span><span class='line'>
</span><span class='line'>　　ylin@ylin:~$ sudo tcpdump ‘ip dst 192.168.240.255′
</span><span class='line'>
</span><span class='line'>　　tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
</span><span class='line'>
</span><span class='line'>　　listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
</span><span class='line'>
</span><span class='line'>　　11:25:29.690658 IP dd.local &gt; 192.168.240.255: ICMP echo request, id 10022, seq 1, length 64
</span><span class='line'>
</span><span class='line'>　　11:25:30.694989 IP dd.local &gt; 192.168.240.255: ICMP echo request, id 10022, seq 2, length 64
</span><span class='line'>
</span><span class='line'>　　11:25:31.697954 IP dd.local &gt; 192.168.240.255: ICMP echo request, id 10022, seq 3, length 64
</span><span class='line'>
</span><span class='line'>　　11:25:32.697970 IP dd.local &gt; 192.168.240.255: ICMP echo request, id 10022, seq 4, length 64
</span><span class='line'>
</span><span class='line'>　　11:25:33.697970 IP dd.local &gt; 192.168.240.255: ICMP echo request, id 10022, seq 5, length 64
</span><span class='line'>
</span><span class='line'>　　11:25:34.697982 IP dd.local &gt; 192.168.240.255: ICMP echo request, id 10022, seq 6, length 64</span></code></pre></td></tr></table></div></figure>


<p>　　此处匹配的是ICMP的广播包，要产生此包，只需要同一个局域网的另一台主机运行ping -b 192.168.240.255即可，当然还可产生组播包，由于没有适合的软件进行模拟产生，在此不举例子。</p>

<p>　　(4)匹配TCP数据包</p>

<p>　　TCP同样是TCP/IP协议栈里面最为重要的协议之一，它提供了端到端的可靠数据流，同时很多应用层协议都是把TCP作为底层的通信协议，因为TCP的匹配是非常重要的。</p>

<p>　　如果想匹配HTTP的通信数据，那只需指定匹配端口为80的条件即可</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　tcpdump ‘tcp dst port 80′
</span><span class='line'>
</span><span class='line'>　　ylin@ylin:~$ wget http://www.baidu.com 2&gt;1 1 &gt;/dev/null & sudo tcpdump -c 5 ‘tcp port 80′
</span><span class='line'>
</span><span class='line'>　　[1] 10762
</span><span class='line'>
</span><span class='line'>　　tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
</span><span class='line'>
</span><span class='line'>　　listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes
</span><span class='line'>
</span><span class='line'>　　12:02:47.549056 IP xd-22-43-a8.bta.net.cn.www &gt; ylin.local.47945: S 1202130469:1202130469(0) ack 1132882351 win 2896 &lt;mss 1460,sackOK,timestamp 3497190920 2329221,nop,wscale 2&gt;
</span><span class='line'>
</span><span class='line'>　　12:02:47.549085 IP ylin.local.47945 &gt; xd-22-43-a8.bta.net.cn.www: . ack 1 win 183 &lt;nop,nop,timestamp 2329258 3497190920&gt;
</span><span class='line'>
</span><span class='line'>　　12:02:47.549226 IP ylin.local.47945 &gt; xd-22-43-a8.bta.net.cn.www: P 1:102(101) ack 1 win 183 &lt;nop,nop,timestamp 2329258 3497190920&gt;
</span><span class='line'>
</span><span class='line'>　　12:02:47.688978 IP xd-22-43-a8.bta.net.cn.www &gt; ylin.local.47945: . ack 102 win 698 &lt;nop,nop,timestamp 3497190956 2329258&gt;
</span><span class='line'>
</span><span class='line'>　　12:02:47.693897 IP xd-22-43-a8.bta.net.cn.www &gt; ylin.local.47945: . 1:1409(1408) ack 102 win 724 &lt;nop,nop,timestamp 3497190957 2329258&gt;
</span><span class='line'>
</span><span class='line'> ```
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'>
</span><span class='line'>　　(5)匹配udp数据包
</span><span class='line'>
</span><span class='line'>　　udp是一种无连接的非可靠的用户数据报，因此udp的主要特征同样是端口，用如下方法可以匹配某一端口
</span><span class='line'>
</span><span class='line'>　　tcpdump ‘upd port 53′ 查看DNS的数据包</span></code></pre></td></tr></table></div></figure>


<p>　　ylin@ylin:~$ ping -c 1 www.baidu.com > /dev/null&amp; sudo tcpdump -p udp port 53</p>

<p>　　[1] 11424</p>

<p>　　tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</p>

<p>　　listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes</p>

<p>　　12:28:09.221950 IP ylin.local.32853 > 192.168.200.150.domain: 63228+ PTR? 43.22.108.202.in-addr.arpa. (44)</p>

<p>　　12:28:09.222607 IP ylin.local.32854 > 192.168.200.150.domain: 5114+ PTR? 150.200.168.192.in-addr.arpa. (46)</p>

<p>　　12:28:09.487017 IP 192.168.200.150.domain > ylin.local.32853: 63228 1/0/0 (80)</p>

<p>　　12:28:09.487232 IP 192.168.200.150.domain > ylin.local.32854: 5114 NXDomain* 0/1/0 (140)</p>

<p>　　12:28:14.488054 IP ylin.local.32854 > 192.168.200.150.domain: 60693+ PTR? 69.240.168.192.in-addr.arpa. (45)</p>

<p>　　12:28:14.755072 IP 192.168.200.150.domain > ylin.local.32854: 60693 NXDomain 0/1/0 (122)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　使用ping www.baidu.com目标是产生DNS请求和答应，53是DNS的端口号。
</span><span class='line'>
</span><span class='line'>　　此外还有很多qualitifer是还没有提及的，下面是其它合法的primitive,在tcpdump中是可以直接使用的。
</span><span class='line'>
</span><span class='line'>　　gateway host
</span><span class='line'>
</span><span class='line'>　　匹配使用host作为网关的数据包，即数据报中mac地址（源或目的）为host，但IP报的源和目的地址不是host的数据包。</span></code></pre></td></tr></table></div></figure>


<p>　　dst net net</p>

<p>　　src net net</p>

<p>　　net net</p>

<p>　　net net mask netmask</p>

<p>　　net net/len</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　匹配IPv4/v6地址为net网络的数据报。
</span><span class='line'>
</span><span class='line'>　　其中net可以为192.168.0.0或192.168这两种形式。如net 192.168 或net 192.168.0.0
</span><span class='line'>
</span><span class='line'>　　net net mask netmask仅对IPv4数据包有效，如net 192.168.0.0 mask 255.255.0.0
</span><span class='line'>
</span><span class='line'>　　net net/len同样只对IPv4数据包有效，如net 192.168.0.0/16
</span><span class='line'>
</span><span class='line'>　　dst portrange port1-port2
</span><span class='line'>
</span><span class='line'>　　src portrange port1-port2
</span><span class='line'>
</span><span class='line'>　　portrange port1-port2
</span><span class='line'>
</span><span class='line'>　　匹配端口在port1-port2范围内的ip/tcp，ip/upd，ip6/tcp和ip6/udp数据包。dst, src分别指明源或目的。没有则表示src or dst
</span><span class='line'>
</span><span class='line'>　　less length 匹配长度少于等于length的报文。
</span><span class='line'>
</span><span class='line'>　　greater length 匹配长度大于等于length的报文。
</span><span class='line'>
</span><span class='line'>　　ip protochain protocol 匹配ip报文中protocol字段值为protocol的报文
</span><span class='line'>
</span><span class='line'>　　ip6 protochain protocol 匹配ipv6报文中protocol字段值为protocol的报文
</span><span class='line'>
</span><span class='line'>　　如tcpdump ‘ip protochain 6 匹配ipv4网络中的TCP报文，与tcpdump ‘ip && tcp’用法一样，这里的&&连接两个primitive。6是TCP协议在IP报文中的编号。
</span><span class='line'>
</span><span class='line'>　　ether broadcast
</span><span class='line'>
</span><span class='line'>　　匹配以太网广播报文
</span><span class='line'>
</span><span class='line'>　　ether multicast
</span><span class='line'>
</span><span class='line'>　　匹配以太网多播报文
</span><span class='line'>
</span><span class='line'>　　ip broadcast
</span><span class='line'>
</span><span class='line'>　　匹配IPv4的广播报文。也即IP地址中主机号为全0或全1的IPv4报文。
</span><span class='line'>
</span><span class='line'>　　ip multicast
</span><span class='line'>
</span><span class='line'>　　匹配IPv4多播报文，也就是IP地址为多播地址的报文。
</span><span class='line'>
</span><span class='line'>　　ip6 multicast
</span><span class='line'>
</span><span class='line'>　　匹配IPv6多播报文，即IP地址为多播地址的报文。
</span><span class='line'>
</span><span class='line'>　　vlan vlan_id
</span><span class='line'>
</span><span class='line'>　　匹配为vlan报文 ，且vlan号为vlan_id的报文
</span><span class='line'>
</span><span class='line'>　　到些为此，我们一直在介绍primitive是如何使用的，也即expression只有一个primitive。通过学会写好每个primtive，我们就很容易把多个primitive组成一个expression，方法很简单，通过逻辑运算符连接起来就可以了，逻辑运算符有以下三个：
</span><span class='line'>
</span><span class='line'>　　“&&” 或”and”
</span><span class='line'>
</span><span class='line'>　　“||” 或“or”
</span><span class='line'>
</span><span class='line'>　　“!” 或“not”
</span><span class='line'>
</span><span class='line'>　　并且可通过()进行复杂的连接运算。
</span><span class='line'>
</span><span class='line'>　　如tcpdump ‘ip && tcp’</span></code></pre></td></tr></table></div></figure>


<p>　　tcpdump ‘ host 192.168.240.3 &amp;&amp;( tcp port 80 || tcp port 443)’</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>　　通过上面的各种primitive，我们可以写出很丰富的条件，如ip, tcp, udp,vlan等等。如IP，可以按址址进行匹，tcp/udp可以按端口匹配。但是，如果我想匹配更细的条件呢？如tcp中只含syn标志，fin标志的报文呢？上面的primitive恐怕无能为力了。不用怕，tcpdump为你提供最后一个功能最强大的primitive，记住是primitive，而不是expression。你可以用多个这个的primitive组成更复杂的 expression.
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'>
</span><span class='line'>　　最后一个primitive形式为 expr relop expr
</span><span class='line'>
</span><span class='line'>　　若把这个形式记为A，那么你可这样写tcpdump ‘A1 && A2 && ip src 192.168.200.1′，等等。
</span><span class='line'>
</span><span class='line'>　　下面我们就来分析A这个形式，看看这是如何强大，如果你觉得很乱的话，建议你先用用上面的知识来实际操作几次，要不然就会很乱的，因为expression太复杂了。
</span><span class='line'>
</span><span class='line'>　　形式：expr relop expr
</span><span class='line'>
</span><span class='line'>　　relop表示关系操作符，可以为&gt;, &lt; ,&gt;=,&lt;=, =, !=之一，
</span><span class='line'>
</span><span class='line'>　　expr是一个算术表达式，由整数组成和二元运算符（＋，－，＊，/，＆，|, &lt;&lt;, &gt;&gt;)，长度操作，报文数据访问子。同时所有的整数都是无符号的，即0×80000000 和 0xffffffff &gt; 0。为了访问报文中的数据，可使用如下方式：
</span><span class='line'>
</span><span class='line'>　　proto [ expr : size ]
</span><span class='line'>
</span><span class='line'>　　proto表示该问的报文，expr的结果表示该报文的偏移，size为可选的，表示从expr偏移量起的szie个字节，整个表达式为proto报文 中,expr起的szie字节的内容（无符号整数）
</span><span class='line'>
</span><span class='line'>　　下面是expr relop expr这种形式primitive的例子：
</span><span class='line'>
</span><span class='line'>　　’ether[0] & 1 !=0′ ether报文中第0个bit为1，即以太网广播或组播的primtive。
</span><span class='line'>
</span><span class='line'>　　通过这种方式，我们可以对报文的任何一个字节进行匹配了，因此它的功能是十分强大的。
</span><span class='line'>
</span><span class='line'>　　‘ip[0] = 4’ ip报文中的第一个字节为version，即匹配IPv4的报文，
</span><span class='line'>
</span><span class='line'>　　如果我们想匹配一个syn报文，可以使用：’tcp[13] = 2′，因为tcp的标志位为TCP报文的第13个字节，而syn在这个字节的低1位，故匹配只有syn标志的报文,上述条件是可满要求的，并且比较严格。
</span><span class='line'>
</span><span class='line'>　　如果想匹配ping命令的请求报文，可以使用’icmp[0]=8′，因为icmp报文的第0字符表示类型，当类型值为8时表示为回显示请求。
</span><span class='line'>
</span><span class='line'>　　对于TCP和ICMP中常用的字节，如TCP中的标志位，ICMP中的类型，这个些偏移量有时会忘记。不过tcpdump为你提供更方便的用法，你不用记位这些数字，用字符就可以代替了.
</span><span class='line'>
</span><span class='line'>　　对于ICMP报文，类型字节可以icmptype来表示它的偏称量，上面的primitive可改为’icmp[icmptype] =8′，如果8也记不住怎么办？tcpdump还为该字节的值也提供了字符表示，如’icmp[icmptype] = icmp-echo’。
</span><span class='line'>
</span><span class='line'>　　下面是tcpdump提供的字符偏移量：
</span><span class='line'>
</span><span class='line'>　　icmptype：表示icmp报文中类弄字节的偏移量
</span><span class='line'>
</span><span class='line'>　　icmpcode:表示icmp报文中编码字节的偏移量
</span><span class='line'>
</span><span class='line'>　　tcpflags:表示TCP报文中标志位字节的偏移量
</span><span class='line'>
</span><span class='line'>　　此外，还提供了很多值来对应上面的偏移字节：
</span><span class='line'>
</span><span class='line'>　　ICMP中类型字节的值可以是：
</span><span class='line'>
</span><span class='line'>　　icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redi‐rect, icmp-echo, icmp-routeradvert, icmp-routersolicit,
</span><span class='line'>
</span><span class='line'>　　icmp-timxceed, icmp-paramprob, icmp-tstamp, icmp-tstam‐preply, icmp-ireq, icmp-ireqreply, icmp-maskreq, icmp-maskreply.
</span><span class='line'>
</span><span class='line'>　　TCP中标志位字节的值可以是：
</span><span class='line'>
</span><span class='line'>　　tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg.
</span><span class='line'>
</span><span class='line'>　　通过上面的字符表示，我们可以写出下面的primitive
</span><span class='line'>
</span><span class='line'>　　’tcp[tcpflags] = tcp-syn’ 匹配只有syn标志设置为1的 tcp报文
</span><span class='line'>
</span><span class='line'>　　’tcp[tcpflags] & (tcp-syn |tcp-ack |tcp-fin) !=0′ 匹配含有syn，或ack或fin标志位的TCP报文
</span><span class='line'>
</span><span class='line'>　　对于IP报文，没有提供字符支持，如果想匹配更细的条件，直接使用数字指字偏移量就可以了，不过要对IP报文有更深入的了解才可以。
</span><span class='line'>
</span><span class='line'>　　学会写primitive后，expression就是小菜一碟了，由一个或多个primitive组成，并且逻辑连接符组成即可：</span></code></pre></td></tr></table></div></figure>


<p>　　tcpdump ‘host 192.168.240.91 &amp;&amp; icmp[icmptype] = icmp-echo’</p>

<p>　　tcpdump ‘host 192.168.1.100 &amp;&amp; vrrp’</p>

<p>　　tcpdump ‘ether src 00:00:00:00:00:02 &amp;&amp; ether[0] &amp; 1 !=0′
&#8220;`
　　让你随心所欲地使用tcpdump，将不用再从复杂的输出中去挑报文了！</p>

<p>　　如此，我们可以写出更复杂的表达式来匹配报文，如IP或TCP中的报文id，IP是中的分段标志，ICMP中类型和代码等。</p>

<p>转载自<a href="http://blog.csdn.net/zjl_1026_2001/article/details/7303118">http://blog.csdn.net/zjl_1026_2001/article/details/7303118</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[今天]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/jin-tian/"/>
    <updated>2013-05-19T10:49:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/jin-tian</id>
    <content type="html"><![CDATA[<p>今天~冷~冻~冰。高一同班的一女生今告诉我《盗墓笔记8》出了，曾经坐在她后面看这小说，想不到她居然也看了而且很迷恋。。移动硬盘两天了还没到，可恶的申通！！晚上打电话回家了。。怀念老妈做的菜，更喜欢吃自个做的菜。。青菜啊。。就这样了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[想说的那些话]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/xiang-shuo-de-na-xie-hua/"/>
    <updated>2013-05-19T10:47:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/xiang-shuo-de-na-xie-hua</id>
    <content type="html"><![CDATA[<pre><code>许久未曾写下些什么,每次抬起手放在键盘上就有种卡住的感觉,如鲠在喉.10年9月自己单枪匹马的坐着k538经过一天一夜的奔波来到杭州，进入了计量~时间过的太快了,禁不起片刻的伫足.转眼四年已快过四分之三了
伴随着成长,随之而来的便是压力.回忆起小时候信誓旦旦的说想快点长大,是多么的天真.殊不知长大的结局就是各种莫名其妙的压力开始死皮赖脸的往你肩上垒.我并不是反感压力,反而我倒是挺嗜迷这种压力的感觉.说来也奇怪,人总是对自己的真实存在充满怀疑,而这些代表着责任的压力恰恰填补了存在感缺失的空隙.
思前想后,总是被一个问题困扰.人为什么而活.记得之前不少在室友面前感叹人生,还因而被他们当做笑柄.我们活着的意义是什么呢?即便那样不着调的理由也算意义的话,那么人活着连这种可怜的意义都没有.长辈们说为了下一代,父母为了儿女,儿女又为了未来的下一代.这便是如今普遍支撑起人们意志的理由.然而这是意义么?也许问题本身就存在毛病,很多事情并不是为了有意义而存在的.这世间万物的存在,它们又何时想过意义.所以太追求意义只是可笑的作茧自缚.
之前想过~十多年的寒窗”苦”读,总想给自己放个长长的假.去各处游历也好.就像南宁帮的小宝哥一样现在到处旅游~总之是想过一种没有任何压力的生活.但是现实是禁不起这么久的清闲的.正如我刚才说的,时间禁不起半点伫足
前几天跟老同学调侃~~大家都问毕业后会回省内发展吗？我说不回的~原因很简单：专业不对口~我也想为家乡的发展作贡献的~毕竟很多人都说,像我这样还会那么一丁半点技术的水货,应该去杭州上海深圳那样的大城市去发展,待遇很更好~自己身边的大牛们也都奔向这些城市~待遇都5k左右或者更多的~或许吧~但这样随之就有很多问题随之而来~
原来在人人上面看过几篇帖子,有说父母慢慢变老的细节的,也有正儿八经计算我们一生还能见父母多少次的.不管形式如何,主题都是一样.人在长大,父母在变老.我们在一起的年华并不如我们想象的那么多了.看完之后感触颇深,”父母在,不远游”也成了我经常念及的话.虽说”好男儿志在四方”苦守一地只会沦为窝囊的代名词.但我总觉得,人活着总要去在意一点情感吧,这样也不妄自诩情感生物.时常能见着父母,能隔三岔五的嘘个寒问个暖什么的才是我想要的.所以现在的我远在它乡~一周至少会打两次长途回家跟老爸老妈唠叨上一段时间~算是对自己的罪过的一种弥补吧~至少这样我打完电话的心情总是明朗~就像之前我打回去告诉放假回家的具体日期后~~现在我每次打回去他们都会问票买的怎么样了~
</code></pre>

<p>   之前打电话回家老爸老妈总会问生活费还够用吗？我总说够用的~其实确是够用了~虽说每个家庭,每位父母都不会计较儿女用自己再多的钱.但是潜移默化的从家长的口中会流露出,诸如”这么大还用家里的钱”或者”养你那么多年,看看你用我了多少钱”此类的,看似平常,却略带点责备的语句.请原谅我的狭隘,我总感觉这些话是莫大的讽刺.它仿佛一个驮在你背上,你甩也甩不掉的怪物.还时刻的提醒你,告诫你,你这个浪费钱的家伙,你的存在根本就是一个错误,一个天天吃了睡,睡了吃的东西居然浪费这么多金钱,可耻,可恨!每每想到此处,我心中便充满了负罪感,恨不得马上去死掉.我有平板，尼康卡片机,移动硬盘各种高端电子设备~其实是我在上海的老哥给我买的~总之我不想成为家人的负担了~</p>

<pre><code>总之,再多的原因都是我在自说自话.路是错是对反正已经走到了这一步,定要认认真真,踏踏实实的走下去.说起”踏踏实实”,这也是我这些年来感悟最多的一个词.不管友情,亲情,爱情都不是该用语言来诠释的东西.用心去做,心中自泯~冷暖自知的便好.
写了好多也说了好多~这些年来经历也算不少了~今天看了自己大一写的那些计划~发现自己写的那些东西居然跟自己如今的行径大体相同~不论如何~世界末日已过~~新纪元开始了~~这也算是给自己新纪元的新的风向标吧~想说的太多了~~以后再说吧~~

```                                                                                                         
                                                                                                                                –by 2012-12-22 mdk-vimer
```
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有的时候]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/you-de-shi-hou/"/>
    <updated>2013-05-19T10:46:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/you-de-shi-hou</id>
    <content type="html"><![CDATA[<p>  有的时候喜欢不吃不喝，一个人走过饭堂门口，感觉不饿，想想，再绕回来；
  有的时候喜欢让自己很忙，累到心里都感觉到疲惫了，蒙起头就睡，不让自己伤神再想起别的事来；
  有的时候醒来会想起某些人，曾经还以为，少了谁都不会怎样，生活还不是一样要过。－－其实不是这样，想念有的时候会让人痛彻心扉；
  有的时候话特别多，喜欢喊着讲，不一定是高兴才这样，也不全是难过非要发泄，可能只是单纯的想而已；
  有的时候喜欢某一首歌，单曲循环，反复听着，像是听着自己的心声那样，比如“十年”：十年之前你不认识我，我也不认识你…十年之后我们是朋友，还可以问候…一路走来，再走下去，遇人无数，谁会是谁的过客，谁又会是谁的知己；
  有的时候很沉默，喜欢一句话都不说，一个人走到某个角落，渐渐的，把某些事想开来，刹那间，让自己找到奋斗下去的勇气；
  有的时候喜欢逛逛朋友的空间，不怎么留痕迹，感觉你们快乐就好；
  有的时候会和别人说，其实我很内向，只是喜欢在你们面前“聒噪”而已，经常某些人会瞪着眼睛反回来，“少来了你，就你这样还内向呢…”有点不知所措，笑笑，无所谓吧，我们一起快乐就好；
  有的时候想着去联系某个人，拿起电话的时候才知道，其实不懂要说什么，总是会突然怀念一些朋友，在心里的问候，也许你们不懂；
  有的时候很多人在一起，感觉很开心，只是自己不怎么喜欢讲话，喜欢听别人讲那些自己经历过或不曾经历过的事，经常在心里感慨：哇，人家见识好广，懂得很多；
  有的时候渴望和我们家族的人在一起，不做什么，一起聊聊天，听听他们唱歌，也会觉得很温馨，偶尔有的时候玩真心话大冒险，会把小丑弄得很委屈，呵呵…其实我也挨她整得很无语过；
  有的时候会很想去某个地方，比如说南宁，不为什么，只是有好多同学在那，会很想他们，我的青春，他们加入过，曾经我们一起努力过，奋斗过。或者走在街上，还会遇到某张熟悉的面孔，打招呼的时候也许会这样说：真巧，你也在这；
  有的时候感觉心里有些不好过，因为大大小小的考试太多，有些顾不上朋友，他们会以为我变了，冷落了他们，其实不是这样，可是很多时候不懂怎么说，害怕他们这样回我，人家读大学都很多课余时间，难道就只有你忙吗；</p>

<p>  有的时候会很想家，想家里人的时候很温馨，也很有动力，常常有这样的感觉，我可以努力去做很多事，只要他们健康、快乐就好；
  有的时候还会为久违的问候而感动，人家说，我不想知道你的主角是谁，我只是想看看你的文字而已…傻啊，你怎么不说你是想看看我的心情，想知道我过得好不好呢；
  有的时候…有的时候也想问某个人，如果你也听说，我把自己的生活过成这样，会不会你也开始有那么一点心疼我？
  有的时候，每个人都有很多个“有的时候”吧，只是不同的时候不同的心情，不同的感慨而已。我不知道你在想什么，不知道你在做什么，也许吃饭，也许～～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ubuntu livecd]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/ubuntu-livecd/"/>
    <updated>2013-05-19T10:45:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/ubuntu-livecd</id>
    <content type="html"><![CDATA[<p>将现有的ubuntu系统打造成LiveCD ~下载Live Ubuntu Backup V2.2 (lub)</p>

<p>将所有环境装好后分别执行: 将lub放到家目录</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1.sudo chmod 777 /home/lub
</span><span class='line'>
</span><span class='line'>2.sudo /home/lub -b</span></code></pre></td></tr></table></div></figure>


<p>然后按e或c来选择是英文提示，还是中文提示。第一次执行时，可能会提示需要安装lupin-casper和squashfs-tools，其中 lupin-casper可以忽略，而squashfs-tools必须安装，运行$sudo apt-get install squashfs-tools即可</p>

<p>之后再次运行$sudo /home/lub -b，依提示运行，就能在用户文件夹下生成一个backup-2013.01.02的目录了，其中有的backup-2013.01.02.squashfs文件就是我们想要的</p>

<p>3.将ubuntu-11.10-desktop.i386.iso拷贝到/home.acmer/下:</p>

<p>执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo /home/acmer/mnt && sudo mount -o loop /home/acmer/Ubuntu-11.10-desktop-i386.iso /home/acmer/mnt</span></code></pre></td></tr></table></div></figure>


<ol>
<li></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo mkdir /home/acmer/livecd 将/home/acmer/mnt下的内容除了casper/filesystem.squashfs，同步到了/home/acmer/livecd目录下。</span></code></pre></td></tr></table></div></figure>


<p>执行:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$sudo rsync –exclude=/home/acmer/acmer/casper/filesystem.squashfs -a /home/acmer/mnt/ /home/acmer/livecd </span></code></pre></td></tr></table></div></figure>


<p>5.对/home/acmer/livecd/casper/目录下的filesystem.squashfs、 filesystem.manifest、filesystem.manifest-desktop这三个文件进行操作，由于它们只有读权限，所以先执行$sudo chmod o+w /home/acmer/livecd/casper/filesystem.*</p>

<p>将刚才lub生成的那个backup-2013.01.02.squashfs文件，拷贝成/home/acmer/livecd/casper/filesystem.squashfs</p>

<p>执行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$sudo cp /home/acmer/backup-2013.01.02/backup2013.01.02.squashfs /home/acmer/livecd/casper/filesystem.squashfs</span></code></pre></td></tr></table></div></figure>


<ol>
<li></li>
</ol>


<p>此外，还要更新/home/acmer/livecd/casper/目录下的filesystem.manifest和filesystem.manifest-remove，这两个文件实际上是系统所装包的列表，通过以下方式更新</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$sudo dpkg -l | grep ii | awk ‘{print $2,$3}’ &gt;/home/acmer/livecd/casper/filesystem.manifest
</span><span class='line'>
</span><span class='line'>$sudo dpkg -l | grep ii | awk {print$2,$3}’&gt; /home/acmer/livecd/casper/filesystem.manifes-remove</span></code></pre></td></tr></table></div></figure>


<ol>
<li></li>
</ol>


<p>退回的LiveCD的工作目录 /home/acmer/livecd 下，</p>

<p>执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$sudo rm md5sum.txt</span></code></pre></td></tr></table></div></figure>


<p>再执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$find -type f -print0 | sudo xargs -0 md5sum | grep -v ./isolinux/ | grep -v ./md5sum.txt | sudo tee md5sum.txt</span></code></pre></td></tr></table></div></figure>


<p>更新原来的md5sum</p>

<ol>
<li></li>
</ol>


<p>将工作目录下的内容打包成ISO</p>

<p>先运行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$sudo apt-get install mkisofs 安装ISO打包工具，</span></code></pre></td></tr></table></div></figure>


<p>执行</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$sudo mkisofs -D -r -V “mdk-linux” -cache-inodes -J -l -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -o ../cjlu-acmer.iso .</span></code></pre></td></tr></table></div></figure>


<p>打包iso时最后一定加 . 来表示目前目录</p>

<p>参照文章来源（有删节）:<a href="http://www.linuxidc.com/Linux/2011-04/34097.htm">http://www.linuxidc.com/Linux/2011-04/34097.htm</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运维的那些命令]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/yun-wei-de-na-xie-ming-ling/"/>
    <updated>2013-05-19T10:42:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/yun-wei-de-na-xie-ming-ling</id>
    <content type="html"><![CDATA[<p>转自:<a href="http://deepin.iteye.com/blog/711813">http://deepin.iteye.com/blog/711813</a>
1.删除0字节文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>find -type f -size 0 -exec rm -rf {} \;</span></code></pre></td></tr></table></div></figure>


<p>2.查看进程
按内存从大到小排列</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ps -e   -o “%C   : %p : %z : %a”|sort -k5 -nr</span></code></pre></td></tr></table></div></figure>


<p>3.按cpu利用率从大到小排列</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ps -e   -o “%C   : %p : %z : %a”|sort   -nr</span></code></pre></td></tr></table></div></figure>


<p>4.打印说cache里的URL</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>grep -r -a   jpg /data/cache/* | strings | grep “http:” | awk -F’http:’ ‘{print “http:”$2;}’</span></code></pre></td></tr></table></div></figure>


<p>5.查看http的并发请求数及其TCP连接状态：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’</span></code></pre></td></tr></table></div></figure>


<ol>
<li></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sed -i ‘/Root/s/no/yes/’ /etc/ssh/sshd_config   sed在这个文里Root的一行，匹配Root一行，将no替换成yes.</span></code></pre></td></tr></table></div></figure>


<p>7.1.如何杀掉mysql进程：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ps aux |grep mysql |grep -v grep  |awk ‘{print $2}’ |xargs kill -9 (从中了解到awk的用途)
</span><span class='line'>
</span><span class='line'>killall -TERM mysqld
</span><span class='line'>
</span><span class='line'>kill -9 `cat /usr/local/apache2/logs/httpd.pid`   试试查杀进程PID</span></code></pre></td></tr></table></div></figure>


<p>8.显示运行3级别开启的服务:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ls /etc/rc3.d/S* |cut -c 15-   (从中了解到cut的用途，截取数据)</span></code></pre></td></tr></table></div></figure>


<p>9.如何在编写SHELL显示多个信息，用EOF</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cat &lt;&lt; EOF
</span><span class='line'>+————————————————————–+
</span><span class='line'>|       === Welcome to Tunoff services ===                |
</span><span class='line'>+————————————————————–+
</span><span class='line'>EOF</span></code></pre></td></tr></table></div></figure>


<ol>
<li>for 的巧用(如给mysql建软链接)</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd /usr/local/mysql/bin
</span><span class='line'>for i in *
</span><span class='line'>do ln /usr/local/mysql/bin/$i /usr/bin/$i
</span><span class='line'>done</span></code></pre></td></tr></table></div></figure>


<ol>
<li>取IP地址：</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ifconfig eth0 |grep “inet addr:” |awk ‘{print $2}’|cut -c 6-   或者
</span><span class='line'>
</span><span class='line'>ifconfig   | grep ‘inet addr:’| grep -v ’127.0.0.1′ | cut -d: -f2 | awk ‘{ print $1}’</span></code></pre></td></tr></table></div></figure>


<p>12.内存的大小:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>free -m |grep “Mem” | awk ‘{print $2}’</span></code></pre></td></tr></table></div></figure>


<ol>
<li></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>netstat -an -t | grep “:80″ | grep ESTABLISHED | awk ‘{printf “%s %s\n”,$5,$6}’ | sort</span></code></pre></td></tr></table></div></figure>


<p>14.查看Apache的并发请求数及其TCP连接状态：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’</span></code></pre></td></tr></table></div></figure>


<p>15.因为同事要统计一下服务器下面所有的jpg的文件的大小,写了个shell给他来统计.原来用xargs实现,但他一次处理一部分,搞的有多个总和….,下面的命令就能解决啦.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>find / -name *.jpg -exec wc -c {} \;|awk ‘{print $1}’|awk ‘{a+=$1}END{print a}’</span></code></pre></td></tr></table></div></figure>


<p>CPU的数量（多核算多个CPU，cat /proc/cpuinfo |grep -c processor）越多，系统负载越低，每秒能处理的请求数也越多。</p>

<p>—————————————————————————————
16   CPU负载</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># cat /proc/loadavg</span></code></pre></td></tr></table></div></figure>


<p>检查前三个输出值是否超过了系统逻辑CPU的4倍。</p>

<p>18   CPU负载</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#mpstat 1 1</span></code></pre></td></tr></table></div></figure>


<p>检查%idle是否过低(比如小于5%)</p>

<p>19   内存空间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># free</span></code></pre></td></tr></table></div></figure>


<p>检查free值是否过低   也可以用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># cat /proc/meminfo</span></code></pre></td></tr></table></div></figure>


<p>20   swap空间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># free</span></code></pre></td></tr></table></div></figure>


<p>检查swap used值是否过高   如果swap used值过高，进一步检查swap动作是否频繁：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># vmstat 1 5</span></code></pre></td></tr></table></div></figure>


<p>观察si和so值是否较大</p>

<p>21   磁盘空间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># df -h</span></code></pre></td></tr></table></div></figure>


<p>检查是否有分区使用率(Use%)过高(比如超过90%)   如发现某个分区空间接近用尽，可以进入该分区的挂载点，用以下命令找出占用空间最多的文件或目录：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># du -cks * | sort -rn | head -n 10</span></code></pre></td></tr></table></div></figure>


<p>22   磁盘I/O负载</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># iostat -x 1 2</span></code></pre></td></tr></table></div></figure>


<p>检查I/O使用率(%util)是否超过100%</p>

<p>23   网络负载</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># sar -n DEV</span></code></pre></td></tr></table></div></figure>


<p>检查网络流量(rxbyt/s, txbyt/s)是否过高</p>

<p>24   网络错误</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># netstat -i</span></code></pre></td></tr></table></div></figure>


<p>检查是否有网络错误(drop fifo colls carrier)   也可以用命令：# cat /proc/net/dev</p>

<p>25 网络连接数目</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># netstat -an | grep -E “^(tcp)” | cut -c 68- | sort | uniq -c | sort -n</span></code></pre></td></tr></table></div></figure>


<p>26   进程总数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># ps aux | wc -l</span></code></pre></td></tr></table></div></figure>


<p>检查进程个数是否正常 (比如超过250)</p>

<p>27   可运行进程数目</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># vmwtat 1 5</span></code></pre></td></tr></table></div></figure>


<p>列给出的是可运行进程的数目，检查其是否超过系统逻辑CPU的4倍</p>

<p>28   进程</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># top -id 1</span></code></pre></td></tr></table></div></figure>


<p>观察是否有异常进程出现</p>

<p>29   网络状态   检查DNS, 网关等是否可以正常连通</p>

<p>30   用户</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># who | wc -l</span></code></pre></td></tr></table></div></figure>


<p>检查登录用户是否过多 (比如超过50个)   也可以用命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># uptime</span></code></pre></td></tr></table></div></figure>


<p>31   系统日志</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># cat /var/log/rflogview/*errors</span></code></pre></td></tr></table></div></figure>


<p> 检查是否有异常错误记录   也可以搜寻一些异常关键字，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># grep -i error /var/log/messages
</span><span class='line'># grep -i fail /var/log/messages</span></code></pre></td></tr></table></div></figure>


<p>32   核心日志</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># dmesg</span></code></pre></td></tr></table></div></figure>


<p>检查是否有异常错误记录</p>

<p>33   系统时间</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># date</span></code></pre></td></tr></table></div></figure>


<p>检查系统时间是否正确</p>

<p>34   打开文件数目</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># lsof | wc -l</span></code></pre></td></tr></table></div></figure>


<p>检查打开文件总数是否过多</p>

<p>35   日志</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># logwatch –print   配置/etc/log.d/logwatch.conf，将 Mailto 设置为自己的email 地址，启动mail服务 (sendmail或者postfix)，这样就可以每天收到日志报告了。</span></code></pre></td></tr></table></div></figure>


<p>缺省logwatch只报告昨天的日志，可以用# logwatch –print –range all 获得所有的日志分析结果。
可以用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># logwatch –print –detail high 获得更具体的日志分析结果(而不仅仅是出错日志)。</span></code></pre></td></tr></table></div></figure>


<p>36.杀掉80端口相关的进程</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>lsof -i :80|grep -v “PID”|awk ‘{print “kill -9″,$2}’|sh</span></code></pre></td></tr></table></div></figure>


<p>37.清除僵死进程。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ps -eal | awk ‘{ if ($2 == “Z”) {print $4}}’ | kill -9</span></code></pre></td></tr></table></div></figure>


<p>38.tcpdump 抓包 ，用来防止80端口被人攻击时可以分析数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># tcpdump -c 10000 -i eth0 -n dst port 80 &gt; /root/pkts</span></code></pre></td></tr></table></div></figure>


<p>39.然后检查IP的重复数 并从小到大排序 注意 “-t\ +0″   中间是两个空格</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># less pkts | awk {‘printf $3″\n”‘} | cut -d. -f 1-4 | sort | uniq -c | awk {‘printf $1″ “$2″\n”‘} | sort -n -t\ +0</span></code></pre></td></tr></table></div></figure>


<p>40.查看有多少个活动的php-cgi进程</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>netstat -anp | grep php-cgi | grep ^tcp | wc -l
</span><span class='line'>
</span><span class='line'>chkconfig –list | awk ‘{if ($5==”3:on”) print $1}’</span></code></pre></td></tr></table></div></figure>


<p>41.kudzu查看网卡型号</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>kudzu –probe –class=network</span></code></pre></td></tr></table></div></figure>


<p>匹配中文字符的正则表达式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[\u4e00-\u9fa5]</span></code></pre></td></tr></table></div></figure>


<p>评注：匹配中文还真是个头疼的事，有了这个表达式就好办了</p>

<p>匹配双字节字符(包括汉字在内)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[^\x00-\xff]</span></code></pre></td></tr></table></div></figure>


<p>评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</p>

<p>匹配空白行的正则表达式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\n\s*\r</span></code></pre></td></tr></table></div></figure>


<p>评注：可以用来删除空白行</p>

<p>匹配HTML标记的正则表达式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</span></code></pre></td></tr></table></div></figure>


<p>评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力</p>

<p>匹配首尾空白字符的正则表达式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>^\s*|\s*$</span></code></pre></td></tr></table></div></figure>


<p>评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式</p>

<p>匹配Email地址的正则表达式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</span></code></pre></td></tr></table></div></figure>


<p>评注：表单验证时很实用</p>

<p>匹配网址URL的正则表达式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[a-zA-z]+://[^\s]*</span></code></pre></td></tr></table></div></figure>


<p>评注：网上流传的版本功能很有限，上面这个基本可以满足需求</p>

<p>匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</span></code></pre></td></tr></table></div></figure>


<p>评注：表单验证时很实用</p>

<p>匹配国内电话号码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\d{3}-\d{8}|\d{4}-\d{7}</span></code></pre></td></tr></table></div></figure>


<p>评注：匹配形式如 0511-4405222 或 021-87888822</p>

<p>匹配腾讯QQ号：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[1-9][0-9]{4,}</span></code></pre></td></tr></table></div></figure>


<p>评注：腾讯QQ号从10000开始</p>

<p>匹配中国邮政编码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[1-9]\d{5}(?!\d)</span></code></pre></td></tr></table></div></figure>


<p>评注：中国邮政编码为6位数字</p>

<p>匹配身份证：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\d{15}|\d{18}</span></code></pre></td></tr></table></div></figure>


<p>评注：中国的身份证为15位或18位</p>

<p>匹配ip地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>\d+\.\d+\.\d+\.\d+</span></code></pre></td></tr></table></div></figure>


<p>评注：提取ip地址时有用</p>

<p>匹配特定数字：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>^[1-9]\d*$　 　 //匹配正整数
</span><span class='line'>^-[1-9]\d*$ 　 //匹配负整数
</span><span class='line'>^-?[1-9]\d*$　　 //匹配整数
</span><span class='line'>^[1-9]\d*|0$　 //匹配非负整数（正整数 + 0）
</span><span class='line'>^-[1-9]\d*|0$　　 //匹配非正整数（负整数 + 0）
</span><span class='line'>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$　　 //匹配正浮点数
</span><span class='line'>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$　 //匹配负浮点数
</span><span class='line'>^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$　 //匹配浮点数
</span><span class='line'>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）
</span><span class='line'>^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$　　//匹配非正浮点数（负浮点数 + 0）</span></code></pre></td></tr></table></div></figure>


<p>评注：处理大量数据时有用，具体应用时注意修正</p>

<p>匹配特定字符串：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串
</span><span class='line'>^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串
</span><span class='line'>^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串
</span><span class='line'>^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串
</span><span class='line'>^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串</span></code></pre></td></tr></table></div></figure>


<p>评注：最基本也是最常用的一些表达式</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[centos启动]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/centosqi-dong/"/>
    <updated>2013-05-19T10:40:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/centosqi-dong</id>
    <content type="html"><![CDATA[<p>启动流程概览</p>

<pre><code>在硬件驱动成功后，Kernel 会主动呼叫 init 程序，而 init 会取得 run-level 资讯；
init 运行 /etc/rc.d/rc.sysinit 文件来准备软件运行的作业环境 (如网络、时区等)；
init 运行 run-level 的各个服务之启动 (script 方式)；
init 运行 /etc/rc.d/rc.local 文件；
init 运行终端机模拟程序 mingetty 来启动 login 程序，最后就等待使用者登陆啦；
</code></pre>

<p> init,/etc/inittab,runlevel介绍</p>

<p>在核心加载完毕、进行完硬件侦测与驱动程序加载后，此时你的主机硬件应该已经准备就绪了 (ready) ， 此时核心会主动的呼叫第一支程序，那就是 /sbin/init 罗。 init 的 PID 号码是一号啦。 /sbin/init 最主要的功能就是准备软件运行的环境，包括系统的主机名称、网络配置、语系处理、文件系统格式及其他服务的启动等。 而所有的动作都会透过 init 的配置档，亦即是 /etc/inittab 来规划，而 inittab 内还有一个很重要的配置项目，那就是默认的 runlevel (启动运行等级) 啦！
Run level：运行等级有哪些？</p>

<p>那么什么是 run level 呢？他有什么功用啊？其实很简单啦， Linux 就是藉由配置 run level 来规定系统使用不同的服务来启动，让 Linux 的使用环境不同。基本上，依据有无网络与有无 X Window 而将 run level 分为 7 个等级，分别是：</p>

<pre><code>0 – halt (系统直接关机)
1 – single user mode (单人维护模式，用在系统出问题时的维护)
2 – Multi-user, without NFS (类似底下的 runlevel 3，但无 NFS 服务)
3 – Full multi-user mode (完整含有网络功能的纯文字模式)
4 – unused (系统保留功能)
5 – X11 (与 runlevel 3 类似，但加载使用 X Window)
6 – reboot (重新启动)
</code></pre>

<p>由於 run level 0, 4, 6 不是关机、重新启动就是系统保留的，所以：『 您当然不能将默认的 run level 配置为这三个值 』， 否则系统就会不断的自动关机或自动重新启动…. 好了，那么我们启动时，到底是如何取得系统的 run level 的？当然是 /etc/inittab 所配置的罗！ 那么 /etc/inittab 到底有什么资讯呢？我们先来看看这个文件的内容好了：
/etc/inittab 的内容与语法
复制代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@www ~]# vim /etc/inittab
</span><span class='line'>id:5:initdefault:                 &lt;==默认的 runlevel 配置, 此 runlevel 为 5 
</span><span class='line'>
</span><span class='line'>si::sysinit:/etc/rc.d/rc.sysinit  &lt;==准备系统软件运行的环境的脚本运行档
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'>l0:0:wait:/etc/rc.d/rc 0    &lt;==runlevel 0 在 /etc/rc.d/rc0.d/
</span><span class='line'>l1:1:wait:/etc/rc.d/rc 1    &lt;==runlevel 1 在 /etc/rc.d/rc1.d/
</span><span class='line'>l2:2:wait:/etc/rc.d/rc 2    &lt;==runlevel 2 在 /etc/rc.d/rc2.d/
</span><span class='line'>l3:3:wait:/etc/rc.d/rc 3    &lt;==runlevel 3 在 /etc/rc.d/rc3.d/
</span><span class='line'>l4:4:wait:/etc/rc.d/rc 4    &lt;==runlevel 4 在 /etc/rc.d/rc4.d/
</span><span class='line'>l5:5:wait:/etc/rc.d/rc 5    &lt;==runlevel 5 在 /etc/rc.d/rc5.d/
</span><span class='line'>l6:6:wait:/etc/rc.d/rc 6    &lt;==runlevel 6 在 /etc/rc.d/rc6.d/
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'>ca::ctrlaltdel:/sbin/shutdown -t3 -r now
</span><span class='line'>
</span><span class='line'> 
</span><span class='line'>pf::powerfail:/sbin/shutdown -f -h +2 "Power Failure; System Shutting Down"
</span><span class='line'>pr:12345:powerokwait:/sbin/shutdown -c "Power Restored; Shutdown Cancelled"</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1:2345:respawn:/sbin/mingetty tty1  &lt;==其实 tty1~tty6 是由底下这六行决定的。
</span><span class='line'>2:2345:respawn:/sbin/mingetty tty2
</span><span class='line'>3:2345:respawn:/sbin/mingetty tty3
</span><span class='line'>4:2345:respawn:/sbin/mingetty tty4
</span><span class='line'>5:2345:respawn:/sbin/mingetty tty5
</span><span class='line'>6:2345:respawn:/sbin/mingetty tty6
</span><span class='line'>
</span><span class='line'>x:5:respawn:/etc/X11/prefdm -nodaemon &lt;==X window 则是这行决定的！</span></code></pre></td></tr></table></div></figure>


<p>复制代码</p>

<p>让我们解析一下这个文件吧！首先，这个文件的语法是利用冒号 (:) 将配置分隔成为四个栏位，每个栏位的意义与说明如下：</p>

<pre><code>配置项目：最多四个字节，代表 init 的主要工作项目，只是一个简单的代表说明。
run level：该项目在哪些 run level 底下进行的意思。如果是 35 则代表 runlevel 3 与 5 都会运行。
init 的动作项目：主要可以进行的动作项目意义有：
inittab 配置值   意义说明
initdefault     代表默认的 run level 配置值
sysinit     代表系统初始化的动作项目
ctrlaltdel  代表 [ctrl]+[alt]+[del] 三个按键是否可以重新启动的配置
wait    代表后面栏位配置的命令项目必须要运行完毕才能继续底下其他的动作
respawn     代表后面栏位的命令可以无限制的再生 (重新启动)。举例来说， tty1 的 mingetty 产生的可登陆画面， 在你注销而结束后，系统会再开一个新的可登陆画面等待下一个登陆。

更多的配置项目请参考 man inittab 的说明。
命令项目：亦即应该可以进行的命令，通常是一些 script 罗。
</code></pre>

<p>init 的处理流程</p>

<p>事实上 /etc/inittab 的配置也有点类似 shell script 啦，因为该文件内容的配置也是一行一行的从上往下处理的， 因此我们可以知道 CentOS 的 init 依据 inittab 配置的处理流程会是：</p>

<pre><code>先取得 runlevel 亦即默认运行等级的相关等级 (以鸟哥的测试机为例，为 5 号)；
使用 /etc/rc.d/rc.sysinit 进行系统初始化
由於 runlevel 是 5 ，因此只进行『l5:5:wait:/etc/rc.d/rc 5』，其他行则略过
配置好 [ctrl]+[alt]+[del] 这组的组合键功能
配置不断电系统的 pf, pr 两种机制；
启动 mingetty 的六个终端机 (tty1 ~ tty6)
最终以 /etc/X11/perfdm -nodaemon 启动图形介面啦！
</code></pre>

<p>现在你可以知道为啥 [ctrl]+[alt]+[del] 可以重新启动而我们默认提供 6 个虚拟终端机 (tty1~tty6) 给你使用了吧！由於整个配置都是依据 /etc/inittab 来决定的，因此如果你想要修改任何细节的话， 可以这样做喔：</p>

<pre><code>如果不想让使用者利用 [crtl]+[alt]+[del] 来重新启动系统，可以将『 ca::ctrlaltdel:/sbin/shutdown -t3 -r now 』加上注解 (#) 来取消该配置
规定启动的默认 run level 是纯文字的 3 号或者是具有图形介面的 5 号 ，可经由 『 id:5:initdefault: 』那个数字来决定！ 以鸟哥自己这个文件为例，我是使用默认的图形介面。如果你想要关闭图形介面的话，将该行 5 改成 3 即可。
如果不想要启动六个终端机 (tty1~tty6)，那么可以将『 6:2345:respawn:/sbin/mingetty tty6』关闭数个。但务必至少启动一个喔！
</code></pre>

<p>所以说，你现在会自行修改登陆时的默认 run level 配置值了吗？够简单的吧？ 一般来说，我们默认都是 3 或者是 5 来作为默认的 run level 的。但有时后可能需要进入 run level 1， 也就是单人维护模式的环境当中。这个 run level 1 有点像是 Windows 系统当中的『安全模式』啦， 专门用来处理当系统有问题时的操作环境。此外，当系统发现有问题时，举例来说，不正常关机造成 filesystem 的不一致现象时，系统会主动的进入单人维护模式呢！</p>

<p>好了， init 在取得 run level 之后，接下来要干嘛？ 上面 /etc/inittab 文件内容不是有提到 sysinit 吗？准备初始化系统了吧！</p>

<p>init 处理系统初始化流程 (/etc/rc.d/rc.sysinit)</p>

<p>还记得上面提到 /etc/inittab 里头有这一句『 si::sysinit:/etc/rc.d/rc.sysinit 』吧？ 这表示：『我开始加载各项系统服务之前，得先做好整个系统环境，我主要利用 /etc/rc.d/rc.sysinit 这个 shell script 来配置好我的系统环境的。』够清楚了吧？ 所以，我想要知道到底 CentOS 启动的过程当中帮我进行了什么动作，就得要仔细的分析 /etc/rc.d/rc.sysinit 罗。</p>

<p>如果你使用 vim 去查阅过 /etc/rc.d/rc.sysinit 的话，那么可以发现他主要的工作大抵有这几项：</p>

<pre><code>取得网络环境与主机类型：
读取网络配置档 /etc/sysconfig/network ，取得主机名称与默认通讯闸 (gateway) 等网络环境。
测试与挂载内存装置 /proc 及 U盘 装置 /sys：
除挂载内存装置 /proc 之外，还会主动侦测系统上是否具有 usb 的装置， 若有则会主动加载 usb 的驱动程序，并且尝试挂载 usb 的文件系统。
决定是否启动 SELinux ：
SELinux 在此时进行一些检测， 并且检测是否需要帮所有的文件重新编写标准的 SELinux 类型 (auto relabel)。
启动系统的乱数产生器
乱数产生器可以帮助系统进行一些口令加密演算的功能，在此需要启动两次乱数产生器。
配置终端机 (console) 字形：
配置显示於启动过程中的欢迎画面 (text banner)；
配置系统时间 (clock) 与时区配置：需读入 /etc/sysconfig/clock 配置值
周边设备的侦测与 Plug and Play (PnP) 参数的测试：
根据核心在启动时侦测的结果 (/proc/sys/kernel/modprobe ) 开始进行 ide / scsi / 网络 / 音效 等周边设备的侦测，以及利用以加载的核心模块进行 PnP 装置的参数测试。
使用者自订模块的加载
使用者可以在 /etc/sysconfig/modules/*.modules 加入自订的模块，则此时会被加载到系统当中
加载核心的相关配置：
系统会主动去读取 /etc/sysctl.conf 这个文件的配置值，使核心功能成为我们想要的样子。
配置主机名称与初始化电源管理模块 (ACPI)
初始化软件磁盘阵列：主要是透过 /etc/mdadm.conf 来配置好的。
初始化 LVM 的文件系统功能
以 fsck 检验磁碟文件系统：会进行 filesystem check
进行磁碟配额 quota 的转换 (非必要)：
重新以可读写模式挂载系统磁碟：
启动 quota 功能：所以我们不需要自订 quotaon 的动作
启动系统虚拟乱数产生器 (pseudo-random)：
清除启动过程当中的缓存文件：
将启动相关资讯加载 /var/log/dmesg 文件中。
</code></pre>

<p>在 /etc/rc.d/rc.sysinit 将基本的系统配置数据都写好了，也将系统的数据配置完整！ 而如果你想要知道到底启动的过程中发生了什么事情呢？那么就运行『 dmesg 』吧。 另外，基本上，在这个文件当中所进行的很多工作的默认配置档，其实都在 /etc/sysconfig/ 当中呢！ 所以，请记得将 /etc/sysconfig/ 内的文件好好的瞧一瞧喔！ ^_^</p>

<p>在这个过程当中，比较值得注意的是自订模块的加载！在 CentOS 当中，如果我们想要加载核心模块的话， 可以将整个模块写入到 /etc/sysconfig/modules/*.modules 当中，在该目录下， 只要记得档名最后是以 .modules 结尾即可。 这个过程是非必要的，因为我们目前的默认模块实在已经很够用了，除非是您的主机硬件实在太新了， 非要自己加载新的模块不可，否则，在经过 /etc/rc.d/rc.sysinit 的处理后， 你的主机系统应该是已经跑得很顺畅了啦！就等著你将系统相关的服务与网络服务启动罗！</p>

<p>启动系统服务与相关启动配置档 (/etc/rc.d/rc N &amp; /etc/sysconfig)</p>

<p>加载核心让整个系统准备接受命令来工作，再经过 /etc/rc.d/rc.sysinit 的系统模块与相关硬件资讯的初始化后，你的 CentOS 系统应该已经顺利工作了。 只是，我们还得要启动系统所需要的各项『服务』啊！这样主机才能提供我们相关的网络或者是主机功能嘛！ 这个时候，依据我们在 /etc/inittab 里面提到的 run level 配置值，就可以来决定启动的服务项目了。 举例来说，使用 run level 3 当然就不需要启动 X Window 的相关服务罗，您说是吧？</p>

<p>那么各个不同的 run level 服务启动的各个 shell script 放在哪？还记得 /etc/inittab 里面提到的：
复制代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>l0:0:wait:/etc/rc.d/rc 0
</span><span class='line'>l1:1:wait:/etc/rc.d/rc 1
</span><span class='line'>l2:2:wait:/etc/rc.d/rc 2
</span><span class='line'>l3:3:wait:/etc/rc.d/rc 3
</span><span class='line'>l4:4:wait:/etc/rc.d/rc 4
</span><span class='line'>l5:5:wait:/etc/rc.d/rc 5  &lt;==本例中，以此项目来解释
</span><span class='line'>l6:6:wait:/etc/rc.d/rc 6</span></code></pre></td></tr></table></div></figure>


<p>复制代码</p>

<p>上面提到的就是各个 run level 要运行的各项脚本放置处啦！主要是透过 /etc/rc.d/rc 这个命令来处理相关任务！ 由於鸟哥使用默认的 runlevel 5 ，因此我们主要针对上述特殊字体那行来解释好了： /etc/rc.d/rc 5 的意义是这样的 (建议您自行使用 vim 去观察一下 /etc/rc.d/rc 这个文件，你会更有概念！)：</p>

<pre><code>透过外部第一号参数 ($1) 来取得想要运行的脚本目录。亦即由 /etc/rc.d/rc 5 可以取得 /etc/rc5.d/ 这个目录来准备处理相关的脚本程序；
找到 /etc/rc5.d/K??* 开头的文件，并进行『 /etc/rc5.d/K??* stop 』的动作；
找到 /etc/rc5.d/S??* 开头的文件，并进行『 /etc/rc5.d/S??* start 』的动作；
</code></pre>

<p>透过上面的说明我们可以知道所有的项目都与 /etc/rc5.d/ 有关，那么我们就来瞧瞧这个目录下有些什么玩意儿吧！
复制代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@www ~]# ll /etc/rc5.d/
</span><span class='line'>lrwxrwxrwx 1 root root 16 Sep  4  2008 K02dhcdbd -&gt; ../init.d/dhcdbd
</span><span class='line'>....(中间省略)....
</span><span class='line'>lrwxrwxrwx 1 root root 14 Sep  4  2008 K91capi -&gt; ../init.d/capi
</span><span class='line'>lrwxrwxrwx 1 root root 23 Sep  4  2008 S00microcode_ctl -&gt; ../init.d/microcode_ctl
</span><span class='line'>lrwxrwxrwx 1 root root 22 Sep  4  2008 S02lvm2-monitor -&gt; ../init.d/lvm2-monitor
</span><span class='line'>....(中间省略)....
</span><span class='line'>lrwxrwxrwx 1 root root 17 Sep  4  2008 S10network -&gt; ../init.d/network
</span><span class='line'>....(中间省略)....
</span><span class='line'>lrwxrwxrwx 1 root root 11 Sep  4  2008 S99local -&gt; ../rc.local
</span><span class='line'>lrwxrwxrwx 1 root root 16 Sep  4  2008 S99smartd -&gt; ../init.d/smartd
</span><span class='line'>....(底下省略)....</span></code></pre></td></tr></table></div></figure>


<p>复制代码</p>

<p>在这个目录下的文件很有趣，主要具有几个特点：</p>

<pre><code>档名全部以 Sxx 或 Kxx ，其中 xx 为数字，且这些数字在文件之间是有相关性的！
全部是连结档，连结到 stand alone 服务启动的目录 /etc/init.d/ 去
</code></pre>

<p>服务的启动主要是以『/etc/init.d/服务档名 {start,stop}』 来启动与关闭的，那么透过刚刚 /etc/rc.d/rc 程序的解说，我们可以清楚的了解到了 /etc/rc5.d/[SK]xx 其实就是跑到 /etc/init.d/ 去找到相对应的服务脚本， 然后分别进行 start (Sxx) 或 stop (Kxx) 的动作而已啦！举例来说，以上述的表格内的 K91capi 及 S10network 为例好了， 透过 /etc/rc.d/rc 5 的运行，这两个文件会这样进行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/etc/rc5.d/K91capi stop –&gt; /etc/init.d/capi stop
</span><span class='line'>/etc/rc5.d/S10network start –&gt; /etc/init.d/network start</span></code></pre></td></tr></table></div></figure>


<p>所以说，你有想要启动该 runlevel 时就运行的服务，那么利用 Sxx 并指向 /etc/init.d/ 的特定服务启动脚本后， 该服务就能够在启动时启动啦！就这么简单！问题是，你需要自行处理这个 K, S 开头的连结档吗？ 并不需要的，chkconfig 就是在负责处理这个连结档啦！这样有没有跟第十八章的观念串在一起了呢？ ^_^</p>

<p>那么为什么 K 与 S 后面要有数字呢？因为各不同的服务其实还是互有关系的。举例来说，如果要启动 WWW 服务，总是得要有网络吧？所以 /etc/init.d/network 就会比较先被启动啦！那么您就会知道在 S 或者是 K 后面接的数字是啥意思了吧？嘿嘿，那就是运行的顺序啦！那么哪个文件被最后运行呢？ 看到最后一个被运行的项目是啥？没错，就是 S99local ，亦即是：/etc/rc.d/rc.local 这个文件啦！</p>

<p>使用者自订启动启动程序 (/etc/rc.d/rc.local)</p>

<p>在完成默认 runlevel 指定的各项服务的启动后，如果我还有其他的动作想要完成时，举例来说， 我还想要寄一封 mail 给某个系统管理帐号，通知他，系统刚刚重新启动完毕，那么是否应该要制作一个 shell script 放置在 /etc/init.d/ 里面，然后再以连结方式连结到 /etc/rc5.d/ 里面呢？呵呵！当然不需要！还记得上一小节提到的 /etc/rc.d/rc.local 吧？ 这个文件就可以运行您自己想要运行的系统命令了。</p>

<p>也就是说，我有任何想要在启动时就进行的工作时，直接将他写入 /etc/rc.d/rc.local ， 那么该工作就会在启动的时候自动被加载喔！而不必等我们登陆系统去启动呢！ 是否很方便啊！一般来说，鸟哥就很喜欢把自己制作的 shell script 完整档名写入 /etc/rc.d/rc.local ，如此一来，启动就会将我的 shell script 运行过，真是好棒那！</p>

<p>根据 /etc/inittab 之配置，加载终端机或 X-Window 介面</p>

<p>在完成了系统所有服务的启动后，接下来 Linux 就会启动终端机或者是 X Window 来等待使用者登陆啦！ 实际参考的项目是 /etc/inittab 内的这一段：
复制代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1:2345:respawn:/sbin/mingetty tty1
</span><span class='line'>2:2345:respawn:/sbin/mingetty tty2
</span><span class='line'>3:2345:respawn:/sbin/mingetty tty3
</span><span class='line'>4:2345:respawn:/sbin/mingetty tty4
</span><span class='line'>5:2345:respawn:/sbin/mingetty tty5
</span><span class='line'>6:2345:respawn:/sbin/mingetty tty6
</span><span class='line'>x:5:respawn:/etc/X11/prefdm -nodaemon</span></code></pre></td></tr></table></div></figure>


<p>复制代码</p>

<p>这一段代表，在 run level 2, 3, 4, 5 时，都会运行 /sbin/mingetty 这个咚咚， 而且运行六个，这也是为何我们 Linux 会提供『六个纯文字终端机』的配置所在啊！ 因为 mingetty 就是在启动终端机的命令说。</p>

<p>要注意的是那个 respawn 的 init 动作项目，他代表『当后面的命令被终止 (terminal) 时， init 会主动的重新启动该项目。』这也是为何我们登陆 tty1 终端机介面后，以 exit 离开后， 系统还是会重新显示等待使用者输入的画面的原因啊！</p>

<p>如果改天您不想要有六个终端机时，可以取消某些终端机介面吗？当然可以啊！ 就将上面表格当中的某些项目注解掉即可！例如不想要 tty5 与 tty6 ，就将那两行注解， 则下次重新启动后，您的 Linux 就只剩下『 F1 ~ F4 』有效而已，这样说，可以了解吧！！^_^</p>

<p>至於如果我们使用的是 run level 5 呢？那么除了这六个终端机之外， init 还会运行 /etc/X11/prefdm -nodaemon 那个命令喔！ 他主要的功能就是在启动 X Window 啦！</p>

<p>启动过程会用到的主要配置档</p>

<p>我们在 /sbin/init 的运行过程中有谈到许多运行脚本，包括 /etc/rc.d/rc.sysinit 以及 /etc/rc.d/rc 等等， 其实这些脚本都会使用到相当多的系统配置档，这些启动过程会用到的配置档则大多放置在 /etc/sysconfig/ 目录下。 同时，由於核心还是需要加载一些驱动程序 (核心模块)，此时系统自订的装置与模块对应档 (/etc/modprobe.conf) 就显的挺重要了喔！
关於模块： /etc/modprobe.conf</p>

<p>/etc/rc.d/rc.sysinit 当中的加载使用者自订模块的地方吗？就是在 /etc/sysconfig/modules/ 目录下啊！ 虽然核心提供的默认模块已经很足够我们使用了，但是，某些条件下我们还是得对模块进行一些参数的规划， 此时就得要使用到 /etc/modprobe.conf 罗！举例来说，鸟哥的 CentOS 主机的 modprobe.conf 有点像这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@www ~]# cat /etc/modprobe.conf
</span><span class='line'>alias eth0 8139too               &lt;==让 eth0 使用 8139too 的模块
</span><span class='line'>alias scsi_hostadapter pata_sis
</span><span class='line'>alias snd-card-0 snd-trident
</span><span class='line'>options snd-card-0 index=0       &lt;==额外指定 snd-card-0 的参数功能
</span><span class='line'>options snd-trident index=0</span></code></pre></td></tr></table></div></figure>


<p>以上表的第一行为例，鸟哥使用螃蟹卡 (Realtek 的芯片组) 来作为我的网络卡，那螃蟹卡使用的模块就是 8139too 啦！这样看的懂了吧？当我要启动网络卡时，系统会跑到这个文件来查阅一下，然后加载 8139too 驱动程序来驱动网络卡罗！更多的相关说明，请 man modprobe.conf 喔！这个文件大多在指定系统内的硬件所使用的模块啦！这个文件通常系统是可以自行产生的，所以你不必手动去订正他！ 不过，如果系统捉到错误的驱动程序，或者是你想要使用升级的驱动程序来对应相关的硬件配备时， 你就得要自行手动的处理一下这个文件了。
 /etc/sysconfig/*</p>

<p>不说您也知道，整个启动的过程当中，老是读取的一些服务的相关配置档都是记录在 /etc/sysconfig 目录下的！那么该目录底下有些啥玩意儿？我们找几个重要的文件来谈谈：</p>

<pre><code>authconfig：
这个文件主要在规范使用者的身份认证的机 制，包括是否使用本机的 /etc/passwd, /etc/shadow 等， 以及 /etc/shadow 口令记录使用何种加密演算法，还有是否使用外部口令服务器提供的帐号验证 (NIS, LDAP) 等。 系统默认使用 MD5 加密演算法，并且不使用外部的身份验证机制；
clock：
此文件在配置 Linux 主机的时区，可以使用格林威治时间(GMT)，也可以使用台湾的本地时间 (local)。基本上，在 clock 文件内的配置项目『 ZONE 』所参考的时区位於 /usr/share/zoneinfo 目录下的相对路径中。而且要修改时区的话，还得将 /usr/share/zoneinfo/Asia/Taipei 这个文件复制成为 /etc/localtime 才行！
i18n：
i18n 在配置一些语系的使用方面，例如最麻烦的文字介面下的日期显示问题！ 如果你是以中文安装的，那么默认语系会被选择 zh_TW.UTF8 ，所以在纯文字介面之下， 你的文件日期显示可能就会呈现乱码！这个时候就需要更改一下这里啦！更动这个 i18n 的文件，将里面的 LC_TIME 改成 en 即可！
keyboard &amp; mouse：
keyboard 与 mouse 就是在配置键盘与鼠标的形式；
network：
network 可以配置是否要启动网络，以及配置主机名称还有通讯闸 (GATEWAY) 这两个重要资讯呢！
network-scripts/：
至於 network-scripts 里面的文件，则是主要用在配置网络卡～
</code></pre>

<p>总而言之一句话，这个目录下的文件很重要的啦！启动过程里面常常会读取到的！</p>

<p>Run level 的切换</p>

<p>在我们完成上面的所有资讯后，其实整个 Linux 主机就已经在等待我们使用者的登陆啦！ 但是，相信您应该还是会有一点疑问的地方，那就是：『我该如何切换 run level 呢？』会不会很难啊？不会啦！很简单～但是依据运行的时间而有不同的方式啊！</p>

<p>事实上，与 run level 有关的启动其实是在 /etc/rc.d/rc.sysinit 运行完毕之后。也就是说，其实 run level 的不同仅是 /etc/rc[0-6].d 里面启动的服务不同而已。不过，依据启动是否自动进入不同 run level 的配置，我们可以说：</p>

<pre><code>要每次启动都运行某个默认的 run level ，则需要修改 /etc/inittab 内的配置项目， 亦即是『 id:5:initdefault: 』里头的数字啊；
如果仅只是暂时变更系统的 run level 时，则使用 init [0-6] 来进行 run level 的变更。 但下次重新启动时，依旧会是以 /etc/inittab 的配置为准。
</code></pre>

<p>假设原本我们是以 run level 5 登陆系统的，但是因为某些因素，想要切换成为 run level 3 时， 该怎么办呢？很简单啊，运行『 init 3 』即可切换。但是 init 3 这个动作到底做了什么呢？ 我们不是说了吗？事实上，不同的 run level 只是加载的服务不同罢了， 亦即是 /etc/rc5.d/ 还有 /etc/rc3.d 内的 Sxxname 与 Kxxname 有差异而已。 所以说，当运行 init 3 时，系统会：</p>

<pre><code>先比对 /etc/rc3.d/ 及 /etc/rc5.d 内的 K 与 S 开头的文件；
在新的 runlevel 亦即是 /etc/rc3.d/ 内有多的 K 开头文件，则予以关闭；
在新的 runlevel 亦即是 /etc/rc3.d/ 内有多的 S 开头文件，则予以启动；
</code></pre>

<p>也就是说，两个 run level 都存在的服务就不会被关闭啦！如此一来，就很容易切换 run level 了， 而且还不需要重新启动呢！真方便。那我怎么知道目前的 run level 是多少呢？ 直接在 bash 当中输入 runlevel 即可啊！
复制代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@www ~]# runlevel
</span><span class='line'>N 5
</span><span class='line'># 左边代表前一个 runlevel ，右边代表目前的 runlevel。
</span><span class='line'># 由於之前并没有切换过 runlevel ，因此前一个 runlevel 不存在 (N)
</span><span class='line'>
</span><span class='line'># 将目前的 runlevel 切换成为 3 (注意， tty7 的数据会消失！)
</span><span class='line'>[root@www ~]# init 3
</span><span class='line'>NIT: Sending processes the TERM signal
</span><span class='line'>Applying Intel CPU microcode update:        [  OK  ]
</span><span class='line'>Starting background readahead:              [  OK  ]
</span><span class='line'>Starting irqbalance:                        [  OK  ]
</span><span class='line'>Starting httpd:                             [  OK  ]
</span><span class='line'>Starting anacron:                           [  OK  ]
</span><span class='line'># 这代表，新的 runlevel 亦即是 runlevel3 比前一个 runlevel 多出了上述 5 个服务
</span><span class='line'>
</span><span class='line'>[root@www ~]# runlevel
</span><span class='line'>5 3
</span><span class='line'># 看吧！前一个是 runlevel 5 ，目前的是 runlevel 3 啦！</span></code></pre></td></tr></table></div></figure>


<p>复制代码</p>

<p>那么你能不能利用 init 来进行关机与重新启动呢？可以的啦！利用『 init 0 』就能够关机， 而『 init 6 』就能够重新启动！为什么？往前翻一下 runlevel 的定义即可了解吧！</p>

<p>转自 <a href="http://vbird.dic.ksu.edu.tw/linux_basic/0510osloader_1.php#startup_init">http://vbird.dic.ksu.edu.tw/linux_basic/0510osloader_1.php#startup_init</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[shell]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/shell/"/>
    <updated>2013-05-19T10:38:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/shell</id>
    <content type="html"><![CDATA[<p>很多人误以为shell脚本只能在命令行下使用。其实shell也可以调用一些GUI组件， 例如菜单，警告框，进度条等等。你可以控制最终的输出，光标位置还有各种输出效果。下面我将介绍一些工具，帮助你创建强大的，互动的，用户友好的 Unix/Linux shell脚本。我在FreeBSD和Linux下测试过这些工具，不过其他UNIX系列的操作系统应该都支持的。</p>

<ol>
<li>notify-send 命令</li>
</ol>


<p>这个命令可以让你通过通知进程发送一个桌面通知给用户。这可以用来向用户发送提示，或者显示一些信息而不用打断用户工作。你需要安装如下软件包：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo apt-get install libnotify-bin</span></code></pre></td></tr></table></div></figure>


<p>下面这个例子展示了如何从命令行向桌面发送一个简单的消息：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>notify-send “rsnapshot done \”static/image/smiley/default/smile.gif\”" smilieid=”\”1\”" alt=”\”\”" border=”\”0\”"&gt;”</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<p>下面是一个复杂一点的例子：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>….
</span><span class='line'>alert=18000
</span><span class='line'>live=$(lynx –dump http://money.rediff.com/ | grep ‘BSE LIVE’ | awk ‘{ print $5}’ | sed ‘s/,//g;s/\.[0-9]*//g’)
</span><span class='line'>[ $notify_counter -eq 0 ] && [ $live -ge $alert ] && { notify-send -t 5000 -u low -i  ”BSE Sensex touched 18k”;  notify_counter=1; }
</span><span class='line'>…</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<p>这里的参数解释如下：</p>

<pre><code>-t 5000：指定超时的时间，毫秒
-u low：设置是否紧急
-i gtk-dialog-info：通知图标，你可以指定图标 -i /path/to/your-icon.png
</code></pre>

<ol>
<li>tput 命令</li>
</ol>


<p>这个命令是用来设置终端特性的：</p>

<pre><code>  移动光标
  获得终端信息
  设置前景和背景色
  设置粗体模式
  设置反模式等等
</code></pre>

<p>举例：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'># clear the screen
</span><span class='line'>tput clear
</span><span class='line'># Move cursor to screen location X,Y (top left is 0,0)
</span><span class='line'>tput cup 3 15
</span><span class='line'># Set a foreground colour using ANSI escape
</span><span class='line'>tput setaf 3
</span><span class='line'>echo “XYX Corp LTD.”
</span><span class='line'>tput sgr0
</span><span class='line'>tput cup 5 17
</span><span class='line'># Set reverse video mode
</span><span class='line'>tput rev
</span><span class='line'>echo “M A I N – M E N U”
</span><span class='line'>tput sgr0
</span><span class='line'>tput cup 7 15
</span><span class='line'>echo “1. User Management”
</span><span class='line'>tput cup 8 15
</span><span class='line'>echo “2. Service Management”
</span><span class='line'>tput cup 9 15
</span><span class='line'>echo “3. Process Management”
</span><span class='line'>tput cup 10 15
</span><span class='line'>echo “4. Backup”
</span><span class='line'># Set bold mode
</span><span class='line'>tput bold
</span><span class='line'>tput cup 12 15
</span><span class='line'>read -p “Enter your choice [1-4] ” choice
</span><span class='line'>tput clear
</span><span class='line'>tput sgr0
</span><span class='line'>tput rc</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<ol>
<li>setleds 命令</li>
</ol>


<p>这个命令可以让你控制键盘灯，例如打开数字键盘灯：</p>

<p>PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>setleds -D +num</span></code></pre></td></tr></table></div></figure>


<p>关闭数字键盘灯：</p>

<p>PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>setleds -D -num
</span><span class='line'>
</span><span class='line'>  -caps: 清除大写灯
</span><span class='line'>  +caps：打开大写灯
</span><span class='line'>  -scroll：清除滚动锁
</span><span class='line'>  +scroll：打开滚动锁</span></code></pre></td></tr></table></div></figure>


<ol>
<li>zenity 命令</li>
</ol>


<p>这个命令可以显示GTK+的对话框，然后返回用户的输入。你可以用这个命令在脚本中显示信息，并要求用户输入信息。下面这段代码就是域名的whois查询：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'># Get domain name
</span><span class='line'>_zenity=”/usr/bin/zenity”
</span><span class='line'>_out=”/tmp/whois.output.[    DISCUZ_CODE_4    ]quot;
</span><span class='line'>domain=$(${_zenity} –title  ”Enter domain” \
</span><span class='line'>      –entry –text “Enter the domain you would like to see whois info” )
</span><span class='line'>if [ $? -eq 0 ]
</span><span class='line'>then
</span><span class='line'>  # Display a progress dialog while searching whois database
</span><span class='line'>  whois $domain  | tee &gt;(${_zenity} –width=200 –height=100 \
</span><span class='line'>        –title=”whois” –progress \
</span><span class='line'>        –pulsate –text=”Searching domain info…” \
</span><span class='line'>            –auto-kill –auto-close \
</span><span class='line'>            –percentage=10) &gt;${_out}
</span><span class='line'>  # Display back output
</span><span class='line'>  ${_zenity} –width=800 –height=600  \
</span><span class='line'>    –title “Whois info for $domain” \
</span><span class='line'>    –text-info –filename=”${_out}”
</span><span class='line'>else
</span><span class='line'>  ${_zenity} –error \
</span><span class='line'>    –text=”No input provided”
</span><span class='line'>fi</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<ol>
<li>kdialog 命令</li>
</ol>


<p>这个命令和zenity很想，只不过它是为KDE/QT应用准备的。使用方法如下：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>kdialog –dontagain myscript:nofilemsg –msgbox “File: ‘~/.backup/config’ not found.”</span></code></pre></td></tr></table></div></figure>


<p>输出</p>

<ol>
<li>Dialog</li>
</ol>


<p>这个命令可以在shell脚本中显示文本组件。它使用了curses和ncurses类库。示例代码：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&gt;#!/bin/bash
</span><span class='line'>dialog –title “Delete file” \
</span><span class='line'>–backtitle “Linux Shell Script Tutorial Example” \
</span><span class='line'>–yesno “Are you sure you want to permanently delete \”/tmp/foo.txt\”?” 7 60
</span><span class='line'># Get exit status
</span><span class='line'># 0 means user hit [yes] button.
</span><span class='line'># 1 means user hit [no] button.
</span><span class='line'># 255 means user hit [Esc] key.
</span><span class='line'>response=$?
</span><span class='line'>case $response in
</span><span class='line'>  0) echo “File deleted.”;;
</span><span class='line'>  1) echo “File not deleted.”;;
</span><span class='line'>  255) echo “[ESC] key pressed.”;;
</span><span class='line'>esac</span></code></pre></td></tr></table></div></figure>


<ol>
<li>logger 命令</li>
</ol>


<p>这个命令可以让你写入系统日志例如 /var/log/messages：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>logger “MySQL database backup failed.”
</span><span class='line'>tail -f /var/log/messages
</span><span class='line'>logger -t mysqld -p daemon.error “Database Server failed”
</span><span class='line'>tail -f /var/log/syslog</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Apr 20 00:11:45 vivek-desktop kernel: [38600.515354] CPU0: Temperature/speed normal
</span><span class='line'>
</span><span class='line'>Apr 20 00:12:20 vivek-desktop mysqld: Database Server failed</span></code></pre></td></tr></table></div></figure>


<ol>
<li>setterm 命令</li>
</ol>


<p>这个命令可以设置中断的属性。下面的例子是强制屏幕全黑15分钟，并且60分钟后把显示器设为待机状态：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>setterm -blank 15 -powersave powerdown -powerdown 60</span></code></pre></td></tr></table></div></figure>


<p>下面这段命令可以在中断显示加下划线的文字：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>setterm -underline on;
</span><span class='line'>echo “Add Your Important Message Here”
</span><span class='line'>setterm -underline off</span></code></pre></td></tr></table></div></figure>


<p>或者你可以关闭光标：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>setterm -cursor off</span></code></pre></td></tr></table></div></figure>


<ol>
<li>smbclient：向 MS-Windows 系统发送消息</li>
</ol>


<p>smbclient可以和 SMB/CIFS服务器通信。它可以向MS-Windows系统的指定用户发送消息：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>smbclient -M WinXPPro &lt;&lt;EOF
</span><span class='line'>Message 1
</span><span class='line'>Message 2
</span><span class='line'>…
</span><span class='line'>..
</span><span class='line'>EOF</span></code></pre></td></tr></table></div></figure>


<p>或者
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo “${Message}” | smbclient -M salesguy2
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Bash Socket 编程</li>
</ol>


<p>你可以在bash中开启一个socket链接，并且传输数据。Bash有两个特殊的设备文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  /dev/tcp/host/port – 如果hostname，和port是合法的话，bash会尝试开启一个TCP连接。
</span><span class='line'>  /dev/udp/host/port – 如果hostname和port是合法的话，bash会开启一个UDP连接。</span></code></pre></td></tr></table></div></figure>


<p>你可以利用这个技术来测试一台主机的端口是否是开启的，而不需要使用nmap或者port扫描器：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># find out if TCP port 25 open or not
</span><span class='line'>(echo &gt;/dev/tcp/localhost/25) &&gt;/dev/null && echo “TCP port 25 open” || echo “TCP port 25 close”</span></code></pre></td></tr></table></div></figure>


<p>你可以 使用循环来查找开着的端口：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>echo “Scanning TCP ports…”
</span><span class='line'>for p in {1..1023}
</span><span class='line'>do
</span><span class='line'>  (echo &gt;/dev/tcp/localhost/$p) &gt;/dev/null 2&gt;&1 && echo “$p open”
</span><span class='line'>done</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Scanning TCP ports…
</span><span class='line'>
</span><span class='line'>22 open
</span><span class='line'>
</span><span class='line'>53 open
</span><span class='line'>
</span><span class='line'>80 open
</span><span class='line'>
</span><span class='line'>139 open
</span><span class='line'>
</span><span class='line'>445 open
</span><span class='line'>
</span><span class='line'>631 open</span></code></pre></td></tr></table></div></figure>


<p>下面的这个例子让你的脚本扮演HTTP客户端：
PHP代码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>exec 3&lt;&gt; /dev/tcp/${1:-www.cyberciti.biz}/80
</span><span class='line'>printf “GET / HTTP/1.0\r\n” &gt;&3
</span><span class='line'>printf “Accept: text/html, text/plain\r\n” &gt;&3
</span><span class='line'>printf “Accept-Language: en\r\n” &gt;&3
</span><span class='line'>printf “User-Agent: nixCraft_BashScript v.%s\r\n” “${BASH_VERSION}”  &gt;&3
</span><span class='line'>printf “\r\n” &gt;&3
</span><span class='line'>while read LINE &lt;&3
</span><span class='line'>do
</span><span class='line'>  # do something on $LINE
</span><span class='line'>  # or send $LINE to grep or awk for grabbing data
</span><span class='line'>  # or simply display back data with echo command
</span><span class='line'>  echo $LINE
</span><span class='line'>done</span></code></pre></td></tr></table></div></figure>


<p>关于GUITools和Cronjob</p>

<p>如果你使用cronjob来调用你的脚本的话，你要通过“ export DISPLAY=[user&rsquo;s machine]:0”命令来设置本地的 display/input 服务。例如调用 /home/vivek/scripts/monitor.stock.sh脚本，它使用了 zenity 工具：
PHP代码</p>

<pre><code>@hourly DISPLAY=:0.0 /home/vivek/scripts/monitor.stock.sh
</code></pre>

<p>所有的命令你都可以通过“man”来查询详细的使用方式。</p>

<p>文章转载自：<a href="http://www.oschina.net/question/28_39527">http://www.oschina.net/question/28_39527</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网易笔试]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/wang-yi-bi-shi/"/>
    <updated>2013-05-19T10:31:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/wang-yi-bi-shi</id>
    <content type="html"><![CDATA[<p>应该说网易的这个笔试对我来说很简单~有那么几个点可以写出来</p>

<p>mysql 一些基础的应用</p>

<p>linux操作系统</p>

<p>tcp/ip</p>

<p>tcp/ip的三次握手过程~</p>

<p>vim/gcc/gdb的使用</p>

<p>进程线程端口号</p>

<p>文件的权限使用情况</p>

<p>大概就这么几点~总体难度不大的</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[企鹅实习生笔试]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/qi-e-shi-xi-sheng-bi-shi/"/>
    <updated>2013-05-19T10:31:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/qi-e-shi-xi-sheng-bi-shi</id>
    <content type="html"><![CDATA[<p>笔试的范围面算是比较广吧～涉及操作系统～数据结构和算法～网络～c/c++~软件工程~唉～还是太弱了～抱着打酱油的心去带回一大瓶酱油～还是得总结总结打有准备的仗~考到线程的并发~插入排序～tcp/ip~操作系统内存分配~~加油了～要有准备要努力啊</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这三天]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/zhe-san-tian/"/>
    <updated>2013-05-19T10:29:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/zhe-san-tian</id>
    <content type="html"><![CDATA[<p>逃了三天课，这三天来~也算是对三年来的验证吧。星期一，浙大玉泉校区参加163.com的笔试（sa反垃圾邮件工程师）,星期二，笔试太累,基本一天在实验室睡觉。今天去了趟滨江。在163.com的c座大厦里就吃了一个他们的小面包和一杯水。╮(╯▽╰)╭，不管结果如何~或许都得到历练了~
星期一，下午两点多，自个火急火燎的赶到浙大，看到玉泉校区才知道什么是读书人的地方，人家的校园，人家的读书氛围，看的像我这种二本掉渣的院校心里不是一般滋味.在里面逛了一圈后终于找到了曹光彪科技楼.晚上的宣讲会赵HR看起来很年轻，讲得很有渲染力。演讲的能力让我打心底里佩服。到场有三百多个人~大部分都是浙大~好不自卑吗~我是坐b1去的玉泉校区~然后我的笔试座位号也B1(神座啊)~八点的考试~主考官最后一个把考卷给我~算是从8:10开始的~我是9:01交的卷子~当时在场的我第三个交卷~自我感觉不错的~就赶着坐公交回下沙了~回到学校的时候已经10:30了~所以没回寝室~在实验室睡了一晚~还因此感冒了~杭州的天气还真是易变啊
星期二，因为笔试那天晚上赶着回来太累了~而且这一天就一节软件工程~所以逃了~也因HR告诉我们笔试的通知最晚在第二天的晚上告诉我们~这一天我是在焦虑中度过的~但我觉得自己的笔试很好~可以拿到面试的~晚上跟着老聂从实验室回去~吃了个饭洗了个澡~然后突然发现163.com的面试通知短信~很兴奋~跑去特地要老聂找去滨江的公交路线~一整晚睡得还可以~
今天~怎么说呢~一切的一切或许又回归了吧~今天又逃了一天的课~早上八点跑来实验室拿简历~九点的时候去书店给天师取快递~快十点的时候坐着566前往滨江~快中午的时候到达滨江~好久都不出去了~下车后有点找不着北的感觉~找了好久才找到面试的地点~快下午一点的时候开始前往面试地点~路上认识一位从上海赶过来的哥们~他研二搞安卓的~他说饿想找吃的~最后我们一起来到了163.com大厦的C座签到，发现面试区域居然提供吃喝~163.com的研究所所在地的确很偏僻~跟我一起的哥们也这么说~他一口气吃了两个面包~我们才坐下不久我就面试开始了~面我的是个很年轻的技术哥~他首先让我自我介绍~然后他开始看我的网上简历和我的笔试卷子~边看边问~当时也是脑子一片空白~随性也跟他扯起来~我记得他让我介绍了我的两个项目~一个是在线评判系统~另一个是ftp（半成品的项目）~我糊里糊涂的也不知道怎么说了~最后依稀记得他向我问了tcpdump和smtp协议~我记得笔试的卷有两道tcp/ip的题目~我答得都挺好的~一个是tcp的三次握手过程和那七层协议~其实我看到面试官手里我的卷子上打着一个不错的分数~心里窃喜啊~最后面试官让我问他问题~我问了几个后就不问了~然后他说面试结束了让我去面试区等待HR通知~走出来的时候我问面试官怎么不问shell啊？他没回答~他过了会问我课多吗~我随性的回答了~出来后发现跟我一起来的那哥们也刚面完出来~我们彼此谈了感受~期间他又吃了两个面包~我们在等待区侯着期间认识了一位中国科技大学的研一的也搞安卓的~他还没有面~他不断地询问都面了啥~我看了他的简历~光项目他就有了一页纸了~牛人啊~然后的然后~那个女HR告诉我结果~我没有追问为何~走出来的时候也挺释然的~╮(╯▽╰)╭╮(╯▽╰)╭~
一句话概括：面包挺好吃的，水也挺甜的~这三天也算是攒了经验值吧~结果已经不重要了~过程已经享受了~在此之前在群里也吼了好多~╮(╯▽╰)╭~回去洗个澡~睡个觉明天的太阳依旧灿烂~一个掉渣的二本院校的技术屌丝男的小逆袭？或许吧~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程之生产者于消费者问题]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/19/duo-xian-cheng-zhi-sheng-chan-zhe-yu-xiao-fei-zhe-wen-ti/"/>
    <updated>2013-05-19T10:26:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/19/duo-xian-cheng-zhi-sheng-chan-zhe-yu-xiao-fei-zhe-wen-ti</id>
    <content type="html"><![CDATA[<p>生产者线程向一缓冲区中写入数据~消费者线程从缓冲区中读取数据，由于生产者线程和消费者线程共享同一缓冲区，为了正确的读写数据，在使用缓冲队列时必须保持互至。生产者线程和消费者线程必须满足：生产者写入的缓冲区的数目不能超过缓冲区的容量，消费者线程读取的数目不能超过生产者写入的数目。初始化读写指针为0，如果读指针等于写指针。则缓冲区是空的~如果（写指针+1） % N 等于读指针，则缓冲区是满的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include&lt;stdio.h&gt;
</span><span class='line'>#include&lt;stdlib.h&gt;
</span><span class='line'>#include&lt;string.h&gt;
</span><span class='line'>#include&lt;sys/wait.h&gt;
</span><span class='line'>#include&lt;sys/types.h&gt;
</span><span class='line'>#include&lt;unistd.h&gt;
</span><span class='line'>#include&lt;pthread.h&gt;
</span><span class='line'>#include&lt;time.h&gt;
</span><span class='line'>#include&lt;math.h&gt;
</span><span class='line'>#define BUFFER_SIZE 8
</span><span class='line'>
</span><span class='line'>struct prodcons {
</span><span class='line'>int buffer[BUFFER_SIZE];
</span><span class='line'>pthread_mutex_t lock;
</span><span class='line'>int readpos,writepos;
</span><span class='line'>pthread_cond_t notempty;
</span><span class='line'>pthread_cond_t notfull;
</span><span class='line'>};
</span><span class='line'>
</span><span class='line'>void init(struct prodcons *b)
</span><span class='line'>{
</span><span class='line'>pthread_mutex_init(&b-&gt;lock,NULL);
</span><span class='line'>pthread_cond_init(&b-&gt;notempty,NULL);
</span><span class='line'>pthread_cond_init(&b-&gt;notfull,NULL);
</span><span class='line'>b-&gt;readpos = 0 ;
</span><span class='line'>b-&gt;writepos = 0 ;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void put(struct prodcons *b,int data)
</span><span class='line'>{
</span><span class='line'>pthread_mutex_lock(&b-&gt;lock);
</span><span class='line'>if((b-&gt;writepos + 1)%BUFFER_SIZE == b-&gt;readpos)
</span><span class='line'>{
</span><span class='line'>pthread_cond_wait(&b-&gt;notfull,&b-&gt;lock);
</span><span class='line'>}
</span><span class='line'>b-&gt;buffer[b-&gt;writepos] = data;
</span><span class='line'>b-&gt;writepos++;
</span><span class='line'>if(b-&gt;writepos &gt;= BUFFER_SIZE)
</span><span class='line'>b-&gt;writepos = 0;
</span><span class='line'>pthread_cond_signal(&b-&gt;notempty);
</span><span class='line'>pthread_mutex_unlock(&b-&gt;lock);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>int get(struct prodcons *b)
</span><span class='line'>{
</span><span class='line'>int data;
</span><span class='line'>pthread_mutex_lock(&b-&gt;lock);
</span><span class='line'>if(b-&gt;writepos == b-&gt;readpos)
</span><span class='line'>{
</span><span class='line'>pthread_cond_wait(&b-&gt;notempty,&b-&gt;lock);
</span><span class='line'>}
</span><span class='line'>data = b-&gt;buffer[b-&gt;readpos];
</span><span class='line'>b-&gt;readpos++;
</span><span class='line'>
</span><span class='line'>if(b-&gt;readpos &gt;= BUFFER_SIZE)
</span><span class='line'>b-&gt;readpos = 0;
</span><span class='line'>
</span><span class='line'>pthread_cond_signal(&b-&gt;notfull);
</span><span class='line'>pthread_mutex_unlock(&b-&gt;lock);
</span><span class='line'>return data;
</span><span class='line'>}
</span><span class='line'>#define OVER (-1)
</span><span class='line'>struct prodcons buffer;
</span><span class='line'>void *producer(void *data)
</span><span class='line'>{
</span><span class='line'>int n;
</span><span class='line'>for(n = 0 ; n &lt; 50 ; n++)
</span><span class='line'>{
</span><span class='line'>printf(“%d\t”,n);
</span><span class='line'>put(&buffer,n);
</span><span class='line'>}
</span><span class='line'>put(&buffer,OVER);
</span><span class='line'>return NULL;
</span><span class='line'>}
</span><span class='line'>void *consumer(void *data)
</span><span class='line'>{
</span><span class='line'>int d;
</span><span class='line'>while(1)
</span><span class='line'>{
</span><span class='line'>d = get(&buffer);
</span><span class='line'>if(d == OVER)
</span><span class='line'>break;
</span><span class='line'>printf(“%d\t”,d);
</span><span class='line'>}
</span><span class='line'>return NULL;
</span><span class='line'>}
</span><span class='line'>int main(void)
</span><span class='line'>{
</span><span class='line'>pthread_t th_a,th_b;
</span><span class='line'>void *retval;
</span><span class='line'>init(&buffer);
</span><span class='line'>pthread_create(&th_a,NULL,producer,0);
</span><span class='line'>pthread_create(&th_b,NULL,consumer,0);
</span><span class='line'>pthread_join(th_a,&retval);
</span><span class='line'>pthread_join(th_b,&retval);
</span><span class='line'>printf(“\n”);
</span><span class='line'>return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新交通规则]]></title>
    <link href="http://mdkvimer.github.io/blog/2013/05/18/xin-jiao-tong-gui-ze/"/>
    <updated>2013-05-18T22:49:00+08:00</updated>
    <id>http://mdkvimer.github.io/blog/2013/05/18/xin-jiao-tong-gui-ze</id>
    <content type="html"><![CDATA[<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   //before
</span><span class='line'>    if(light == “green”){
</span><span class='line'>      run();
</span><span class='line'>    }else if(light == “red”){
</span><span class='line'>      stop();
</span><span class='line'>    }else if(light == “yellow”){
</span><span class='line'>      holdOn();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    //now
</span><span class='line'>    if(light == “green”){
</span><span class='line'>      run();
</span><span class='line'>    }else if(light == “red”){
</span><span class='line'>      stop();
</span><span class='line'>    }else if(light == “yellow”){
</span><span class='line'>      stop();
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
